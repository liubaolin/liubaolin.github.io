<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mongoDB系列06-mongoDB事务操作</title>
    <url>/2021/04/05/mongoDB%E7%B3%BB%E5%88%9706-mongoDB%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB命令速查</title>
    <url>/2021/04/03/mongoDB%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">test    0.000GB</span><br></pre></td></tr></table></figure>

<h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; use test</span><br><span class="line">switched to db test</span><br></pre></td></tr></table></figure>
<h2 id="连接到一个指定的数据库"><a href="#连接到一个指定的数据库" class="headerlink" title="连接到一个指定的数据库"></a>连接到一个指定的数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; use test</span><br><span class="line">switched to db test</span><br></pre></td></tr></table></figure>

<h2 id="显示当前数据库对象或集合"><a href="#显示当前数据库对象或集合" class="headerlink" title="显示当前数据库对象或集合"></a>显示当前数据库对象或集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; db</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<h2 id="统计集合记录数"><a href="#统计集合记录数" class="headerlink" title="统计集合记录数"></a>统计集合记录数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.baseSe.count()</span><br></pre></td></tr></table></figure>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 分两步，先选中，再删除</span><br><span class="line">rs0:PRIMARY&gt; use ihr360_collections</span><br><span class="line">switched to db ihr360_collections</span><br><span class="line">rs0:PRIMARY&gt; db.dropDatabase()</span><br><span class="line">&#123;</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1617609515, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1617609515, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看指定数据库状态"><a href="#查看指定数据库状态" class="headerlink" title="查看指定数据库状态"></a>查看指定数据库状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.stats();</span><br><span class="line">&#123;</span><br><span class="line">	&quot;db&quot; : &quot;test&quot;,</span><br><span class="line">	&quot;collections&quot; : 98276,</span><br><span class="line">	&quot;views&quot; : 0,</span><br><span class="line">	&quot;objects&quot; : 10000002,</span><br><span class="line">	&quot;avgObjSize&quot; : 217.77775944444812,</span><br><span class="line">	&quot;dataSize&quot; : 2177778030,</span><br><span class="line">	&quot;storageSize&quot; : 793391104,</span><br><span class="line">	&quot;numExtents&quot; : 0,</span><br><span class="line">	&quot;indexes&quot; : 98276,</span><br><span class="line">	&quot;indexSize&quot; : 503685120,</span><br><span class="line">	&quot;scaleFactor&quot; : 1,</span><br><span class="line">	&quot;fsUsedSize&quot; : 53629050880,</span><br><span class="line">	&quot;fsTotalSize&quot; : 84014424064,</span><br><span class="line">	&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.drop()</span><br></pre></td></tr></table></figure>
<h2 id="查看数据库服务器的状态"><a href="#查看数据库服务器的状态" class="headerlink" title="查看数据库服务器的状态"></a>查看数据库服务器的状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.serverStatus()</span><br></pre></td></tr></table></figure>

<h2 id="查询指定数据库包含的集合名称列表"><a href="#查询指定数据库包含的集合名称列表" class="headerlink" title="查询指定数据库包含的集合名称列表"></a>查询指定数据库包含的集合名称列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.getCollectionNames()</span><br></pre></td></tr></table></figure>

<h1 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开启3000毫秒以上的慢查询记录</span><br><span class="line">db.setProfilingLevel(1,3000)</span><br><span class="line">&#x2F;&#x2F; 查看最近5条慢查询</span><br><span class="line">show profile</span><br><span class="line">&#x2F;&#x2F; 按照慢查询执行时间倒序查询</span><br><span class="line">db.system.profile.find().sort(&#123;&#39;millis&#39;:-1&#125;).pretty</span><br><span class="line">&#x2F;&#x2F; 查看查询计划</span><br><span class="line">db.TestCollection98252.find(&#123;$and:[&#123;&quot;name&quot;:&quot;Foo88888&quot;&#125;,&#123;&quot;age&quot;:88&#125;]&#125;).explain()</span><br><span class="line">&#x2F;&#x2F; 关闭慢查询记录</span><br><span class="line">db.setProfilingLevel(0)</span><br></pre></td></tr></table></figure>
<h2 id="停止超过一定时间的查询"><a href="#停止超过一定时间的查询" class="headerlink" title="停止超过一定时间的查询"></a>停止超过一定时间的查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.currentOp().inprog.forEach(</span><br><span class="line">function(item)&#123;</span><br><span class="line">if (item.secs_running &gt; 1000 ) </span><br><span class="line">db.killOp(item.opid);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="基本DDL和DML"><a href="#基本DDL和DML" class="headerlink" title="基本DDL和DML"></a>基本DDL和DML</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">&gt;db.collection.createIndex(keys, options)</span><br><span class="line">语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可</span><br><span class="line"></span><br><span class="line">&gt; db.TestCollection98252.createIndex(&#123;&quot;name&quot;:1&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;createdCollectionAutomatically&quot; : false,</span><br><span class="line">	&quot;numIndexesBefore&quot; : 1,</span><br><span class="line">	&quot;numIndexesAfter&quot; : 2,</span><br><span class="line">	&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用多个字段创建索引</span><br><span class="line">&gt; db.TestCollection98252.createIndex(&#123;&quot;name&quot;:1,&quot;age&quot;:-1&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;createdCollectionAutomatically&quot; : false,</span><br><span class="line">	&quot;numIndexesBefore&quot; : 1,</span><br><span class="line">	&quot;numIndexesAfter&quot; : 2,</span><br><span class="line">	&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.TestCollection98252.getIndexes()</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;v&quot; : 2,</span><br><span class="line">		&quot;key&quot; : &#123;</span><br><span class="line">			&quot;_id&quot; : 1</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">		&quot;ns&quot; : &quot;test.TestCollection98252&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;v&quot; : 2,</span><br><span class="line">		&quot;key&quot; : &#123;</span><br><span class="line">			&quot;name&quot; : 1</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;name&quot; : &quot;name_1&quot;,</span><br><span class="line">		&quot;ns&quot; : &quot;test.TestCollection98252&quot;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.TestCollection98252.dropIndex(&quot;name_1&quot;)</span><br><span class="line">&#123; &quot;nIndexesWas&quot; : 2, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; db.TestCollection98252.getIndexes()</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;v&quot; : 2,</span><br><span class="line">		&quot;key&quot; : &#123;</span><br><span class="line">			&quot;_id&quot; : 1</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">		&quot;ns&quot; : &quot;test.TestCollection98252&quot;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 删除当前集合所有索引</span><br><span class="line">db.TestCollection98252.dropIndex()</span><br></pre></td></tr></table></figure>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.page.reIndex()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB系列05-mongoDB数据模型设计</title>
    <url>/2021/03/21/mongoDB%E7%B3%BB%E5%88%9705-mongoDB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="JSON文档模型特点"><a href="#JSON文档模型特点" class="headerlink" title="JSON文档模型特点"></a>JSON文档模型特点</h1><p>在传统关系模型中需要多张表关联的模型，在json文档模型中可以通过一个表（集合）完成</p>
<p>文档模型设计主要考虑两点：性能和开发易用</p>
<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><ul>
<li>集合：同关系数据库中的表</li>
<li>字段：同关系数据库中的列</li>
<li>内嵌数组，引用字段：类似于关系数据库的主外键，关联关系</li>
</ul>
<h1 id="1-1关系建模"><a href="#1-1关系建模" class="headerlink" title="1-1关系建模"></a>1-1关系建模</h1><ul>
<li>一对一关系以内嵌为主,作为子文档形式或者直接在顶级</li>
<li>如果内嵌后导致文档大小超过16M,则不建议内嵌</li>
</ul>
<blockquote>
<p>mongoDB文档大小不能超过16M</p>
</blockquote>
<h1 id="1-N关系建模"><a href="#1-N关系建模" class="headerlink" title="1-N关系建模"></a>1-N关系建模</h1><ul>
<li>一对多关系同样以内嵌为主</li>
<li>用数组表示一对多</li>
<li>同样如果文档大小超过16M或数组长度太大（数万或更多）或数组长度不确定则不使用内嵌</li>
</ul>
<h1 id="N-N关系模型"><a href="#N-N关系模型" class="headerlink" title="N-N关系模型"></a>N-N关系模型</h1><ul>
<li><p>不通过映射表做，同样建议通过内嵌数组表示一对多，通过冗余来实现N-N</p>
</li>
<li><p>同样如果文档大小超过16M或数组长度太大（数万或更多）或数组长度不确定则不使用内嵌</p>
<p>在mongoDB里面有些时候是允许甚至鼓励做冗余的</p>
<p>在mongoDB建模中，内嵌是一种重要的方式,但是内嵌不是万能的，根据具体情况我也需要建立文档间的引用关系</p>
</li>
</ul>
<h1 id="根据业务需求细化建模"><a href="#根据业务需求细化建模" class="headerlink" title="根据业务需求细化建模"></a>根据业务需求细化建模</h1><p>首先要收集确认需求：</p>
<ul>
<li><p>读写比例</p>
</li>
<li><p>查询方式，比如查询最近几天，查询参数,以及最频繁的查询方式是什么</p>
</li>
<li><p>最频繁的写入方式是什么</p>
</li>
<li><p>数据量大小,将低频查询且数据量较大的数据单独集合保存，建立关联关系</p>
<p>基于这些需求，我们最终决定是使用引用来避免性能瓶颈还是使用冗余来优化访问性能.</p>
<p>比如内嵌模型通过冗余的方式实现N-N时，加入在数据量大的情况下，我们可能面临大量的修改操作(对冗余的数据进行修改),此时就需要设计为关联的方式,<br>将关联关系独立出一张表来，然后依然通过数组冗余的方式维护关系，只不过此时我们冗余的不是具体的数据，而是冗余表的主键数组</p>
<p>这种通过冗余+关联的设计，我们可以通过$lookup的方式进行（多表）查询，类似mysql中的join</p>
</li>
</ul>
<p>总结，什么时候应该使用引用的方式查询：</p>
<ul>
<li>内嵌文档太大，数MB或则超过16MB</li>
<li>内嵌文档或者数组元素会频繁修改</li>
<li>内嵌数组元素会持续增长且没有封顶</li>
</ul>
<h1 id="mongoDB引用设计的限制"><a href="#mongoDB引用设计的限制" class="headerlink" title="mongoDB引用设计的限制"></a>mongoDB引用设计的限制</h1><ul>
<li>引用集合之间无主外键检查</li>
<li>使用$lookup的方式模仿关联查询</li>
<li>$lookup只支持left outer join</li>
<li>$lookup的关联目标(from)不能是分片表</li>
</ul>
<h1 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h1><h2 id="分桶模式"><a href="#分桶模式" class="headerlink" title="分桶模式"></a>分桶模式</h2><p>批量保存概念，节省索引和公共字段的存储空间。</p>
<p>通过分桶模式可以大大减少文档数量和索引的占用空间</p>
<h2 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h2><p>将多列数据转换成一行数据，将多列的信息放到行内的数组中维护</p>
<p>这样如果我们本来需要对这些列建分别建索引（可能几十个），现在只需要建一个就够了.此模式解决的是索引过多的问题</p>
<p>索引太多影响插入效率的问题就解决了</p>
<p>注意的是只有这些列能抽象成一个对象表示时才可行(否则我们从语义上也无法实现列转行)</p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>模型灵活了，如何管理文档的不同版本？</p>
<p>可以增加一个版本字段：”schema_version”</p>
<p>这样我们可以根据版本进行过滤，同时可以根据版本进行规则设置</p>
<h2 id="近似计算"><a href="#近似计算" class="headerlink" title="近似计算"></a>近似计算</h2><p>对于请求量大同时准确性要求不高的统计，我们可以采用近似计算的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if random(0,9) &#x3D;&#x3D; 0</span><br><span class="line">  increment by 10</span><br></pre></td></tr></table></figure>

<p>可大量减少写入操作</p>
<h2 id="预聚合"><a href="#预聚合" class="headerlink" title="预聚合"></a>预聚合</h2><p>增加统计字段，在进行数据修改的同时，修改这些统计字段的值，这样就可以避免聚合查询带来的性能和资源问题。</p>
<p>这里是利用了mongoDB文档模型的灵活性，增加了聚合字段，而不影响正常业务数据</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB系列04-mongoDB复制集</title>
    <url>/2021/03/21/mongoDB%E7%B3%BB%E5%88%9704-mongoDB%E5%A4%8D%E5%88%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="复制集的作用"><a href="#复制集的作用" class="headerlink" title="复制集的作用"></a>复制集的作用</h1><ul>
<li>高可用：复制集主要是为了实现服务的高可用,mongoDB原生支持高可用.</li>
<li>数据分发：将数据从一个区域分发到另一个区域，减少另一个区域的读延迟</li>
<li>读写分离：降低节点压力</li>
<li>异地容灾：数据中心故障时迅速切换到异地</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>数据写入时,后台有进程会将数据迅速复制到另一个节点上</li>
<li>在接收写入的节点发生故障时，自动选举出一个新的代替节点</li>
</ul>
<h1 id="复制集结构"><a href="#复制集结构" class="headerlink" title="复制集结构"></a>复制集结构</h1><p>一般由3个以上（奇数个）具有投票权的节点组成，其中有：</p>
<ul>
<li>一个主节点(PRIMARY），接收写入操作和选举时投票；</li>
<li>两个或多个从节点（SECONDARY）,复制主节点的数据和选举时投票</li>
</ul>
<h1 id="数据如何复制"><a href="#数据如何复制" class="headerlink" title="数据如何复制"></a>数据如何复制</h1><ul>
<li>当一个修改操作（增删改）到达主节点时，它对数据的操作将被记录下来（经过一些必要的转换），这些记录称为aplog.</li>
<li>从节点通过在主节点上打开一个tailable游标不断获取新进入主节点的aplog，并在自己的数据库上回放，以此保持跟主节点上的数据一致.</li>
</ul>
<h1 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h1><ul>
<li>具有投票权的节点之间两两之间互相发送心跳</li>
<li>当5次心跳未收到时认为该节点失联，如果失联的是主节点，则从节点会发起选举，选出新的主节点，如果是从节点失联，则不会产生新的选举</li>
<li>选举基于RAFT一致性算法实现，选举成功的必要条件是大多数投票节点存活</li>
<li>复制集中最多可以有50个节点，但有投票权的节点最多有7个</li>
</ul>
<h1 id="影响选举的因素"><a href="#影响选举的因素" class="headerlink" title="影响选举的因素"></a>影响选举的因素</h1><ul>
<li>整个集群必须有大多数投票节点粗活</li>
<li>被选举的主节点必须<ul>
<li>包括自己在内，能够与多数节点建立连接</li>
<li>有较新的aplog</li>
<li>具有较高的优先级（如果有配置）</li>
</ul>
</li>
</ul>
<h1 id="复制集部署选项"><a href="#复制集部署选项" class="headerlink" title="复制集部署选项"></a>复制集部署选项</h1><ul>
<li>是否具有投票权（v参数）,默认是有的</li>
<li>优先级（priority参数），优先级越高的节点越优先成为主节点，优先级为0的节点无法成为主节点</li>
<li>隐藏（hidden参数），复制数据，但对应用不可见。隐藏节点可以具有投票权，但是优先级必须为0,隐藏数据主要用于备份，不希望被应用使用.</li>
<li>延迟（slveDely参数），复制n s之前的数据，保持于主节点的时间差.这个参数主要用于数据恢复，比如设置延迟一个小时，则数据可以恢复到一个小时之前。</li>
</ul>
<h1 id="复制集注意事项"><a href="#复制集注意事项" class="headerlink" title="复制集注意事项"></a>复制集注意事项</h1><ul>
<li>正常复制集节点都有可能成为主节点，所以它们的地位应该是一样的</li>
<li>为了保证节点不会同时宕机，各节点应该相互独立</li>
<li>复制集各节点的软件版本必须一致，避免出现未知的问题</li>
<li>增加节点不会增加系统的写性能,只能对读操作进行分流。要降低写操作的压力，需考虑分片部署的方式。</li>
</ul>
<h1 id="搭建mongoDB复制集"><a href="#搭建mongoDB复制集" class="headerlink" title="搭建mongoDB复制集"></a>搭建mongoDB复制集</h1><p>搭建一主两从的3节点复制集需要几步：</p>
<ul>
<li>启动3个mongoDB实例</li>
<li>将3个mongoDB实例搭建成一个复制集</li>
<li>对复制集参数进行一些常规调整</li>
</ul>
<h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><ul>
<li><p>安装最新的mongoDB版本，并配置好环境变量<a href="https://10000hours.top/2021/03/06/mongoDB%E7%B3%BB%E5%88%9702-mongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">安装mongoDB</a></p>
</li>
<li><p>确保有10G以上的硬盘空间</p>
</li>
</ul>
<h2 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h2><p>mongoDB启动的时候将使用一个数据目录存放所有的数据文件。我们先为3个复制集分别创建各自的数据目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;db&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>

<h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><p>在生成环境，不同的复制集实例应该运行在不同的服务器上。这里我们为了实验，需要在一台机器上运行3个mongoDB实例进程，因此需要对它们各自配置：</p>
<ul>
<li>不同的端口，28017、28018、28019</li>
<li>不同的数据目录 /data/db1 、/data/db2、/data/db3</li>
<li>不同的日志文件 /data/db1/mongod.log、/data/db1/mongod.log、/data/db1/mongod.log</li>
</ul>
<p>配置文件demo（/data/db1/mongod.conf)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">   destination: file</span><br><span class="line">   path: &quot;&#x2F;data&#x2F;db1&#x2F;mongod.log&quot;</span><br><span class="line">   logAppend: true</span><br><span class="line">storage:</span><br><span class="line">   dbPath: &#x2F;data&#x2F;db1</span><br><span class="line">   journal:</span><br><span class="line">      enabled: true</span><br><span class="line">processManagement:</span><br><span class="line">   fork: true # 作为后端进程独立运行</span><br><span class="line">net:</span><br><span class="line">   bindIp: 0.0.0.0 # 监听所有ip，默认只监听127.0.0.1,也就是只有本地可以访问</span><br><span class="line">   port: 28017</span><br><span class="line">replication:</span><br><span class="line">   replSetName: rs0 #复制集名称，没有此配置说明是单节点</span><br></pre></td></tr></table></figure>

<h2 id="准备好配置文件后，启动3个mongoDB实例"><a href="#准备好配置文件后，启动3个mongoDB实例" class="headerlink" title="准备好配置文件后，启动3个mongoDB实例"></a>准备好配置文件后，启动3个mongoDB实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod -f &#x2F;data&#x2F;db1&#x2F;mongod.conf </span><br><span class="line">mongod -f &#x2F;data&#x2F;db2&#x2F;mongod.conf </span><br><span class="line">mongod -f &#x2F;data&#x2F;db3&#x2F;mongod.conf </span><br><span class="line"></span><br><span class="line">#demo</span><br><span class="line">richey@localhost db1]$ mongod -f &#x2F;data&#x2F;db3&#x2F;mongod.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 20340</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>
<p>确认进程正在运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost db1]$ ps -ef|grep mongod</span><br><span class="line">richey   20033     1  0 15:36 ?        00:00:02 mongod -f &#x2F;data&#x2F;db1&#x2F;mongod.conf</span><br><span class="line">richey   20231     1  0 15:40 ?        00:00:01 mongod -f &#x2F;data&#x2F;db2&#x2F;mongod.conf</span><br><span class="line">richey   20340     1  0 15:43 ?        00:00:01 mongod -f &#x2F;data&#x2F;db3&#x2F;mongod.conf</span><br><span class="line">richey   20470 17013  0 15:46 pts&#x2F;4    00:00:00 grep --color&#x3D;auto mongod</span><br></pre></td></tr></table></figure>
<p>停止mongo服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost ~]$ mongod --shutdown -f &#x2F;data&#x2F;db1&#x2F;mongod.conf </span><br><span class="line">killing process with pid: 20033</span><br><span class="line">[richey@localhost ~]$ mongod --shutdown -f &#x2F;data&#x2F;db2&#x2F;mongod.conf </span><br><span class="line">killing process with pid: 20231</span><br><span class="line">[richey@localhost ~]$ mongod --shutdown -f &#x2F;data&#x2F;db3&#x2F;mongod.conf </span><br><span class="line">killing process with pid: 20340</span><br></pre></td></tr></table></figure>

<h1 id="配置复制集"><a href="#配置复制集" class="headerlink" title="配置复制集"></a>配置复制集</h1><p>我们已经启动了3个mongoDB实例，但目前为止它们是相互独立，互不相干的，我们需要对其进行配置，使其变成一个复制集.</p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>此方法hostname需要能被解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost ~]$ cat &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1 10000hours</span><br></pre></td></tr></table></figure>

<p>rs.initiate()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo localhost:28017</span><br><span class="line"></span><br><span class="line">&gt; rs.initiate()  # 初始化复制集</span><br><span class="line">&#123;</span><br><span class="line">	&quot;info2&quot; : &quot;no configuration specified. Using a default configuration for the set&quot;,</span><br><span class="line">	&quot;me&quot; : &quot;localhost.localdomain:28017&quot;,</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1616314186, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1616314186, 1)</span><br><span class="line">&#125;</span><br><span class="line">rs0:SECONDARY&gt; # 执行完rs.initiate() 变成从节点 </span><br><span class="line">rs0:PRIMARY&gt; # 再回车，变成主节点</span><br></pre></td></tr></table></figure>

<p>rs.add(“10000hours:28018”)</p>
<p>rs.add(“10000hours:28018”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; rs.add(&quot;10000hours:28018&quot;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1616314337, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1616314337, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; rs.add(&quot;10000hours:28019&quot;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1616314304, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1616314304, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看状态rs.status()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs0:PRIMARY&gt; rs.status()</span><br><span class="line">&#123;</span><br><span class="line">	&quot;set&quot; : &quot;rs0&quot;,</span><br><span class="line">	&quot;date&quot; : ISODate(&quot;2021-03-21T08:21:57.896Z&quot;),</span><br><span class="line">	&quot;myState&quot; : 1,</span><br><span class="line">	&quot;term&quot; : NumberLong(1),</span><br><span class="line">	&quot;syncingTo&quot; : &quot;&quot;,</span><br><span class="line">	&quot;syncSourceHost&quot; : &quot;&quot;,</span><br><span class="line">	&quot;syncSourceId&quot; : -1,</span><br><span class="line">	&quot;heartbeatIntervalMillis&quot; : NumberLong(2000),</span><br><span class="line">	&quot;majorityVoteCount&quot; : 2,</span><br><span class="line">	&quot;writeMajorityCount&quot; : 2,</span><br><span class="line">	&quot;optimes&quot; : &#123;</span><br><span class="line">		&quot;lastCommittedOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;lastCommittedWallTime&quot; : ISODate(&quot;2021-03-21T08:21:56.560Z&quot;),</span><br><span class="line">		&quot;readConcernMajorityOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;readConcernMajorityWallTime&quot; : ISODate(&quot;2021-03-21T08:21:56.560Z&quot;),</span><br><span class="line">		&quot;appliedOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;durableOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;lastAppliedWallTime&quot; : ISODate(&quot;2021-03-21T08:21:56.560Z&quot;),</span><br><span class="line">		&quot;lastDurableWallTime&quot; : ISODate(&quot;2021-03-21T08:21:56.560Z&quot;)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;lastStableRecoveryTimestamp&quot; : Timestamp(1616314906, 1),</span><br><span class="line">	&quot;lastStableCheckpointTimestamp&quot; : Timestamp(1616314906, 1),</span><br><span class="line">	&quot;electionCandidateMetrics&quot; : &#123;</span><br><span class="line">		&quot;lastElectionReason&quot; : &quot;electionTimeout&quot;,</span><br><span class="line">		&quot;lastElectionDate&quot; : ISODate(&quot;2021-03-21T08:09:46.529Z&quot;),</span><br><span class="line">		&quot;electionTerm&quot; : NumberLong(1),</span><br><span class="line">		&quot;lastCommittedOpTimeAtElection&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(0, 0),</span><br><span class="line">			&quot;t&quot; : NumberLong(-1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;lastSeenOpTimeAtElection&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1616314186, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(-1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;numVotesNeeded&quot; : 1,</span><br><span class="line">		&quot;priorityAtElection&quot; : 1,</span><br><span class="line">		&quot;electionTimeoutMillis&quot; : NumberLong(10000),</span><br><span class="line">		&quot;newTermStartDate&quot; : ISODate(&quot;2021-03-21T08:09:46.546Z&quot;),</span><br><span class="line">		&quot;wMajorityWriteAvailabilityDate&quot; : ISODate(&quot;2021-03-21T08:09:46.552Z&quot;)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;members&quot; : [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 0,</span><br><span class="line">			&quot;name&quot; : &quot;localhost.localdomain:28017&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 1,</span><br><span class="line">			&quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class="line">			&quot;uptime&quot; : 783,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(1)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-03-21T08:21:56Z&quot;),</span><br><span class="line">			&quot;syncingTo&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : -1,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;electionTime&quot; : Timestamp(1616314186, 2),</span><br><span class="line">			&quot;electionDate&quot; : ISODate(&quot;2021-03-21T08:09:46Z&quot;),</span><br><span class="line">			&quot;configVersion&quot; : 3,</span><br><span class="line">			&quot;self&quot; : true,</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 1,</span><br><span class="line">			&quot;name&quot; : &quot;10000hours:28019&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 2,</span><br><span class="line">			&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">			&quot;uptime&quot; : 613,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(1)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDurable&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(1)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-03-21T08:21:56Z&quot;),</span><br><span class="line">			&quot;optimeDurableDate&quot; : ISODate(&quot;2021-03-21T08:21:56Z&quot;),</span><br><span class="line">			&quot;lastHeartbeat&quot; : ISODate(&quot;2021-03-21T08:21:57.867Z&quot;),</span><br><span class="line">			&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2021-03-21T08:21:57.871Z&quot;),</span><br><span class="line">			&quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncingTo&quot; : &quot;localhost.localdomain:28017&quot;,</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;localhost.localdomain:28017&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : 0,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;configVersion&quot; : 3</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 2,</span><br><span class="line">			&quot;name&quot; : &quot;10000hours:28018&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 2,</span><br><span class="line">			&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">			&quot;uptime&quot; : 580,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(1)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDurable&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1616314916, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(1)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-03-21T08:21:56Z&quot;),</span><br><span class="line">			&quot;optimeDurableDate&quot; : ISODate(&quot;2021-03-21T08:21:56Z&quot;),</span><br><span class="line">			&quot;lastHeartbeat&quot; : ISODate(&quot;2021-03-21T08:21:57.867Z&quot;),</span><br><span class="line">			&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2021-03-21T08:21:57.565Z&quot;),</span><br><span class="line">			&quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncingTo&quot; : &quot;10000hours:28019&quot;,</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;10000hours:28019&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : 1,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;configVersion&quot; : 3</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1616314916, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1616314916, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>直接使用rs.initiate(),传入配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rs.initiate(&#123;</span><br><span class="line">        _id:&quot;rs0&quot;,</span><br><span class="line">        members:[</span><br><span class="line">        &#123;_id:0,</span><br><span class="line">        host:&quot;localhost:28017&quot;&#125;,</span><br><span class="line">        &#123;_id:1,</span><br><span class="line">        host:&quot;localhost:28018&quot;&#125;,</span><br><span class="line">        &#123;_id:2,</span><br><span class="line">        host:&quot;localhost:28019&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="验证复制集"><a href="#验证复制集" class="headerlink" title="验证复制集"></a>验证复制集</h1><p>在主节点插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo localhost:28017</span><br><span class="line">db.test.insert(&#123;name:&quot;richey&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>在从节点查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo localhost:28018</span><br><span class="line"></span><br><span class="line">rs0:SECONDARY&gt; show dbs</span><br><span class="line">2021-03-21T16:31:28.658+0800 E  QUERY    [js] uncaught exception: Error: listDatabases failed:&#123;</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1616315486, 1),</span><br><span class="line">	&quot;ok&quot; : 0,</span><br><span class="line">	&quot;errmsg&quot; : &quot;not master and slaveOk&#x3D;false&quot;,</span><br><span class="line">	&quot;code&quot; : 13435,</span><br><span class="line">	&quot;codeName&quot; : &quot;NotPrimaryNoSecondaryOk&quot;,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1616315486, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; :</span><br><span class="line">rs0:SECONDARY&gt; </span><br><span class="line">rs0:SECONDARY&gt; rs.slaveOk() # 上面报错，slave没有读权限，执行此命令允许从节点读</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>ulimit详解</title>
    <url>/2021/03/21/ulimit%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本地测试mongodb，大量创建Collection的时候报错open: Too many open files.这个问题主要指的是进程企图打开一个文件，或者叫句柄，但是现在进程打开的句柄已经达到了上限，已经无法打开新句柄了。</p>
<h1 id="Linux句柄介绍"><a href="#Linux句柄介绍" class="headerlink" title="Linux句柄介绍"></a>Linux句柄介绍</h1><p>Linux中所有的事物或资源都是以文件的形式存在，比如消息、共享内存、连接等，句柄可以理解为指向这些文件的指针。</p>
<h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>对于这些句柄，Linux是有数量限制的，单个进程默认可以打开的句柄数上限，可以用以下命令来查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost ~]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 62939</span><br><span class="line">max locked memory       (kbytes, -l) 16384</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 2000</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 62939</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>
<p>其中的open files一项就是默认的句柄数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit: ulimit [-SHabcdefiklmnpqrstuvxPT] [限制]</span><br><span class="line">    修改 shell 资源限制。</span><br><span class="line">    </span><br><span class="line">    在允许此类控制的系统上，提供对于 shell 及其创建的进程所可用的</span><br><span class="line">    资源的控制。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -S	使用软 (&#96;soft&#39;) 资源限制</span><br><span class="line">      -H	使用硬 (&#96;hard&#39;) 资源限制</span><br><span class="line">      -a	所有当前限制都被报告</span><br><span class="line">      -b	套接字缓存尺寸</span><br><span class="line">      -c	创建的核文件的最大尺寸</span><br><span class="line">      -d	一个进程的数据区的最大尺寸</span><br><span class="line">      -e	最高的调度优先级 (&#96;nice&#39;)</span><br><span class="line">      -f	有 shell 及其子进程可以写的最大文件尺寸</span><br><span class="line">      -i	最多的可以挂起的信号数</span><br><span class="line">      -k	分配给此进程的最大 kqueue 数量</span><br><span class="line">      -l	一个进程可以锁定的最大内存尺寸</span><br><span class="line">      -m	最大的内存进驻尺寸</span><br><span class="line">      -n	最多的打开的文件描述符个数</span><br><span class="line">      -p	管道缓冲区尺寸</span><br><span class="line">      -q	POSIX 信息队列的最大字节数</span><br><span class="line">      -r	实时调度的最大优先级</span><br><span class="line">      -s	最大栈尺寸</span><br><span class="line">      -t	最大的CPU时间，以秒为单位</span><br><span class="line">      -u	最大用户进程数</span><br><span class="line">      -v	虚拟内存尺寸</span><br><span class="line">      -x	最大的文件锁数量</span><br><span class="line">      -P	最大伪终端数量</span><br><span class="line">      -T	最大线程数量</span><br><span class="line">    </span><br><span class="line">    并非所有选项在所有系统上可用。</span><br><span class="line">    </span><br><span class="line">    如果提供了 LIMIT 变量，则它为指定资源的新的值；特别的 LIMIT 值为</span><br><span class="line">    &#96;soft&#39;、&#96;hard&#39;和&#96;unlimited&#39;，分别表示当前的软限制，硬限制和无限制。</span><br><span class="line">    否则打印指定资源的当前限制值，不带选项则假定为 -f</span><br><span class="line">    </span><br><span class="line">    取值都是 1024 字节为单位，除了 -t 以秒为单位，-p 以 512 字节递增，</span><br><span class="line">    -u 为无范围的进程数量。</span><br></pre></td></tr></table></figure>
<p>设置某个进程的句柄上限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit –a PID</span><br></pre></td></tr></table></figure>

<h1 id="ulimit配置文件"><a href="#ulimit配置文件" class="headerlink" title="ulimit配置文件"></a>ulimit配置文件</h1><p>使用ulimit方式修改句柄设置，在系统重启后会失效，可以通过修改配置文件的方式进行永久设置</p>
<p>配置文件地址：/etc/security/limits.conf</p>
<p>格式：<br>domain：可以是用户或者用户组 <em>代表所有<br>type：可以有三个值，soft 、 hard和-,其中hard的设置是实际的默认值，也就是上限，而soft的配置只是用来警告的，如果超过了soft的值，会有warn，而第三种用短横线– 的配置，则是hard和soft同时配置的方式。<br>item：表示要限定的资源 可以有很多候选值，如 stack（最大堆栈大小），cpu（占用cpu的时间），nofile（最大打开文件数） 等等<br>例：</em> hard nofile 100 该行配置语句限定了任意用户所能创建的最大文件数是 100。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* soft nofile 196605</span><br><span class="line">* hard nofile 196605</span><br></pre></td></tr></table></figure>

<p>修改后重启或重新ssh连接服务器，使用命令ulimit -a即可看到效果</p>
<h1 id="查询某个进程占用的句柄"><a href="#查询某个进程占用的句柄" class="headerlink" title="查询某个进程占用的句柄"></a>查询某个进程占用的句柄</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof |grep pid</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>mongoDB系列00-MongoDB数据库选型</title>
    <url>/2021/03/20/mongoDB%E7%B3%BB%E5%88%9700-MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">mock    0.047GB</span><br><span class="line">salary  0.000GB</span><br><span class="line">test    0.000GB</span><br><span class="line">&gt; use salary</span><br><span class="line">switched to db salary</span><br><span class="line">&gt; show collections</span><br><span class="line">payslip</span><br><span class="line">&gt; db</span><br><span class="line">salary</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB系列03-mongoDB聚合操作</title>
    <url>/2021/03/07/mongoDB%E7%B3%BB%E5%88%9703-mongoDB%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">mock    0.047GB</span><br><span class="line">salary  0.000GB</span><br><span class="line">test    0.000GB</span><br><span class="line">&gt; use salary</span><br><span class="line">switched to db salary</span><br><span class="line">&gt; show collections</span><br><span class="line">payslip</span><br><span class="line">&gt; db</span><br><span class="line">salary</span><br></pre></td></tr></table></figure>

<h1 id="聚合框架说明"><a href="#聚合框架说明" class="headerlink" title="聚合框架说明"></a>聚合框架说明</h1><p>MongoDB聚合框架（Aggregation Framework）是一个计算框架</p>
<p>可以作用在一个或几个集合上，对集合的数据进行一系列运算，将这些数据转化为期望的形式</p>
<p>MongoDB聚合框架相当于SQL查询中的:GROUPBY/LEFT OUTER JOIN /AS 等</p>
<p>MongoDB聚合中的管道（Pipline）和步骤（Stage）, 整个聚合运算的过程称为管道（Pipline），它是由多个步骤组成的,每个管道:</p>
<ul>
<li><p>接收一系列文档（数据）</p>
</li>
<li><p>每个步骤对这些文档进行一系列的运算</p>
</li>
<li><p>结果文档输出给下一个步骤</p>
</li>
</ul>
<h1 id="聚合运算的基本格式"><a href="#聚合运算的基本格式" class="headerlink" title="聚合运算的基本格式"></a>聚合运算的基本格式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义pipeline（由一系列的步骤组成）</span></span><br><span class="line">pipeline = [$stage1,$stage2,...$stageN]</span><br><span class="line"></span><br><span class="line">db.&lt;集合&gt;.aggregate(pipeline,&#123;options&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="常见步骤类型"><a href="#常见步骤类型" class="headerlink" title="常见步骤类型"></a>常见步骤类型</h1><ul>
<li><p>$match </p>
<p>过滤用，相当于sql中的where</p>
</li>
<li><p>$project </p>
<p>投影, 相当于sql中的as</p>
</li>
<li><p>$sort</p>
<p>排序， 相当于sql中的order by</p>
</li>
<li><p>$group </p>
<p>分组， 相当于sql中的group by</p>
</li>
<li><p>$skip/$limit</p>
<p>结果限制， 相当于sql中的skip/limit</p>
</li>
<li><p>$lookup </p>
<p>左外连接， 相当于sql中的left outer join </p>
</li>
</ul>
<p><img src="https://blog-pic-1254088127.picsh.myqcloud.com/mongo-aggregate-02.png" alt="常见步骤"></p>
<h1 id="常见步骤中的运算符"><a href="#常见步骤中的运算符" class="headerlink" title="常见步骤中的运算符"></a>常见步骤中的运算符</h1><p><img src="https://blog-pic-1254088127.picsh.myqcloud.com/mongo-aggregate-01.png" alt="group中常见运算符"></p>
<h1 id="聚合的使用场景"><a href="#聚合的使用场景" class="headerlink" title="聚合的使用场景"></a>聚合的使用场景</h1><ul>
<li><p>OLTP</p>
<p>计算</p>
</li>
<li><p>OLAP</p>
<p>分析总额、均值、数据分布等等</p>
</li>
</ul>
<h1 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h1><p>可以使用compass工具方便的生成聚合逻辑<br>//todo </p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s常用命令</title>
    <url>/2021/03/06/K8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th align="center">MongoDB术语/概念</th>
<th align="right">解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td align="center">database</td>
<td align="right">数据库</td>
</tr>
<tr>
<td>table</td>
<td align="center">collection</td>
<td align="right">数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td align="center">document</td>
<td align="right">数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td align="center">field</td>
<td align="right">数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td align="center">index</td>
<td align="right">索引</td>
</tr>
<tr>
<td>table joins</td>
<td align="center"></td>
<td align="right">表连接,MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td align="center">primary key</td>
<td align="right">主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>版本选择：</p>
<ul>
<li>企业版</li>
<li>社区版 所有环境免费使用</li>
<li>TGZ server mongos tools 和 shell</li>
</ul>
<p><a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener">下载地址:https://www.mongodb.com/try/download/community</a></p>
<p>选择好版本后可以生成下载连接,以命令行操作为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录,mongod 默认会使用/data/db目录进行数据存储</span></span><br><span class="line">sudo mkdir -p /data /data/db</span><br><span class="line"></span><br><span class="line">cd /data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载安装mongodb</span></span><br><span class="line">curl -O sudo curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩</span></span><br><span class="line"></span><br><span class="line">(base) [richey@localhost data]$ sudo tar -xvf mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz </span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/THIRD-PARTY-NOTICES.gotools</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/README</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/THIRD-PARTY-NOTICES</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/MPL-2</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/LICENSE-Community.txt</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongodump</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongorestore</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoexport</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoimport</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongostat</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongotop</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/bsondump</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongofiles</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoreplay</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongod</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongos</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongo</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/install_compass</span><br><span class="line">(base) [richey@localhost data]$ ls</span><br><span class="line">db  mongodb-linux-x86_64-rhel80-4.2.13-rc1  mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">export PATH=$PATH:/data/mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久配置</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">在文件最后添加：</span><br><span class="line">export PATH=$PATH:/data/mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin</span><br><span class="line">使配置立马剩下</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时mongodb就配置好了,可以输入mongod启动服务</span></span><br></pre></td></tr></table></figure>

<h1 id="直接使用mongodb云服务"><a href="#直接使用mongodb云服务" class="headerlink" title="直接使用mongodb云服务"></a>直接使用mongodb云服务</h1><p>也可以在mongodb官网直接注册，可以创建一个免费的mongodb云存储服务</p>
<p>创建好后可以配置连接方式，创建用户名密码<br><img src="https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas.png" alt="配置mongodb 云服务"></p>
<p>选择连接方式<br>![配置mongodb 云服务](<a href="https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas" target="_blank" rel="noopener">https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas</a> -2.png)</p>
<p>我们已经在本地安装了mongodb，可以选择在shell中连接，复制上面的地址在本地执行，输入密码即可连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MongoDB Enterprise atlas-zh2gha-shard-0:PRIMARY&gt; show dbs</span><br><span class="line">2021-03-06T16:11:21.925+0800 I  CONNPOOL [ReplicaSetMonitor-TaskExecutor] Connecting to cluster0-shard-00-02.leoli.mongodb.net:27017</span><br><span class="line">admin  0.000GB</span><br><span class="line">local  1.253GB</span><br></pre></td></tr></table></figure>


<h1 id="安装图形化管理工具Compass"><a href="#安装图形化管理工具Compass" class="headerlink" title="安装图形化管理工具Compass"></a>安装图形化管理工具Compass</h1><p>去官网下载合适的包,安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) [richey@localhost opt]$ sudo rpm -ivh mongodb-compass-1.26.0.x86_64.rpm </span><br><span class="line">警告：mongodb-compass-1.26.0.x86_64.rpm: 头V3 RSA&#x2F;SHA1 Signature, 密钥 ID ea312927: NOKEY</span><br><span class="line">Verifying...                          ################################# [100%]</span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级&#x2F;安装...</span><br><span class="line">   1:mongodb-compass-1.26.0-1.el7     ################################# [100%]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB系列02-mongoDB基本操作</title>
    <url>/2021/03/06/mongoDB%E7%B3%BB%E5%88%9702-mongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="intert插入操作"><a href="#intert插入操作" class="headerlink" title="intert插入操作"></a>intert插入操作</h1><p>db.&lt;集合&gt;.insertOne(&lt;JSON对象&gt;)<br>db.&lt;集合&gt;.insertMany([&lt;JSON 1&gt;,…<JSON n>])</p>
<p>demo:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.insertOne(&#123;name:&quot;Richey&quot;&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedId&quot; : ObjectId(&quot;60434c93b562b8d1012436aa&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.insertMany([&#123;name:&quot;Kelly&quot;&#125;,&#123;name:&quot;Darwin&quot;&#125;,&#123;name:&quot;Freeman&quot;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedIds&quot; : [</span><br><span class="line">		ObjectId(&quot;60434cffb562b8d1012436ab&quot;),</span><br><span class="line">		ObjectId(&quot;60434cffb562b8d1012436ac&quot;),</span><br><span class="line">		ObjectId(&quot;60434cffb562b8d1012436ad&quot;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434c93b562b8d1012436aa&quot;), &quot;name&quot; : &quot;Richey&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ab&quot;), &quot;name&quot; : &quot;Kelly&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ac&quot;), &quot;name&quot; : &quot;Darwin&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ad&quot;), &quot;name&quot; : &quot;Freeman&quot; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="find查找数据"><a href="#find查找数据" class="headerlink" title="find查找数据"></a>find查找数据</h1><p>查询所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;集合&gt;.find()</span><br></pre></td></tr></table></figure>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.insertMany([&#123;name:&quot;Jobs&quot;,age:18&#125;,&#123;name:&quot;Lili&quot;,gender:&quot;Female&quot;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedIds&quot; : [</span><br><span class="line">		ObjectId(&quot;60434f08b562b8d1012436ae&quot;),</span><br><span class="line">		ObjectId(&quot;60434f08b562b8d1012436af&quot;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">#单条件查询</span><br><span class="line"></span><br><span class="line">&gt; db.staff.find(&#123;&quot;age&quot;:18&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">#多条件and查询</span><br><span class="line">&gt; db.staff.find(&#123;&quot;name&quot;:&quot;Jobs&quot;,&quot;age&quot;:18&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">&gt; db.staff.find(&#123;$and:[&#123;&quot;name&quot;:&quot;Jobs&quot;&#125;,&#123;&quot;age&quot;:18&#125;]&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">#多条件or查询</span><br><span class="line">&gt; db.staff.find(&#123;$or:[&#123;&quot;age&quot;:18&#125;,&#123;&quot;gender&quot;:&quot;Female&quot;&#125;]&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436af&quot;), &quot;name&quot; : &quot;Lili&quot;, &quot;gender&quot; : &quot;Female&quot; &#125;</span><br><span class="line">#按正则表达式查询</span><br><span class="line"></span><br><span class="line">&gt; db.staff.find(&#123;&quot;name&quot;:&#x2F;^\b&#x2F;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434c93b562b8d1012436aa&quot;), &quot;name&quot; : &quot;Richey&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ab&quot;), &quot;name&quot; : &quot;Kelly&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ac&quot;), &quot;name&quot; : &quot;Darwin&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ad&quot;), &quot;name&quot; : &quot;Freeman&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436af&quot;), &quot;name&quot; : &quot;Lili&quot;, &quot;gender&quot; : &quot;Female&quot; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="find搜索子文档"><a href="#find搜索子文档" class="headerlink" title="find搜索子文档"></a>find搜索子文档</h2><p>find支持使用”field.sub_field”形式查询子文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.staff.insertOne(&#123;&quot;name&quot;:&quot;ZSan&quot;,&quot;age&quot;:28,&quot;addr&quot;:&#123;&quot;city&quot;:&quot;ShangHai&quot;,&quot;street&quot;:&quot;华夏西路188号&quot;&#125;&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedId&quot; : ObjectId(&quot;60435997b562b8d1012436b0&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.find(&#123;&quot;addr.city&quot;:&quot;ShangHai&quot;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435997b562b8d1012436b0&quot;), &quot;name&quot; : &quot;ZSan&quot;, &quot;age&quot; : 28, &quot;addr&quot; : &#123; &quot;city&quot; : &quot;ShangHai&quot;, &quot;street&quot; : &quot;华夏西路188号&quot; &#125; &#125;</span><br><span class="line"># 下面这种写法是错误的，子文档的查询应该用上面的写法</span><br><span class="line">&gt; db.staff.find(&#123;&quot;addr&quot;:&#123;&quot;city&quot;:&quot;ShangHai&quot;&#125;&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="find搜索数组"><a href="#find搜索数组" class="headerlink" title="find搜索数组"></a>find搜索数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.insertOne(&#123;&quot;name&quot;:&quot;LSi&quot;,&quot;food&quot;:[&quot;egg&quot;,&quot;bread&quot;,&quot;milk&quot;]&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedId&quot; : ObjectId(&quot;60435bbbb562b8d1012436b1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.find(&#123;&quot;food&quot;:&quot;egg&quot;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435bbbb562b8d1012436b1&quot;), &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br><span class="line">&gt; db.staff.find(&#123;$or:[&#123;&quot;food&quot;:&quot;egg&quot;&#125;,&#123;&quot;food&quot;:&quot;milk&quot;&#125;]&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435bbbb562b8d1012436b1&quot;), &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br></pre></td></tr></table></figure>
<p>数组中搜索子对象的多个字段时，用$elemMatch表示必须是同一个子对象满足多个条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.insertOne(&#123;&quot;name&quot;:&quot;WWu&quot;,&quot;favorite_books&quot;:[&#123;&quot;title&quot;:&quot;The Old Man and the Sea&quot;,&quot;author&quot;:&quot;Hemingway&quot;&#125;,&#123;&quot;title&quot;:&quot;围城&quot;,&quot;author&quot;:&quot;钱锺书&quot;&#125;]&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedId&quot; : ObjectId(&quot;60435df1b562b8d1012436b2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.find(&#123;&quot;favorite_books.title&quot;:&quot;The Old Man and the Sea&quot;,&quot;favorite_books.author&quot;:&quot;钱锺书&quot;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435df1b562b8d1012436b2&quot;), &quot;name&quot; : &quot;WWu&quot;, &quot;favorite_books&quot; : [ &#123; &quot;title&quot; : &quot;The Old Man and the Sea&quot;, &quot;author&quot; : &quot;Hemingway&quot; &#125;, &#123; &quot;title&quot; : &quot;围城&quot;, &quot;author&quot; : &quot;钱锺书&quot; &#125; ] &#125;</span><br><span class="line">&gt; db.staff.find(&#123;&quot;favorite_books&quot;:&#123;$elemMatch:&#123;&quot;title&quot;:&quot;The Old Man and the Sea&quot;,&quot;author&quot;:&quot;钱锺书&quot;&#125;&#125;&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="控制find返回的字段-投影projection"><a href="#控制find返回的字段-投影projection" class="headerlink" title="控制find返回的字段(投影projection)"></a>控制find返回的字段(投影projection)</h2><p>find可以指定只返回指定的字段</p>
<p>_id字段必须明确指定不返回，否则默认返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.find(&#123;$or:[&#123;&quot;food&quot;:&quot;egg&quot;&#125;,&#123;&quot;food&quot;:&quot;milk&quot;&#125;]&#125;,&#123;&quot;_id&quot;:0,&quot;name&quot;:1,&quot;food&quot;:1&#125;)</span><br><span class="line">&#123; &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.staff.find(&#123;&#125;,&#123;&quot;_id&quot;:0,&quot;name&quot;:1,&quot;food&quot;:1&#125;)</span><br><span class="line">&#123; &quot;name&quot; : &quot;Richey&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Kelly&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Darwin&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Freeman&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Jobs&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Lili&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;ZSan&quot; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;WWu&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用remove删除文档"><a href="#使用remove删除文档" class="headerlink" title="使用remove删除文档"></a>使用remove删除文档</h1><p>remove 命令必须配合查询条件使用，否则mongo会报错，需要要删除全部可以使用空条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434c93b562b8d1012436aa&quot;), &quot;name&quot; : &quot;Richey&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ab&quot;), &quot;name&quot; : &quot;Kelly&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ac&quot;), &quot;name&quot; : &quot;Darwin&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ad&quot;), &quot;name&quot; : &quot;Freeman&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436ae&quot;), &quot;name&quot; : &quot;Jobs&quot;, &quot;age&quot; : 18 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436af&quot;), &quot;name&quot; : &quot;Lili&quot;, &quot;gender&quot; : &quot;Female&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435997b562b8d1012436b0&quot;), &quot;name&quot; : &quot;ZSan&quot;, &quot;age&quot; : 28, &quot;addr&quot; : &#123; &quot;city&quot; : &quot;ShangHai&quot;, &quot;street&quot; : &quot;华夏西路188号&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435bbbb562b8d1012436b1&quot;), &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435df1b562b8d1012436b2&quot;), &quot;name&quot; : &quot;WWu&quot;, &quot;favorite_books&quot; : [ &#123; &quot;title&quot; : &quot;The Old Man and the Sea&quot;, &quot;author&quot; : &quot;Hemingway&quot; &#125;, &#123; &quot;title&quot; : &quot;围城&quot;, &quot;author&quot; : &quot;钱锺书&quot; &#125; ] &#125;</span><br><span class="line">&gt; db.staff.remove(&#123;&quot;name&quot;:&quot;Jobs&quot;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br><span class="line">&gt; db.staff.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434c93b562b8d1012436aa&quot;), &quot;name&quot; : &quot;Richey&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ab&quot;), &quot;name&quot; : &quot;Kelly&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ac&quot;), &quot;name&quot; : &quot;Darwin&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434cffb562b8d1012436ad&quot;), &quot;name&quot; : &quot;Freeman&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60434f08b562b8d1012436af&quot;), &quot;name&quot; : &quot;Lili&quot;, &quot;gender&quot; : &quot;Female&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435997b562b8d1012436b0&quot;), &quot;name&quot; : &quot;ZSan&quot;, &quot;age&quot; : 28, &quot;addr&quot; : &#123; &quot;city&quot; : &quot;ShangHai&quot;, &quot;street&quot; : &quot;华夏西路188号&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435bbbb562b8d1012436b1&quot;), &quot;name&quot; : &quot;LSi&quot;, &quot;food&quot; : [ &quot;egg&quot;, &quot;bread&quot;, &quot;milk&quot; ] &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60435df1b562b8d1012436b2&quot;), &quot;name&quot; : &quot;WWu&quot;, &quot;favorite_books&quot; : [ &#123; &quot;title&quot; : &quot;The Old Man and the Sea&quot;, &quot;author&quot; : &quot;Hemingway&quot; &#125;, &#123; &quot;title&quot; : &quot;围城&quot;, &quot;author&quot; : &quot;钱锺书&quot; &#125; ] &#125;</span><br><span class="line">&gt; db.staff.remove(&#123;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : 8 &#125;)</span><br><span class="line">&gt; db.staff.find()</span><br></pre></td></tr></table></figure>

<h1 id="使用update更新文档"><a href="#使用update更新文档" class="headerlink" title="使用update更新文档"></a>使用update更新文档</h1><p>db.&lt;集合&gt;.updat(&lt;查询条件&gt;,&lt;更新字段&gt;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.staff.insertMany([&#123;&quot;name&quot;:&quot;Richey&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;Kelly&quot;,&quot;age&quot;:20&#125;])</span><br><span class="line">&#123;</span><br><span class="line">	&quot;acknowledged&quot; : true,</span><br><span class="line">	&quot;insertedIds&quot; : [</span><br><span class="line">		ObjectId(&quot;60439f09b562b8d1012436b3&quot;),</span><br><span class="line">		ObjectId(&quot;60439f09b562b8d1012436b4&quot;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.staff.updateOne(&#123;&quot;name&quot;:&quot;Richey&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:24&#125;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line">&gt; db.staff.find(&#123;&quot;name&quot;:&quot;Richey&quot;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60439f09b562b8d1012436b3&quot;), &quot;name&quot; : &quot;Richey&quot;, &quot;age&quot; : 24 &#125;</span><br></pre></td></tr></table></figure>

<p>使用updateOne无论条件匹配多少条，都只会更新第一条</p>
<p>使用updateMany表示条件匹配多少条就更新多少条</p>
<p>使用updateOne/updateMany发方法要求更新条件部份（第二个参数）必须具有以下之一，否则报错：</p>
<ul>
<li>$set/$unset</li>
<li>$push/$pushAll/$pop</li>
<li>$pull/$pullAll</li>
<li>$addToSet</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$push :增加一个对象到数据底部</span><br><span class="line">$pushAll： 增加多个对象到数组底部</span><br><span class="line">$pop： 从数组底部删除一个对象</span><br><span class="line">$pull： 如果匹配指定的值，则从数组中删除相应的对象</span><br><span class="line">$pullAll： 如果匹配任意的值，则从数组中三处相应的对象</span><br><span class="line">$addToSet： 如果不存在则增加一个值到数组</span><br></pre></td></tr></table></figure>

<h1 id="使用drop删除集合"><a href="#使用drop删除集合" class="headerlink" title="使用drop删除集合"></a>使用drop删除集合</h1><p>db.&lt;集合&gt;.drop()</p>
<p>集合中的全部文档都会被删除</p>
<p>集合相关的索引也会被删除</p>
<p>一定要谨慎使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; show collections</span><br><span class="line">staff</span><br><span class="line">&gt; db.staff.drop()</span><br><span class="line">true</span><br><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure>

<h1 id="使用dropDatabase删除数据库"><a href="#使用dropDatabase删除数据库" class="headerlink" title="使用dropDatabase删除数据库"></a>使用dropDatabase删除数据库</h1><p>db.dropDatabase()</p>
<p>数据库相应的文件也会被删除，磁盘空间将被释放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">mock    0.047GB</span><br><span class="line">test    0.000GB</span><br><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; db.dropDatabase()</span><br><span class="line">&#123; &quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">mock    0.047GB</span><br><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure>


<h1 id="SQL和MQL查询逻辑对照"><a href="#SQL和MQL查询逻辑对照" class="headerlink" title="SQL和MQL查询逻辑对照"></a>SQL和MQL查询逻辑对照</h1><p><a href="https://docs.mongodb.com/manual/reference/sql-comparison/" target="_blank" rel="noopener">官方文档</a></p>
<p><img src="https://blog-pic-1254088127.picsh.myqcloud.com/sql-mapping-mql.png" alt="SQL-MAPPING-MQL"></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB系列01-mongoDB基础</title>
    <url>/2021/03/06/mongoDB%E7%B3%BB%E5%88%9701-mongoDB%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th align="center">MongoDB术语/概念</th>
<th align="right">解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td align="center">database</td>
<td align="right">数据库</td>
</tr>
<tr>
<td>table</td>
<td align="center">collection</td>
<td align="right">数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td align="center">document</td>
<td align="right">数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td align="center">field</td>
<td align="right">数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td align="center">index</td>
<td align="right">索引</td>
</tr>
<tr>
<td>table joins</td>
<td align="center"></td>
<td align="right">表连接,MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td align="center">primary key</td>
<td align="right">主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>版本选择：</p>
<ul>
<li>企业版</li>
<li>社区版 所有环境免费使用</li>
<li>TGZ server mongos tools 和 shell</li>
</ul>
<p><a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener">下载地址:https://www.mongodb.com/try/download/community</a></p>
<p>选择好版本后可以生成下载连接,以命令行操作为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录,mongod 默认会使用/data/db目录进行数据存储</span></span><br><span class="line">sudo mkdir -p /data /data/db</span><br><span class="line"></span><br><span class="line">cd /data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载安装mongodb</span></span><br><span class="line">curl -O sudo curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩</span></span><br><span class="line"></span><br><span class="line">(base) [richey@localhost data]$ sudo tar -xvf mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz </span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/THIRD-PARTY-NOTICES.gotools</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/README</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/THIRD-PARTY-NOTICES</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/MPL-2</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/LICENSE-Community.txt</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongodump</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongorestore</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoexport</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoimport</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongostat</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongotop</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/bsondump</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongofiles</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongoreplay</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongod</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongos</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/mongo</span><br><span class="line">mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin/install_compass</span><br><span class="line">(base) [richey@localhost data]$ ls</span><br><span class="line">db  mongodb-linux-x86_64-rhel80-4.2.13-rc1  mongodb-linux-x86_64-rhel80-4.2.13-rc1.tgz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">export PATH=$PATH:/data/mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久配置</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">在文件最后添加：</span><br><span class="line">export PATH=$PATH:/data/mongodb-linux-x86_64-rhel80-4.2.13-rc1/bin</span><br><span class="line">使配置立马剩下</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时mongodb就配置好了,可以输入mongod启动服务</span></span><br></pre></td></tr></table></figure>

<h1 id="直接使用mongodb云服务"><a href="#直接使用mongodb云服务" class="headerlink" title="直接使用mongodb云服务"></a>直接使用mongodb云服务</h1><p>也可以在mongodb官网直接注册，可以创建一个免费的mongodb云存储服务</p>
<p>创建好后可以配置连接方式，创建用户名密码<br><img src="https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas.png" alt="配置mongodb 云服务"></p>
<p>选择连接方式<br>![配置mongodb 云服务](<a href="https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas" target="_blank" rel="noopener">https://blog-pic-1254088127.picsh.myqcloud.com/Clusters-Atlas-MongoDB-Atlas</a> -2.png)</p>
<p>我们已经在本地安装了mongodb，可以选择在shell中连接，复制上面的地址在本地执行，输入密码即可连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MongoDB Enterprise atlas-zh2gha-shard-0:PRIMARY&gt; show dbs</span><br><span class="line">2021-03-06T16:11:21.925+0800 I  CONNPOOL [ReplicaSetMonitor-TaskExecutor] Connecting to cluster0-shard-00-02.leoli.mongodb.net:27017</span><br><span class="line">admin  0.000GB</span><br><span class="line">local  1.253GB</span><br></pre></td></tr></table></figure>


<h1 id="安装图形化管理工具Compass"><a href="#安装图形化管理工具Compass" class="headerlink" title="安装图形化管理工具Compass"></a>安装图形化管理工具Compass</h1><p>去官网下载合适的包,安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) [richey@localhost opt]$ sudo rpm -ivh mongodb-compass-1.26.0.x86_64.rpm </span><br><span class="line">警告：mongodb-compass-1.26.0.x86_64.rpm: 头V3 RSA&#x2F;SHA1 Signature, 密钥 ID ea312927: NOKEY</span><br><span class="line">Verifying...                          ################################# [100%]</span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级&#x2F;安装...</span><br><span class="line">   1:mongodb-compass-1.26.0-1.el7     ################################# [100%]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes04-集群搭建</title>
    <url>/2021/03/06/Kubernetes04-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="准备3台服务器"><a href="#准备3台服务器" class="headerlink" title="准备3台服务器"></a>准备3台服务器</h1><p>这里我们用虚拟机装3个节点：node1,node2,node3</p>
<p>如果安装的时候没有设置好主机名，可以手动再设置一下，给个名字方便操作：</p>
<p>hostnamectl set-hostname node1  //node2 node3</p>
<h2 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h2><p>最好将节点的ip设置成静态的（不能随便变）,这里3个节点装的是ubuntu 20.04 server,设置方法如下：</p>
<p>ifconfig //列出系统中所有连接的网络接口</p>
<p><img src="https://blog-pic-1254088127.picsh.myqcloud.com/ifconfig-20210523.png" alt="ifconfig"></p>
<p>我们将ens33以太网网络接口配置一个静态IP</p>
<p>vim /etc/netplan/xxx-yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">      addresses:</span><br><span class="line">      - 172.16.250.128&#x2F;24</span><br><span class="line">      dhcp4: false</span><br><span class="line">      gateway4: 172.16.250.2</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses:</span><br><span class="line">          - 8.8.8.8</span><br><span class="line">  version: 2</span><br></pre></td></tr></table></figure>
<p>如果YAML文件不是由发行版安装程序创建的，则可以使用此命令为渲染器生成所需的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br></pre></td></tr></table></figure>
<p>保存该文件并退出。然后使用以下netplan命令应用最近的网络更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>将3个节点全部设置成静态ip</p>
<h2 id="修改域名文件"><a href="#修改域名文件" class="headerlink" title="修改域名文件"></a>修改域名文件</h2><p>vim /etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.16.250.128 node1</span><br><span class="line">172.16.250.129 node2</span><br><span class="line">172.16.250.131 node3</span><br></pre></td></tr></table></figure>
<p>scp /etc/hosts <a href="mailto:root@172.16.250.129">root@172.16.250.129</a>:/etc/hosts<br>scp /etc/hosts <a href="mailto:root@172.16.250.131">root@172.16.250.131</a>:/etc/hosts</p>
<h1 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h1><p>务必保证3台服务器的时区是一样的，强制更改时区为上海，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -snf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br><span class="line">bash -c &quot;echo &#39;Asia&#x2F;Shanghai&#39; &gt; &#x2F;etc&#x2F;timezone&quot;</span><br></pre></td></tr></table></figure>

<p>安装ntpdate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y ntpdate</span><br></pre></td></tr></table></figure>
<p>如果出现以下错误：</p>
<p>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</p>
<p>执行2个命令解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;lock</span><br><span class="line">sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock</span><br></pre></td></tr></table></figure>

<p>使用阿里云的时间服务器更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpdate ntp1.aliyun.com</span><br><span class="line">i</span><br></pre></td></tr></table></figure>
<p>3台服务器都执行一下，确保时间一致.</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>所有节点都要安装。<br>如果使用docker作为k8s容器，则docker是必须要安装的。</p>
<p>更新apt源并添加https支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install apt-transport-https ca-certificates curl software-properties-common -y</span><br></pre></td></tr></table></figure>

<p>使用utc源添加GPG Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add</span><br></pre></td></tr></table></figure>

<p>添加Docker-ce稳定版源地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure>

<p>安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">apt-cache madison docker-ce &#x2F;&#x2F; List the versions available in your repo</span><br><span class="line">sudo apt install docker-ce&#x3D;5:19.03.9~3-0~ubuntu-focal</span><br></pre></td></tr></table></figure>



<p>3个节点都要安装</p>
<h1 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h1><ul>
<li>kubeadm：引导集群的命令。</li>
<li>kubelet：在群集中所有计算机上运行的组件，它执行诸如启动Pod和容器之类的操作。</li>
<li>kubectl：用于与您的集群通信的命令行工具。</li>
</ul>
<p>所有节点都需要安装：</p>
<p>添加apt key及源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install -y apt-transport-https curl</span><br><span class="line"></span><br><span class="line">curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">echo &quot;deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main&quot; &gt;&gt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y kubelet&#x3D;1.15.2-00 kubeadm&#x3D;1.15.2-00 kubectl&#x3D;1.15.2-00</span><br><span class="line">sudo apt-mark hold kubelet&#x3D;1.15.2-00 kubeadm&#x3D;1.15.2-00 kubectl&#x3D;1.15.2-00</span><br></pre></td></tr></table></figure>
<h1 id="禁用swap"><a href="#禁用swap" class="headerlink" title="禁用swap"></a>禁用swap</h1><p>所有节点都要操作（这里node1，node2，node3）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sed -i &#39;&#x2F;swap&#x2F; s&#x2F;^&#x2F;#&#x2F;&#39; &#x2F;etc&#x2F;fstab</span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure>


<h1 id="安装kubernetes集群"><a href="#安装kubernetes集群" class="headerlink" title="安装kubernetes集群"></a>安装kubernetes集群</h1><p>只在master节点安装即可，这里我们用node1做master节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --image-repository registry.aliyuncs.com&#x2F;google_containers --kubernetes-version v1.15.2 --pod-network-cidr&#x3D;192.169.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line">[init] Using Kubernetes version: v1.15.2</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;setup&#x2F;cri&#x2F;</span><br><span class="line">	[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.9. Latest validated version: 18.09</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;pki&quot;</span><br><span class="line">[certs] Generating &quot;etcd&#x2F;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd&#x2F;server&quot; certificate and key</span><br><span class="line">[certs] etcd&#x2F;server serving cert is signed for DNS names [node1 localhost] and IPs [172.16.250.128 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd&#x2F;peer&quot; certificate and key</span><br><span class="line">[certs] etcd&#x2F;peer serving cert is signed for DNS names [node1 localhost] and IPs [172.16.250.128 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd&#x2F;healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [node1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.16.250.128]</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;&#x2F;etc&#x2F;kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 16.004480 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.15&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node node1 as control-plane by adding the label &quot;node-role.kubernetes.io&#x2F;master&#x3D;&#39;&#39;&quot;</span><br><span class="line">[mark-control-plane] Marking the node node1 as control-plane by adding the taints [node-role.kubernetes.io&#x2F;master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: yq1qjo.00jrgi61fik1rnuc</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME&#x2F;.kube</span><br><span class="line">  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 172.16.250.128:6443 --token yq1qjo.00jrgi61fik1rnuc \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:fcb73171bb839f6dc6701880d9b863258f62992530aa04695e150798e56ef6ed</span><br></pre></td></tr></table></figure>

<p>这样就初始化成功了，注意警告信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;setup&#x2F;cri&#x2F;</span><br></pre></td></tr></table></figure>
<p>可以忽略，解决方法：</p>
<p>修改或者创建 vim /etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝kubeconfig文件到家目录的-kube目录"><a href="#拷贝kubeconfig文件到家目录的-kube目录" class="headerlink" title="拷贝kubeconfig文件到家目录的.kube目录"></a>拷贝kubeconfig文件到家目录的.kube目录</h1><p>只需要在master节点（这里我们是node1节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@node1:&#x2F;home&#x2F;richey# mkdir -p $HOME&#x2F;.kube</span><br><span class="line">root@node1:&#x2F;home&#x2F;richey# sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">root@node1:&#x2F;home&#x2F;richey# sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure>

<h1 id="安装网络插件，让pod之间通信"><a href="#安装网络插件，让pod之间通信" class="headerlink" title="安装网络插件，让pod之间通信"></a>安装网络插件，让pod之间通信</h1><p>只需要在master节点（这里我们是node1节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br><span class="line"></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure>

<h1 id="查看kube-system命名空间下的pod状态"><a href="#查看kube-system命名空间下的pod状态" class="headerlink" title="查看kube-system命名空间下的pod状态"></a>查看kube-system命名空间下的pod状态</h1><p>kubectl get pod -n kube-system</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@node1:&#x2F;home&#x2F;richey# kubectl get pod -n kube-system</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-bccdc95cf-6khq2         1&#x2F;1     Running   0          30m</span><br><span class="line">coredns-bccdc95cf-lk8j6         1&#x2F;1     Running   0          30m</span><br><span class="line">etcd-node1                      1&#x2F;1     Running   0          30m</span><br><span class="line">kube-apiserver-node1            1&#x2F;1     Running   0          30m</span><br><span class="line">kube-controller-manager-node1   1&#x2F;1     Running   0          29m</span><br><span class="line">kube-flannel-ds-cxt98           1&#x2F;1     Running   0          78s</span><br><span class="line">kube-proxy-56nt6                1&#x2F;1     Running   0          30m</span><br><span class="line">kube-scheduler-node1            1&#x2F;1     Running   0          29m</span><br></pre></td></tr></table></figure>

<h1 id="加入node节点"><a href="#加入node节点" class="headerlink" title="加入node节点"></a>加入node节点</h1><p>仅在node节点操作，在master节点执行kubeadm init时，最后会打印出加入node节点的命令，在每个node节点执行此命令，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.16.250.128:6443 --token yq1qjo.00jrgi61fik1rnuc \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:fcb73171bb839f6dc6701880d9b863258f62992530aa04695e150798e56ef6ed</span><br></pre></td></tr></table></figure>

<p>操作完后可以在主节点查看节点信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@node1:&#x2F;home&#x2F;richey# kubectl get nodes</span><br><span class="line">NAME    STATUS     ROLES    AGE   VERSION</span><br><span class="line">node1   Ready      master   34m   v1.15.2</span><br><span class="line">node2   NotReady   &lt;none&gt;   31s   v1.15.2</span><br><span class="line">node3   NotReady   &lt;none&gt;   25s   v1.15.2</span><br></pre></td></tr></table></figure>

<h1 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install bash-completion</span><br><span class="line"></span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">source  ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="部署dashboard可视化插件"><a href="#部署dashboard可视化插件" class="headerlink" title="部署dashboard可视化插件"></a>部署dashboard可视化插件</h1><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard</a></p>
<p>安装</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes03-Quick-Start</title>
    <url>/2021/03/06/Kubernetes03-Quick-Start/</url>
    <content><![CDATA[<h1 id="安装Minikube，快速启动一个单节点K8s环境"><a href="#安装Minikube，快速启动一个单节点K8s环境" class="headerlink" title="安装Minikube，快速启动一个单节点K8s环境"></a>安装Minikube，快速启动一个单节点K8s环境</h1><p><a href="https://kubernetes.io/zh/docs/tutorials/hello-minikube/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tutorials/hello-minikube/</a></p>
<h1 id="快速运行一个应用"><a href="#快速运行一个应用" class="headerlink" title="快速运行一个应用"></a>快速运行一个应用</h1><p>kubectl run可以创建所有组件而不需要JSON或YAML文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost config-exercise]$ kubectl run kubia --image&#x3D;luksa&#x2F;kubia --port&#x3D;8080 --generator&#x3D;run&#x2F;v1</span><br><span class="line">Flag --generator has been deprecated, has no effect and will be removed in the future.</span><br><span class="line">pod&#x2F;kubia created</span><br></pre></td></tr></table></figure>

<h1 id="查看pod"><a href="#查看pod" class="headerlink" title="查看pod"></a>查看pod</h1><p>kubectl get pods</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@localhost config-exercise]$ kubectl get pods -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia   1&#x2F;1     Running   0          3m57s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到这个pod有自己的ip，但是这个ip是集群内部的，在集群外无法访问，我们在集群外可以ping一下这个ip，是不通的。</p>
<h1 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h1><p>要想从集群外部访问pod，需要在集群中创建一个Service服务，Service用于访问集群内的pod，并对外提供可访问的ip。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose pod kubia --type&#x3D;LoadBalancer --name kubia-http</span><br><span class="line">service&#x2F;kubia-http exposed</span><br><span class="line">[richey@localhost config-exercise]$ kubectl get svc</span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443&#x2F;TCP          19h</span><br><span class="line">kubia-http   LoadBalancer   10.100.122.15   &lt;pending&gt;     8080:31222&#x2F;TCP   9s</span><br></pre></td></tr></table></figure>

<p>使用minikube不支持LoadBalance类型服务，因此服务不会有外部ip。可以运行minikube service kubia-http获取可以访问服务的ip和端口</p>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes02-基本概念</title>
    <url>/2021/03/06/Kubernetes02-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>Kubernetes中的基本构成模块,基本操作单元。<br>一个pod就是一组紧密管理的容器（也可能是一个）,它们一起运行在一个工作节点上，及同一个Linux命名空间中。<br>一个pod就像一个独立的逻辑机器，它有独立的IP、主机名、进程等。</p>
<h1 id="区别于容器"><a href="#区别于容器" class="headerlink" title="区别于容器"></a>区别于容器</h1><p>容器被设计成每个容器中只能运行一个进程，pod中可以运行多个容器（便于相关服务部署在一起）。</p>
<p>容器间彼此完全隔离，pod中的容器可以共享相同的命名空间，可以共享相同的主机名和端口,同样的这些容器在相同的IPC命名空间下运行，因此可以使用IPC进行通信。</p>
<p>可以通过localhost与同一个pod中的其它容器进行通讯。</p>
<h1 id="平坦pod间网络"><a href="#平坦pod间网络" class="headerlink" title="平坦pod间网络"></a>平坦pod间网络</h1><p>Kubernetes集群中的所有pod都是在同一个共享网络地址空间中。所以每个pod都可以通过访问其它pod 的ip地址实现相互访问。（它们之间没有NAT）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods &#x2F;&#x2F;列出pod</span><br><span class="line">kubectl describe pod pod-name &#x2F;&#x2F;查看具体pod的详细信息</span><br><span class="line">kubectl get pod my-pode-name -o yaml &#x2F;&#x2F; 查看pod的当前yaml配置</span><br></pre></td></tr></table></figure>

<h1 id="yaml文件重要参数"><a href="#yaml文件重要参数" class="headerlink" title="yaml文件重要参数"></a>yaml文件重要参数</h1><ul>
<li>metadata<br>包括名称、命名空间、标签和关于容器的其它信息</li>
<li>spec<br>包括pod的实际说明， 例如pod的容器、卷和其它数据</li>
<li>status<br>运行中的pod的当前信息，例如pod所处的条件、每个容器的描述和状态，以及内部ip和其它信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl explain pods &#x2F;&#x2F; 查看可能的api字段</span><br><span class="line">kubectl explain pods</span><br></pre></td></tr></table></figure>


<h2 id="访问pod"><a href="#访问pod" class="headerlink" title="访问pod"></a>访问pod</h2><p>pod有自己的IP，但是这个ip是集群内部的，不能从集群外部访问。</p>
<p>需要创建服务对象公开pod，服务对象是一个特殊的LoadBalanceer类型的服务，可以通过服务对外共该的ip访问pod。</p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>服务对象是一个特殊的LoadBalanceer类型的服务，可以通过服务对外共该的ip访问pod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get svc &#x2F;&#x2F;列出所有服务，-o wide 可查看详细数据</span><br><span class="line">&#x2F;&#x2F; 详细数据中的EXTERNAL-IP 是对外开放的ip</span><br></pre></td></tr></table></figure>

<h1 id="RS"><a href="#RS" class="headerlink" title="RS"></a>RS</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get rs &#x2F;&#x2F;查看rs信息，比如副本数</span><br><span class="line"></span><br><span class="line">kubectl scale rs my-rs-name  --replicas&#x3D;3 &#x2F;&#x2F;修改副本数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes01-命令速查</title>
    <url>/2021/03/06/Kubernetes01-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="展示集群信息"><a href="#展示集群信息" class="headerlink" title="展示集群信息"></a>展示集群信息</h1><p>kubectl cluster-info</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@k8s-master-dev:&#x2F;home&#x2F;richey kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;192.168.1.217:8443</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;192.168.1.217:8443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br></pre></td></tr></table></figure>
<h1 id="列出集群节点"><a href="#列出集群节点" class="headerlink" title="列出集群节点"></a>列出集群节点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<h1 id="查看节点的详细信息"><a href="#查看节点的详细信息" class="headerlink" title="查看节点的详细信息"></a>查看节点的详细信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe node node-name</span><br><span class="line">kubectl describe node &#x2F;&#x2F;不指定具体的node名，将展示所有的</span><br></pre></td></tr></table></figure>

<h1 id="为kubectl配置别名和命令补齐"><a href="#为kubectl配置别名和命令补齐" class="headerlink" title="为kubectl配置别名和命令补齐"></a>为kubectl配置别名和命令补齐</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias k&#x3D;kubectl &#x2F;&#x2F;将此命令添加到~&#x2F;.bashrc文件中</span><br></pre></td></tr></table></figure>

<h1 id="列出pod"><a href="#列出pod" class="headerlink" title="列出pod"></a>列出pod</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<h1 id="查看pod的yaml文件"><a href="#查看pod的yaml文件" class="headerlink" title="查看pod的yaml文件"></a>查看pod的yaml文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod my-pode-name -o yaml  &#x2F;&#x2F;通过 -o yaml参数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>python-操作mongodb</title>
    <url>/2021/03/01/python-%E6%93%8D%E4%BD%9Cmongodb/</url>
    <content><![CDATA[<h1 id="安装Python-MongoDB驱动"><a href="#安装Python-MongoDB驱动" class="headerlink" title="安装Python MongoDB驱动"></a>安装Python MongoDB驱动</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pymongo</span><br><span class="line">``` </span><br><span class="line"><span class="comment"># 检查驱动安装</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pymongo.version</span><br><span class="line"><span class="string">'3.11.3'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uri = <span class="string">"mongodb://127.0.0.1:27017"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = MongoClient(uri)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(client)</span><br><span class="line">MongoClient(host=[<span class="string">'127.0.0.1:27017'</span>], document_class=dict, tz_aware=<span class="literal">False</span>, connect=<span class="literal">True</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="操作数据库和集合"><a href="#操作数据库和集合" class="headerlink" title="操作数据库和集合"></a>操作数据库和集合</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = client[<span class="string">"salary"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payslip_collection = db[<span class="string">"payslip"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_payslip = &#123;<span class="string">"basesalary"</span>:<span class="number">2800</span>,<span class="string">"bonus"</span>:<span class="number">8000</span>,<span class="string">"performances"</span>:<span class="number">1600</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = payslip_collection.insert_one(new_payslip)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;pymongo.results.InsertOneResult object at <span class="number">0x7fd8ee8cdf00</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">mock    <span class="number">0.047</span>GB</span><br><span class="line">salary  <span class="number">0.000</span>GB</span><br><span class="line">test    <span class="number">0.000</span>GB</span><br><span class="line">&gt; use salary</span><br><span class="line">switched to db salary</span><br><span class="line">&gt; show collections</span><br><span class="line">payslip</span><br><span class="line">&gt; db.payslip.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"6044a74ca6868ddcfa42c426"</span>), <span class="string">"basesalary"</span> : <span class="number">2800</span>, <span class="string">"bonus"</span> : <span class="number">8000</span>, <span class="string">"performances"</span> : <span class="number">1600</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h1 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = payslip_collection.update_one(&#123;<span class="string">"basesalary"</span>:<span class="number">2800</span>&#125;,&#123;<span class="string">"$set"</span>:&#123;<span class="string">"positionsalary"</span>:<span class="number">3000</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.payslip.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"6044a74ca6868ddcfa42c426"</span>), <span class="string">"basesalary"</span> : <span class="number">2800</span>, <span class="string">"bonus"</span> : <span class="number">8000</span>, <span class="string">"performances"</span> : <span class="number">1600</span>, <span class="string">"positionsalary"</span> : <span class="number">3000</span> &#125;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里不需要修改数据库表结构</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Phthon</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka重平衡（Rebalance）</title>
    <url>/2021/02/20/Kafka%E9%87%8D%E5%B9%B3%E8%A1%A1%EF%BC%88Rebalance%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是Rebalance"><a href="#什么是Rebalance" class="headerlink" title="什么是Rebalance"></a>什么是Rebalance</h1><p>首先要搞清楚，为什么要Rebalance：由于消费者组订阅了topic，因topic partition数和消费者组成员个数不同而存在的分配机制。</p>
<p>Rebalance是让Consumer Group下所有的Consumer重新分配Topic的每个分区的过程。</p>
<p>Rebalance过程所有的consumer都会参与，在协调者组件（Coordinator）的帮助下，完成主题分区的分配。</p>
<p>整个Rebalance过程，所有Consumer都不能消费，而且这个过程比较慢。</p>
<h1 id="什么时候会Rebalance"><a href="#什么时候会Rebalance" class="headerlink" title="什么时候会Rebalance"></a>什么时候会Rebalance</h1><p>有三种情况会触发Rebalance：</p>
<ol>
<li><p>有新的Consumer加入Consumer Group</p>
</li>
<li><p>Consumer Group订阅的主题数量发生变化</p>
</li>
<li><p>Consumer Group订阅的主题的数量发生变化</p>
</li>
</ol>
<p>Rebalance时Consumer Group内所有的consumer都会参与。</p>
<h1 id="如何避免Rebalance"><a href="#如何避免Rebalance" class="headerlink" title="如何避免Rebalance"></a>如何避免Rebalance</h1><p>上面说了有三种情况会发生Rebalance，只要这三种情况的任一情况发生，都必然会产生Rebalance。这三种情况有些是计划内的，比如增加一个Consumer，调整分区数，添加或减少<br>某个主题的订阅。</p>
<p>我们只能尽量避免那些必不要的Rebalance，比如某些情况Consumer被Coordinator错误的认为已停止，从而被提出Consumer Group。</p>
<ul>
<li><p>Coordinator什么情况会认为Consumer已停止？</p>
<p>Consumer会定时往Coordinator发送心跳，证明它还活着。如果Consumer不能及时的发送这个心跳请求，就会被Coordinator认为已经死了，从而将其从Group中移除，然后进行Rebalance。<br>Consumer端的参数session.timeout.ms决定了Consumer存活性的时间间隔，默认10s，即Coordinator如果10s内没有收到Consuner的心跳请求，即认为Consumer死亡。</p>
<p>Consumer参数heartbeat.interval.ms 控制的是Consumer端发送心跳请求的间隔。这个值越小心跳频次发送的越高，占用带宽越多，但是可以更快的知道是否需要Rebalance，<br>因为Coordinator通知各个Consumer机型Rabalance的方式就是将 REBALANCE_NEEDED 标志封装进心跳请求的响应体中。</p>
<p>Consumer参数 max.poll.interval.ms 限定了Consumer端两次调用poll方法的最大时间间隔，默认5分钟。即如果在5分钟内无法完成poll方法返回的消息，则Consumer会主动发起离开组的请求，Coorditator也会开始新一轮的Rabalance.也可以修改max.poll.records参数，减少一次poll拉取的消息数，从而减少消费时间。</p>
<p>Consumer参数说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session.timeout.ms 决定了 Consumer 存活性的时间间隔</span><br><span class="line">heartbeat.interval.ms 控制的是Consumer端发送心跳请求的间隔</span><br><span class="line">max.poll.interval.ms 限定了Consumer端两次调用poll方法的最大时间间隔（即是处理一次poll方法返回消息的最大允许时间）</span><br></pre></td></tr></table></figure>
</li>
<li><p>Consumer未及时发送心跳导致的Rebalance</p>
<p>上面我们说了Consumer发送的心跳频次的参数和Coordinator认为Consumer死亡时间的参数。所以为了避免Coordinator错误的判断Consumer死亡的发生，我们要在较短的时间内，较多的发送请求。推荐参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在Coordinator认为Consumer死亡之前（6s内），发送三次心跳请求</span><br><span class="line">session.timeout.ms &#x3D; 6s</span><br><span class="line">heartbeat.interval.ms &#x3D; 2s</span><br></pre></td></tr></table></figure>
</li>
<li><p>Consumer消费时间过长导致的Rebalance</p>
<p>上面说了max.poll.interval.ms时间内Consumer没有消费完上次poll拉取的消息，则Consumber会主动请求离开组，然后Coordinator进行Rebalance。<br>所以需要了解业务处理时间，合理的设置max.poll.interval.ms</p>
</li>
</ul>
<ul>
<li><p>频繁Full GC引起的Rebalance</p>
<p>Full GC导致的长时间停顿，导致业务没有在正常时间内处理完，触发max.poll.interval.ms超时时间，产生Rebalance。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter环境搭建</title>
    <url>/2021/02/20/jupyter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ol>
<li>安装anaconda</li>
<li>pycharm中新建项目配置环境变量为conda</li>
<li>安装必要的包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple pandas jupyter xlrd openpyxl pillow matplotlib seaborn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Phthon</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python库-Pandas说明</title>
    <url>/2021/02/19/Python%E5%BA%93-Pandas%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://pandas.pydata.org/docs/index.html" target="_blank" rel="noopener">pandas官网</a><br>pandas 是用来做数据分析的一个工具库，为Python编程语言提供高性能、易用的数据结构和数据分析工具</p>
<p>也可以简单的认为pandans是Python中的excel表</p>
<h1 id="对比列表-numpy-pandas"><a href="#对比列表-numpy-pandas" class="headerlink" title="对比列表/numpy/pandas"></a>对比列表/numpy/pandas</h1><ul>
<li><p>列表里的元素可以是python中的任意对象，使用方便，但是存在性能问题</p>
</li>
<li><p>numpy 是一个多维的数组结构，区别于列表，numpy只能保存同一类型的数据，通常为数值型，numpy大大提高了对于数据类型的计算效率</p>
</li>
<li><p>pandas 构建在numpy之上，继承了numpy的高效，同时又更易于使用</p>
<p><img src="https://blog-pic-1254088127.picsh.myqcloud.com/python-list-nunpy-pandas.png" alt="list-numpy-pandas"></p>
</li>
</ul>
<p>易用性示例：</p>
<p>  <img src="https://blog-pic-1254088127.picsh.myqcloud.com/pandas02.png" alt="pandas"></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>pandas 没有3维及以上数据结构</p>
<ol>
<li><p>Seris</p>
<p>一维数据</p>
</li>
<li><p>DataFrame</p>
<p>二维数据,DataFrame中的每一列都是Seris</p>
<p>read_excel</p>
<p>to_excel</p>
<p>append() 上下拼接多个表格</p>
<p>join（） 左右拼接两个表格</p>
<p>concat() 通过设置axis参数，上下或左右拼接多个表格</p>
<p>merge() 相当于excel中的vlookup，通过同一列相同的元素把两个表格合并在一起</p>
<p>pivot_table 相当于excel中的透视操作</p>
<p>rolling() 固定窗口滚动操作</p>
<p>expanding() 扩展窗口操作</p>
</li>
</ol>
<h1 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<pre><code>0    1
1    2
2    3
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              index=list(<span class="string">'abc'</span>),</span><br><span class="line">              dtype=<span class="string">'int64'</span>,</span><br><span class="line">              name=<span class="string">'num'</span>)</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<pre><code>a    1
b    2
c    3
Name: num, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">s = pd.Series(d)</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<pre><code>a    1
b    2
c    3
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(<span class="number">3.0</span>,index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<pre><code>a    3.0
b    3.0
c    3.0
dtype: float64</code></pre><p>实际开发中，我们一般通过读取Excel创建</p>
<h1 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h1><ul>
<li>通过二维list-like创建</li>
<li>通过字典创建</li>
<li>通过读取Excel表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_2d = [[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">           [<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(list_2d)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(list_2d,</span><br><span class="line">                  columns=[<span class="string">'A'</span>,<span class="string">'B'</span>],</span><br><span class="line">                  index=[<span class="string">'x'</span>,<span class="string">'y'</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'A'</span>:[<span class="number">1</span>,<span class="number">3</span>],<span class="string">'B'</span>:[<span class="number">2</span>,<span class="number">4</span>]&#125;</span><br><span class="line">df = pd.DataFrame(d,index=[<span class="string">'x'</span>,<span class="string">'y'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>x</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>y</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">'staffSalary.xlsx'</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>姓名</th>
      <th>部门</th>
      <th>工号</th>
      <th>纳税人身份</th>
      <th>员工状态</th>
      <th>入职日期</th>
      <th>基本工资</th>
      <th>岗位工资</th>
      <th>合同类型改</th>
      <th>员工类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>张三</td>
      <td>销售部</td>
      <td>GH00030</td>
      <td>居民</td>
      <td>在职</td>
      <td>2019-01-03</td>
      <td>10035</td>
      <td>2000</td>
      <td>劳动合同</td>
      <td>全职</td>
    </tr>
    <tr>
      <th>1</th>
      <td>李四</td>
      <td>销售部</td>
      <td>GH00031</td>
      <td>居民</td>
      <td>在职</td>
      <td>2019-05-08</td>
      <td>10036</td>
      <td>2000</td>
      <td>劳动合同</td>
      <td>全职</td>
    </tr>
    <tr>
      <th>2</th>
      <td>王五</td>
      <td>销售部</td>
      <td>GH00032</td>
      <td>居民</td>
      <td>在职</td>
      <td>2019-01-01</td>
      <td>10000</td>
      <td>5000</td>
      <td>劳动合同</td>
      <td>全职</td>
    </tr>
    <tr>
      <th>3</th>
      <td>赵六</td>
      <td>销售部</td>
      <td>GH00033</td>
      <td>居民</td>
      <td>在职</td>
      <td>2019-01-01</td>
      <td>10000</td>
      <td>5000</td>
      <td>劳动合同</td>
      <td>全职</td>
    </tr>
  </tbody>
</table>
</div>


]]></content>
      <categories>
        <category>Phthon</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/2021/01/30/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数据类型和数据结构"><a href="#数据类型和数据结构" class="headerlink" title="数据类型和数据结构"></a>数据类型和数据结构</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><ol>
<li>整数 int 123</li>
<li>浮点数 float 1.234</li>
<li>字符串 str “Python”</li>
<li>布尔值 bool True False</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&quot;Phthon&quot;)</span><br><span class="line">&lt;class &#39;str&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(1.234)</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(True)</span><br><span class="line">&lt;class &#39;bool&#39;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>类型转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">123</span>)</span><br><span class="line"><span class="string">'123'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">123</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算薪资</span><br><span class="line"># 工作天数</span><br><span class="line">workday &#x3D; 21.75;</span><br><span class="line"># 日薪</span><br><span class="line">dailyPay &#x3D; 288;</span><br><span class="line"># 奖金</span><br><span class="line">bonus &#x3D; 566;</span><br><span class="line">total &#x3D; workday * dailyPay + bonus;</span><br><span class="line">print(total);</span><br></pre></td></tr></table></figure>

<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>序列有两个特性</p>
<ol>
<li>成员是有序的</li>
<li>可以通过下标访问一个或几个成员</li>
</ol>
<ul>
<li>字符串、列表、元组都属于序列</li>
</ul>
<ol>
<li>字符串 “春夏秋冬”</li>
<li>列表 [1,”春”,2,”秋”]</li>
<li>元组 (“春”,”夏”,”秋”,”冬”)  元组中存放不可变更的内容,没有增加删除等功能</li>
</ol>
<ul>
<li>序列基本操作</li>
</ul>
<ol>
<li>[not] in 成员关系</li>
<li><ul>
<li>连接 </li>
</ul>
</li>
<li><ul>
<li>重复</li>
</ul>
</li>
<li>: 切片 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据结构相关</span><br><span class="line"># 四季</span><br><span class="line">seasons &#x3D; [&quot;春&quot;, &quot;夏&quot;, &quot;秋&quot;, &quot;冬&quot;];</span><br><span class="line"></span><br><span class="line"># ---------------------切片操作</span><br><span class="line"># 第一季</span><br><span class="line">print(seasons[0])</span><br><span class="line"># 第一季和第三季</span><br><span class="line">print(seasons[0:2])</span><br><span class="line"># 倒数第一季</span><br><span class="line">print(seasons[-1])</span><br><span class="line"></span><br><span class="line"># ---------------------连接操作</span><br><span class="line">print(seasons + seasons)</span><br><span class="line">print(seasons + [1,2,3])</span><br><span class="line"></span><br><span class="line"># ---------------------重复操作</span><br><span class="line">print(seasons * 2)</span><br><span class="line"># ---------------------关系操作</span><br><span class="line">print(&quot;春&quot; in seasons)</span><br><span class="line">print(&quot;春&quot; not in seasons)</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">春</span><br><span class="line">[&#39;春&#39;, &#39;夏&#39;]</span><br><span class="line">冬</span><br><span class="line">[&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;, &#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;]</span><br><span class="line">[&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;, 1, 2, 3]</span><br><span class="line">[&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;, &#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;]</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>元组demo 计算某一天属于哪个季节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算某一天属于哪个季节</span><br><span class="line"></span><br><span class="line"># 计算某一天属于哪个季节</span><br><span class="line"></span><br><span class="line">seasons &#x3D; (&quot;春&quot;,&quot;夏&quot;,&quot;秋&quot;,&quot;冬&quot;)</span><br><span class="line"></span><br><span class="line"># 季节的第一天</span><br><span class="line">seasonsFirstDays &#x3D; ((1,1),(4,1),(7,1),(10,1))</span><br><span class="line"></span><br><span class="line">(month,day) &#x3D; (2,11)</span><br><span class="line">#(month,day) &#x3D; list(map(int,input(&quot;请输入月和日，用空格隔开&quot;).split()))</span><br><span class="line">print((month,day))</span><br><span class="line">filterSeasonFirstDay &#x3D; filter(lambda x : x &lt;&#x3D; (month,day),seasonsFirstDays)</span><br><span class="line">filterSeasonFirstDayLen  &#x3D; len(list(filterSeasonFirstDay))</span><br><span class="line">seasonIndex &#x3D; filterSeasonFirstDayLen % 4 -1</span><br><span class="line">print(seasonIndex)</span><br><span class="line">print(seasons[seasonIndex])</span><br><span class="line"></span><br><span class="line">[(1, 1)]</span><br><span class="line">-1</span><br><span class="line">冬</span><br></pre></td></tr></table></figure>

<p>列表demo </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列表的操作，区别于元组，列表可以添加和删除</span><br><span class="line"></span><br><span class="line">bonusItem &#x3D; [&quot;全勤奖&quot;,&quot;绩效奖&quot;]</span><br><span class="line"></span><br><span class="line">bonusItem.append(&quot;项目奖&quot;)</span><br><span class="line">print(bonusItem)</span><br><span class="line">bonusItem.remove(&quot;绩效奖&quot;)</span><br><span class="line">print(bonusItem)</span><br><span class="line"></span><br><span class="line">[&#39;全勤奖&#39;, &#39;绩效奖&#39;, &#39;项目奖&#39;]</span><br><span class="line">[&#39;全勤奖&#39;, &#39;项目奖&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="字典-key-value"><a href="#字典-key-value" class="headerlink" title="字典(key-value)"></a>字典(key-value)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;basesalary&quot;:&quot;4000&quot;,&quot;bonux&quot;:&quot;1888&quot;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 字典类型的使用</span><br><span class="line"></span><br><span class="line">dic1 &#x3D; &#123;&#125;</span><br><span class="line">print(type(dic1))</span><br><span class="line"></span><br><span class="line">dic2 &#x3D; &#123;&#39;basesalary&#39;:4000,&#39;bonus&#39;:1888&#125;</span><br><span class="line">dic2[&#39;postwage&#39;] &#x3D; 800</span><br><span class="line">print(dic2)</span><br><span class="line"></span><br><span class="line">&lt;class &#39;dict&#39;&gt;</span><br><span class="line">&#123;&#39;basesalary&#39;: 4000, &#39;bonus&#39;: 1888, &#39;postwage&#39;: 800&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算1到10所有偶数的平方</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for i in range(1,11):</span><br><span class="line">    if(i % 2 &#x3D;&#x3D; 0):</span><br><span class="line">        list1.append(i * i)</span><br><span class="line"></span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line"># 列表推导式语法</span><br><span class="line">list2 &#x3D; [i * i for i in range(1,11) if i % 2 &#x3D;&#x3D; 0]</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">upNumber &#x3D; (&quot;壹&quot;,&quot;贰&quot;,&quot;叁&quot;,&quot;肆&quot;,&quot;伍&quot;,&quot;陆&quot;,&quot;柒&quot;,&quot;捌&quot;,&quot;玖&quot;,&quot;拾&quot;)</span><br><span class="line">dic1 &#x3D; &#123;&#125;</span><br><span class="line">for i in upNumber:</span><br><span class="line">    dic1[i] &#x3D; 0;</span><br><span class="line">print(dic1)</span><br><span class="line"># 字典推导式语法</span><br><span class="line">dic2 &#x3D; &#123;i:0 for i in upNumber&#125;</span><br><span class="line">print(dic2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[4, 16, 36, 64, 100]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br><span class="line">&#123;&#39;壹&#39;: 0, &#39;贰&#39;: 0, &#39;叁&#39;: 0, &#39;肆&#39;: 0, &#39;伍&#39;: 0, &#39;陆&#39;: 0, &#39;柒&#39;: 0, &#39;捌&#39;: 0, &#39;玖&#39;: 0, &#39;拾&#39;: 0&#125;</span><br><span class="line">&#123;&#39;壹&#39;: 0, &#39;贰&#39;: 0, &#39;叁&#39;: 0, &#39;肆&#39;: 0, &#39;伍&#39;: 0, &#39;陆&#39;: 0, &#39;柒&#39;: 0, &#39;捌&#39;: 0, &#39;玖&#39;: 0, &#39;拾&#39;: 0&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 表达式:</span><br><span class="line">   代码块</span><br><span class="line">elif 表达式:</span><br><span class="line">   代码块</span><br><span class="line">else :</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 迭代变量 in 可迭代对象:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 表达式:</span><br><span class="line">      代码块</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upNumber &#x3D; (&quot;壹&quot;,&quot;贰&quot;,&quot;叁&quot;,&quot;肆&quot;,&quot;伍&quot;,&quot;陆&quot;,&quot;柒&quot;,&quot;捌&quot;,&quot;玖&quot;,&quot;拾&quot;)</span><br><span class="line">for num in range(10):</span><br><span class="line">    print(&quot;%s 的大写方式是:%s&quot; %(num,upNumber[(num - 1) % 10]))</span><br><span class="line"></span><br><span class="line">for idx in upNumber:</span><br><span class="line">    print(idx)</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文件操作</span><br><span class="line"></span><br><span class="line"># w是覆盖写入模式</span><br><span class="line">salaryfieldFile &#x3D; open(&#39;salaryfield.txt&#39;,&#39;w&#39;)</span><br><span class="line">salaryfieldFile.write(&quot;基本工资&quot;)</span><br><span class="line">salaryfieldFile.close()</span><br><span class="line"></span><br><span class="line">fieldRead &#x3D; open(&#39;salaryfield.txt&#39;)</span><br><span class="line">print(fieldRead.read())</span><br><span class="line">fieldRead.close()</span><br><span class="line"></span><br><span class="line"># 追加写入模式 a</span><br><span class="line"></span><br><span class="line">fieldAppend &#x3D; open(&#39;salaryfield.txt&#39;,&#39;a&#39;)</span><br><span class="line">fieldAppend.write(&#39;岗位工资&#39;)</span><br><span class="line">fieldAppend.close()</span><br></pre></td></tr></table></figure>

<p>指针操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文件指针操作</span><br><span class="line"></span><br><span class="line">file &#x3D; open(&quot;salaryfield.txt&quot;)</span><br><span class="line">print(&quot;当前文件指针位置%s：&quot;%file.tell())</span><br><span class="line">print(&quot;我们读取了一个字符：%s&quot;%file.read(1))</span><br><span class="line">print(&quot;当前文件指针位置%s：&quot;%file.tell())</span><br><span class="line">file.seek(0)</span><br><span class="line">print(&quot;进行指针移动操作&quot;)</span><br><span class="line">print(&quot;当前文件指针位置%s：&quot;%file.tell())</span><br><span class="line"># seek 函数第一个参数是偏移量，第二个参数是相对位置：0表示从文件开头 1表示从当前位置 2表示从文件结尾</span><br><span class="line">file.seek(5,0)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">当前文件指针位置0：</span><br><span class="line">我们读取了一个字符：基</span><br><span class="line">当前文件指针位置3：</span><br><span class="line">进行指针移动操作</span><br><span class="line">当前文件指针位置0：</span><br></pre></td></tr></table></figure>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常处理语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">  代码块</span><br><span class="line">except Exception[,reason]</span><br><span class="line">  异常处理</span><br><span class="line">final:</span><br><span class="line">  最终执行代码</span><br></pre></td></tr></table></figure>

<p>异常处理demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 异常处理</span><br><span class="line">try:</span><br><span class="line"> i &#x3D; j</span><br><span class="line">except NameError:</span><br><span class="line">    print(&#39;变量未定义异常&#39;)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line"> 1&#x2F;0</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&#39;除数不能为0&#39;)</span><br><span class="line"></span><br><span class="line"># 捕获多个异常</span><br><span class="line">try:</span><br><span class="line"> 1&#x2F;0</span><br><span class="line">except (NameError,ZeroDivisionError):</span><br><span class="line">    print(&#39;程序出现了异常&#39;)</span><br><span class="line"></span><br><span class="line"># 打印异常信息</span><br><span class="line">try:</span><br><span class="line"> 1&#x2F;0</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&#39;除数不能为0,%s&#39;%e)</span><br><span class="line"></span><br><span class="line"># 通用异常捕获</span><br><span class="line">try:</span><br><span class="line"> 1&#x2F;0</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&#39;程序异常,%s&#39;%e)</span><br><span class="line"></span><br><span class="line"># 自定义异常信息</span><br><span class="line">try:</span><br><span class="line"> raise NameError(&quot;这个一个自定义的异常信息&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&#39;程序异常,%s&#39;%e)</span><br><span class="line"></span><br><span class="line"># final执行操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">  file &#x3D; open(&quot;salaryfield.txt&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&#39;文件操作异常%s&#39;%e)</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line">    print(&quot;文件关闭&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def functionName(param1,param2,*other,**keywords):</span><br><span class="line">    代码</span><br><span class="line">    return 需要返回的内容</span><br><span class="line"></span><br><span class="line">参数分为3种</span><br><span class="line"></span><br><span class="line">param1,param2属属于必填的普通参数</span><br><span class="line">*other 是可变长参数，可以是0个或者一个</span><br><span class="line">**keywords 是关键字参数，可以通过调用的时候指定参数</span><br></pre></td></tr></table></figure>
<h2 id="函数变量作用域"><a href="#函数变量作用域" class="headerlink" title="函数变量作用域"></a>函数变量作用域</h2><p>默认函数内定义的变量，作用域只能在函数内</p>
<p>global关键字可以改变函数作用域为全局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 函数作用域</span><br><span class="line"></span><br><span class="line">var &#x3D; 123</span><br><span class="line">def func1():</span><br><span class="line">    var &#x3D; 456</span><br><span class="line">    print(var)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">print(var)</span><br><span class="line"></span><br><span class="line">global var2</span><br><span class="line">var2 &#x3D; 123</span><br><span class="line">def func2():</span><br><span class="line">    var2 &#x3D; 456</span><br><span class="line">    print(var2)</span><br><span class="line"></span><br><span class="line">func2()</span><br><span class="line">print(var2)</span><br><span class="line"></span><br><span class="line">var3 &#x3D; 123</span><br><span class="line">def func3():</span><br><span class="line">    global var3;</span><br><span class="line">    var3 &#x3D; 456</span><br><span class="line">    print(var3)</span><br><span class="line"></span><br><span class="line">func3()</span><br><span class="line">print(var3)</span><br><span class="line"></span><br><span class="line">456</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">456</span><br></pre></td></tr></table></figure>

<h2 id="函数迭代器和生成器"><a href="#函数迭代器和生成器" class="headerlink" title="函数迭代器和生成器"></a>函数迭代器和生成器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 生成器（通过yield实现迭代器功能）</span><br><span class="line">def floatRange(start,stop,step):</span><br><span class="line">    x &#x3D; start</span><br><span class="line">    while x &lt; stop:</span><br><span class="line">        yield x #迭代x</span><br><span class="line">        x +&#x3D; step</span><br><span class="line"></span><br><span class="line">for i in floatRange(10,20,0.5):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">10.5</span><br><span class="line">11.0</span><br><span class="line">11.5</span><br><span class="line">12.0</span><br><span class="line">12.5</span><br><span class="line">13.0</span><br><span class="line">13.5</span><br><span class="line">14.0</span><br><span class="line">14.5</span><br><span class="line">15.0</span><br><span class="line">15.5</span><br><span class="line">16.0</span><br><span class="line">16.5</span><br><span class="line">17.0</span><br><span class="line">17.5</span><br><span class="line">18.0</span><br><span class="line">18.5</span><br><span class="line">19.0</span><br><span class="line">19.5</span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lambda表达式</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def add(x,y):</span><br><span class="line">...     return x+y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; add(3,5)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; lambda x,y:x+y</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x7f0b8d3fcb00&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>filter、map、reduce、zip</p>
<p>help 函数名可以产看帮助文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filter函数 过滤</span><br><span class="line"></span><br><span class="line">&gt;&gt; list2 &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt; print(list(filter(lambda x:x&lt;4,list2)))</span><br><span class="line">[1, 2, 3]</span><br><span class="line"></span><br><span class="line"># map函数 对内容依次处理</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt; print(list(map(lambda x:x+1,a)))</span><br><span class="line">[2, 3, 4, 5, 6, 7, 8]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt; print(list(map(lambda x,y:x+y,a,b)))</span><br><span class="line">[2, 4, 6, 8, 10, 12, 14]</span><br><span class="line"></span><br><span class="line"># reduce函数 </span><br><span class="line">[2, 4, 6, 8, 10, 12, 14]</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x,y:x+y,[1,2,3],1)</span><br><span class="line">7</span><br><span class="line">等价于 ((1+1)+2)+3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># zip函数 常用于合并累加等</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; zip((1,2,3),(4,5,6))</span><br><span class="line">&lt;zip object at 0x7f0b8d3e3c30&gt;</span><br><span class="line">&gt;&gt;&gt; for i in zip((1,2,3),(4,5,6)):</span><br><span class="line">...    print(i)</span><br><span class="line">...</span><br><span class="line">(1, 4)</span><br><span class="line">(2, 5)</span><br><span class="line">(3, 6)</span><br><span class="line"></span><br><span class="line">#通过zip实现字段key-value对调</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dicta &#x3D; &#123;&quot;a&quot;:&quot;aa&quot;,&quot;b&quot;:&quot;bb&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; zip(dicta.values(),dicta.keys())</span><br><span class="line">&lt;zip object at 0x7f0b8d302780&gt;</span><br><span class="line">&gt;&gt;&gt; print(dict(zip(dicta.values(),dicta.keys())))</span><br><span class="line">&#123;&#39;aa&#39;: &#39;a&#39;, &#39;bb&#39;: &#39;b&#39;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>外部函数变量被内部函数引用，这种形式称之为闭包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 闭包</span><br><span class="line"></span><br><span class="line"># 计数器</span><br><span class="line">def counter(FIRST&#x3D;0):</span><br><span class="line">    cnt &#x3D; [FIRST]</span><br><span class="line">    def addOne():</span><br><span class="line">        cnt[0] +&#x3D; 1</span><br><span class="line">        return cnt[0]</span><br><span class="line">    return addOne</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 &#x3D; counter()</span><br><span class="line">num5 &#x3D; counter(5)</span><br><span class="line"></span><br><span class="line">print(num1())</span><br><span class="line">print(num1())</span><br><span class="line">print(num1())</span><br><span class="line">print(num5())</span><br><span class="line">print(num5())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器用来装饰函数，通过闭包实现。有点java aop的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 装饰器的使用</span><br><span class="line"></span><br><span class="line"># 通过闭包实现的装饰器</span><br><span class="line">def wash(func):</span><br><span class="line">    def wrapper(food):</span><br><span class="line">        print(&quot;吃饭前先洗手...&quot;)</span><br><span class="line">        print(&quot;函数调用名%s&quot;%func.__name__)</span><br><span class="line">        func(food)</span><br><span class="line">        print(&quot;吃完饭要漱口...&quot;)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def newWash(args):</span><br><span class="line">    def wash(func):</span><br><span class="line">        def wrapper(food):</span><br><span class="line">            print(&quot;%s前先洗手...&quot;%args)</span><br><span class="line">            func(food)</span><br><span class="line">            print(&quot;吃完%s要漱口...&quot;%args)</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line">    return wash;</span><br><span class="line"></span><br><span class="line">def eat():</span><br><span class="line">    print(&quot;开始吃饭&quot;)</span><br><span class="line"></span><br><span class="line"># 没使用装饰器前</span><br><span class="line">print(&quot;吃饭前先洗手...&quot;)</span><br><span class="line">eat()</span><br><span class="line">print(&quot;吃完饭要漱口...&quot;)</span><br><span class="line"></span><br><span class="line">@wash</span><br><span class="line">def eat2(food):</span><br><span class="line">    print(&quot;开始吃%s&quot;%food)</span><br><span class="line"></span><br><span class="line">eat2(&quot;面包&quot;)</span><br><span class="line"></span><br><span class="line">@newWash(&quot;早饭&quot;)</span><br><span class="line">def eat3(food):</span><br><span class="line">    print(&quot;开始吃%s&quot;%food)</span><br><span class="line"></span><br><span class="line">eat3(&quot;烤肉&quot;)</span><br><span class="line"></span><br><span class="line">吃饭前先洗手...</span><br><span class="line">开始吃饭</span><br><span class="line">吃完饭要漱口...</span><br><span class="line">吃饭前先洗手...</span><br><span class="line">开始吃面包</span><br><span class="line">吃完饭要漱口...</span><br><span class="line">早饭前先洗手...</span><br><span class="line">开始吃烤肉</span><br><span class="line">吃完早饭要漱口...</span><br></pre></td></tr></table></figure>

<h2 id="上下文管理器with"><a href="#上下文管理器with" class="headerlink" title="上下文管理器with"></a>上下文管理器with</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 上下文管理器 with</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    file &#x3D; open(&quot;salaryfield.txt&quot;)</span><br><span class="line">    for line in file.readlines():</span><br><span class="line">        print(line)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"># 可使用with代替上面的写法,不需要自己管理资源</span><br><span class="line"></span><br><span class="line">with open(&quot;salaryfield.txt&quot;) as file:</span><br><span class="line">        for line in file.readlines():</span><br></pre></td></tr></table></figure>

<h1 id="编码规范包"><a href="#编码规范包" class="headerlink" title="编码规范包"></a>编码规范包</h1><p>python提供了一个编码规范的工具包，可以自行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install autopep8</span><br></pre></td></tr></table></figure>
<p>安装完后可以配置pycharm添加到其扩展工具里，就可以在代码中右键使用了。配置方式这里就不写了。</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>class 关键字可以定义一个类,python中定义的类同样可以实现继承、封装、多态的特性</p>
<h2 id="类的使用示例"><a href="#类的使用示例" class="headerlink" title="类的使用示例"></a>类的使用示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 迭代类</span><br><span class="line"></span><br><span class="line">class ProjectIteration():  # 定义一个类</span><br><span class="line">    def __init__(self, name, code):</span><br><span class="line">        self.__name &#x3D; name  # 迭代名称 __开头表示私有属性，不可修改</span><br><span class="line">        self.code &#x3D; code  # 迭代编号</span><br><span class="line"></span><br><span class="line">    def printInfo(self):  # 定义一个方法</span><br><span class="line">        print(&#39;迭代名称：[%s] 迭代编号:[%s]&#39; % (self.__name, self.code))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bug():</span><br><span class="line">    &#39;定义bug类&#39;</span><br><span class="line">    pass  # pass 暂不实现</span><br><span class="line"></span><br><span class="line">currentPj &#x3D; ProjectIteration(&quot;智能薪酬&quot;, &quot;znxc001&quot;)  # 类的实例化</span><br><span class="line">currentPj.printInfo()</span><br><span class="line"></span><br><span class="line"># 类的继承</span><br><span class="line"># 父类</span><br><span class="line">class Animal():</span><br><span class="line">    def __init__(self,name,age&#x3D;0):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;跑了一段距离&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 继承父类</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        # self.name &#x3D; name</span><br><span class="line">        # self.age &#x3D; age</span><br><span class="line">        super().__init__(name,age)</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;小猫跑了一会&quot;) # 可以覆盖父类的方法</span><br><span class="line"></span><br><span class="line">tom &#x3D; Cat(&quot;tom&quot;,18)</span><br><span class="line">tom.run();</span><br><span class="line"></span><br><span class="line">print(&#39;tom 的类型是%s&#39;%type(tom))</span><br><span class="line">print(isinstance(tom,Animal))  # tom 是否是Animal的子类</span><br></pre></td></tr></table></figure>

<h2 id="自定义类支持with语法"><a href="#自定义类支持with语法" class="headerlink" title="自定义类支持with语法"></a>自定义类支持with语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TestWith():</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&#39;初始化...&#39;)</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        if exc_tb &#x3D;&#x3D; None:</span><br><span class="line">            print(&#39;没有异常&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;产生异常%s&#39; % exc_val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with TestWith():</span><br><span class="line">    print(&#39;Test is running&#39;)</span><br><span class="line">    raise NameError(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;home&#x2F;richey&#x2F;PycharmProjects&#x2F;pythonProject&#x2F;tutorial&#x2F;18TestWith.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    raise NameError(&quot;test&quot;)</span><br><span class="line">NameError: test</span><br><span class="line">初始化...</span><br><span class="line">Test is running</span><br><span class="line">产生异常test</span><br></pre></td></tr></table></figure>

<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>暂无</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>python的一大优势就是各种库特别丰富</p>
<p>python官方提供的库称之为标准库,官方网站：<a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">https://docs.python.org/3/library/index.html</a></p>
<p>python标准库提供类丰富的内容，比如基础的文本操作、日期处理、网络、开发工具和调试工具等等</p>
<h2 id="正则库re"><a href="#正则库re" class="headerlink" title="正则库re"></a>正则库re</h2><p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">https://docs.python.org/3/library/re.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  re</span><br></pre></td></tr></table></figure>

<h2 id="日期与时间函数"><a href="#日期与时间函数" class="headerlink" title="日期与时间函数"></a>日期与时间函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(time.time())</span><br><span class="line">print(time.localtime())</span><br><span class="line">print(time.strftime(&#39;%Y-%m-%d %H-%M-%S&#39;))</span><br><span class="line"></span><br><span class="line"># 1612010800.1010308</span><br><span class="line"># time.struct_time(tm_year&#x3D;2021, tm_mon&#x3D;1, tm_mday&#x3D;30, tm_hour&#x3D;20, tm_min&#x3D;46, tm_sec&#x3D;40, tm_wday&#x3D;5, tm_yday&#x3D;30, tm_isdst&#x3D;0)</span><br><span class="line"># 2021-01-30 20-46-40</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(datetime.datetime.now())</span><br><span class="line">newTime &#x3D; datetime.timedelta(minutes&#x3D;10) # 10分钟的偏移</span><br><span class="line">print(datetime.datetime.now() + newTime) # 10分钟后的时间</span><br><span class="line"></span><br><span class="line"># 2021-01-30 20:50:50.395245</span><br><span class="line"># 2021-01-30 21:00:50.395273</span><br><span class="line"></span><br><span class="line">newDay &#x3D; datetime.datetime(2021,1,30)</span><br><span class="line">print(newDay)</span><br><span class="line">datInterval &#x3D; datetime.timedelta(days&#x3D;10)</span><br><span class="line">print(newDay + datInterval)</span><br><span class="line"></span><br><span class="line"># 2021-01-30 00:00:00</span><br><span class="line"># 2021-02-09 00:00:00</span><br></pre></td></tr></table></figure>

<h2 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h2><h2 id="文本及目录操作"><a href="#文本及目录操作" class="headerlink" title="文本及目录操作"></a>文本及目录操作</h2><p><a href="https://docs.python.org/3/library/os.path.html" target="_blank" rel="noopener">https://docs.python.org/3/library/os.path.html</a></p>
<p><a href="https://docs.python.org/3/library/pathlib.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pathlib.html</a></p>
<p>几个简单的demo，详细操作查询文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(os.path.abspath(&quot;.&quot;)) # 根据当前路径获取绝对路径</span><br><span class="line">print(os.path.abspath(&quot;..&quot;))</span><br><span class="line">print(os.path.exists(&quot;&#x2F;home&quot;))</span><br><span class="line">print(os.path.isfile(&quot;&#x2F;home&quot;))</span><br><span class="line">os.path.join(&quot;&#x2F;home&#x2F;richey&#x2F;&quot;,&quot;&#x2F;Download&#x2F;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line"># &gt;&gt;&gt; p &#x3D; Path(&#39;.&#39;)</span><br><span class="line"># &gt;&gt;&gt; [x for x in p.iterdir() if x.is_dir()]</span><br><span class="line"># [PosixPath(&#39;.hg&#39;), PosixPath(&#39;docs&#39;), PosixPath(&#39;dist&#39;),</span><br><span class="line">#  PosixPath(&#39;__pycache__&#39;), PosixPath(&#39;build&#39;)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Phthon</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP原理</title>
    <url>/2021/01/01/CAP%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><p><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP定理</a></p>
<p><img src="http://assets.processon.com/chart_image/5c755040e4b0f9fba693aa8f.png" alt="cap定理"></p>
<p>分布式系统早已成为主流开发架构模式，当今中大型系统开发绕不开分布式.</p>
<p>相对于单点系统，分布式简单理解就是由多个节点一起组成的系统，由单点变成多点。节点之间的状态如何同步，成为了分布式系统首先要面对的问题，这也是分布式系统最大的难点。</p>
<p>CAP定理就是这方面的基本定理，自然而然的也是最基础最关键的理论。</p>
<blockquote>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。 ——百度百科</p>
</blockquote>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（要做到一致性，节点间的通讯必须是正常的,且在节点没有同步好数据之前，需要锁定写操作和读操作。但是这不符合可用性）</li>
<li>可用性（A）：每次请求都能获得一个(非错误)响应，但不保证返回的是最新写入的数据。</li>
<li>分区容忍性（P）：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。</li>
</ul>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。要注意的是，CAP里的一致性与数据库ACID中的一致性，是截然不同的。</p>
<ul>
<li>CA (consistency + availability)，这样的系统关注一致性和可用性，它需要非常严格的全体一致的协议，比如“两阶段提交”（2PC）。</li>
<li>CP (consistency + partition tolerance)，这样的系统关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法（Quorum 类的算法）。</li>
<li>AP (availability + partition tolerance)，这样的系统关心可用性和分区容忍性。</li>
</ul>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP 定理的含义</a></p>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka高可用配置</title>
    <url>/2020/12/13/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="producer端配置"><a href="#producer端配置" class="headerlink" title="producer端配置"></a>producer端配置</h1><h2 id="使用带有回调通知的-send-方法"><a href="#使用带有回调通知的-send-方法" class="headerlink" title="使用带有回调通知的 send 方法"></a>使用带有回调通知的 send 方法</h2><p>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</p>
<blockquote>
<p>设置 acks = all。设置成 all，表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。</p>
</blockquote>
<p> “所有副本”指的是ISR中的所有副本。ISR 中的副本都是与 Leader 同步的副本，相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的。ISR列表里跟Leader保持同步的那些Follower都要把消息同步过去，才能认为这条消息是写入成功了。Leader副本天然在ISR中。</p>
<p> Producer端认为消息已经成功提交的条件是：ISR中所有副本都已经保存了该消息，但producer并没有指定ISR中需要几个副本。这就是min.insync.replicas参数的作用。</p>
<p> 只有acks=-1(同all)时，min.insync.replicas参宿才有意义。</p>
<blockquote>
<p>设置 retries 为一个较大的值。</p>
</blockquote>
<p>对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p>
<h1 id="broker端参数"><a href="#broker端参数" class="headerlink" title="broker端参数"></a>broker端参数</h1><blockquote>
<p>设置 unclean.leader.election.enable = false。</p>
</blockquote>
<p>如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p>
<blockquote>
<p>设置 replication.factor &gt;= 3。</p>
</blockquote>
<p>最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</p>
<blockquote>
<p>设置 min.insync.replicas &gt; 1。</p>
</blockquote>
<p>控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中不要使用默认值 1。<br>只有当acks=all时该参数才有意义</p>
<p>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</p>
<h1 id="Cosumer端参数"><a href="#Cosumer端参数" class="headerlink" title="Cosumer端参数"></a>Cosumer端参数</h1><blockquote>
<p>enable.auto.commit，最好把它设置成 false</p>
</blockquote>
<p>采用手动提交位移的方式。这对于单 Consumer 多线程处理的场景而言是至关重要的。</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka常用校本</title>
    <url>/2020/11/17/Kafka%E5%B8%B8%E7%94%A8%E6%A0%A1%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="kafka-consumer-groups-sh"><a href="#kafka-consumer-groups-sh" class="headerlink" title="kafka-consumer-groups.sh"></a>kafka-consumer-groups.sh</h1><h2 id="查询kafka消息是否被消费"><a href="#查询kafka消息是否被消费" class="headerlink" title="查询kafka消息是否被消费"></a>查询kafka消息是否被消费</h2><p>要知道某条消息是否被消息,首先得知道是查被哪个消费组在消费; 比如 项目配置的kafka的group.id是 my-consumer-group ;<br>那么我们去看看 这个消费者组的消费情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092 --describe --group my-consumer-group</span><br></pre></td></tr></table></figure>

<p>这样查询出来的结果就是 staff-consumer-group消费组消费了哪些Topic; 如果想过滤某个TOPIC;可以加上|grep TOPIC名称 过滤一下；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092 --describe --group staff-consumer-group |grep TOPIC名称</span><br></pre></td></tr></table></figure>

<h2 id="–members-此选项提供使用者组中所有活动成员的列表"><a href="#–members-此选项提供使用者组中所有活动成员的列表" class="headerlink" title="–members   此选项提供使用者组中所有活动成员的列表"></a>–members   此选项提供使用者组中所有活动成员的列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092 --describe --group my-consumer-group  --members</span><br></pre></td></tr></table></figure>

<h2 id="–verbose-还展示分配给每个成员的分区"><a href="#–verbose-还展示分配给每个成员的分区" class="headerlink" title="–verbose  还展示分配给每个成员的分区"></a>–verbose  还展示分配给每个成员的分区</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092 --describe --group my-consumer-group  --members   --verbose</span><br></pre></td></tr></table></figure>

<h2 id="–state-提供有用的组级别信息"><a href="#–state-提供有用的组级别信息" class="headerlink" title="–state  提供有用的组级别信息"></a>–state  提供有用的组级别信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092 --describe --group my-consumer-group  --state</span><br></pre></td></tr></table></figure>

<h2 id="–delete-手动删除一个或多个消费者组"><a href="#–delete-手动删除一个或多个消费者组" class="headerlink" title="–delete   手动删除一个或多个消费者组"></a>–delete   手动删除一个或多个消费者组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --bootstrap-server xxx1:9092,xxx2:9092,xxx3:9092  --delete  --group my-consumer-group1  --group my-consumer-group2</span><br></pre></td></tr></table></figure>

<h2 id="–reset-offsets-重置消费者组的offset"><a href="#–reset-offsets-重置消费者组的offset" class="headerlink" title="–reset-offsets  重置消费者组的offset"></a>–reset-offsets  重置消费者组的offset</h2><blockquote>
<p>如果使用是老的高级消费者并在zookeeper存储消费者组的元数据（即。offsets.storage=zookeeper），则通过–zookeeper，而不是bootstrap-server</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-consumer-groups.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure>


<h1 id="kafka-topics-sh"><a href="#kafka-topics-sh" class="headerlink" title="kafka-topics.sh"></a>kafka-topics.sh</h1><p>使用kafka-topics.sh工具 可以执行主题的大部分操作（配置变更部份被移动至kafka-config.sh工具中）</p>
<h2 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h2><p>在集群中创建一个主题需要3个必填参数：主题名字、复制系数、分区数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --create --topic &lt;string&gt; --replication-factor &lt;integer&gt; --partitions &lt;integer&gt; --if-not-exists</span><br></pre></td></tr></table></figure>

<h2 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --alter --topic &lt;string&gt; --partitions &lt;integer&gt;</span><br></pre></td></tr></table></figure>
<h2 id="减少分区数量"><a href="#减少分区数量" class="headerlink" title="减少分区数量"></a>减少分区数量</h2><p>无法减少分区数量。因为如果删除了分区，分区里的数据也会一并被删除。也无法将这些分区的数据分配给其它分区。<br>如果一定要减少分区数量，就只能删除整个主题，然后重新创建。</p>
<h2 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h2><ul>
<li>broker的delete.topic.enable参数必须被设置成true,否则删除主题的请求会被忽略。</li>
<li>删除主题会丢失主题里的所有数据，这是一个不可逆的操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper  &lt;zookeeper connect&gt; --delete --topic &lt;string&gt;</span><br></pre></td></tr></table></figure>
<h2 id="列出集群里的所有主题"><a href="#列出集群里的所有主题" class="headerlink" title="列出集群里的所有主题"></a>列出集群里的所有主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper   &lt;zookeeper connect&gt; --list</span><br></pre></td></tr></table></figure>
<h2 id="列出主题的详细信息"><a href="#列出主题的详细信息" class="headerlink" title="列出主题的详细信息"></a>列出主题的详细信息</h2><p>薪资包含主题分区数量、主题的覆盖配置、以及每个分区的副本清单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper   &lt;zookeeper connect&gt; --describe </span><br><span class="line"># 加上--topic就可以列出指定主题的详细信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux expect spawn用法</title>
    <url>/2020/10/31/Linux%20expect%20spawn%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>通过脚本简化人机交互过程，比如登录远程服务器。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>使用expect + 其内部命令 spawn 可以实现类似的自动化需求。</p>
<ul>
<li>安装expect</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dnf install expect</span><br></pre></td></tr></table></figure>

<ul>
<li>案例1</li>
</ul>
<p>登录到远程服务器，并暂时获取root权限（sudo su）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;expect</span><br><span class="line">set timeout 30</span><br><span class="line">spawn ssh ubuntu@192.168.1.131</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect &quot;$*&quot;</span><br><span class="line">send &quot;sudo su\r&quot;</span><br><span class="line">expect &quot;*password*&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect &quot;*#&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s基本概念</title>
    <url>/2020/10/17/K8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><p><a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" target="_blank" rel="noopener">kubectl 是kubernetes命令行工具</a></p>
<p>如果我们打算在笔记本电脑（本地）上运行 Kubernetes 集群，则需要首先安装 minikube 等工具.</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/" target="_blank" rel="noopener">文档</a></p>
<h1 id="k8s-命令"><a href="#k8s-命令" class="headerlink" title="k8s 命令"></a>k8s 命令</h1><ul>
<li>获取运行的默认集群名称空间的所有Pod的列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ul>
<li>查看在pod内运行的容器的输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl logs [pod name]</span><br></pre></td></tr></table></figure>

<ul>
<li>查看服务详细信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe svc some-app</span><br></pre></td></tr></table></figure>

<ul>
<li>集群配置上下文</li>
</ul>
<blockquote>
<p>Kubernetes使用配置文件config来查找连接到集群所需的信息。该文件位于主机主文件夹的：~/.kube/config。上下文是该配置文件中的一个元素，它包含对集群，名称空间和用户的引用。如果要访问或运行单个群集，则配置文件中将只有一个上下文。我们可以定义多个指向不同集群的上下文。</p>
</blockquote>
<p>使用kubectl config命令可以查看这些上下文并在它们之间切换。</p>
<h1 id="k8s常用概念"><a href="#k8s常用概念" class="headerlink" title="k8s常用概念"></a>k8s常用概念</h1><ul>
<li>k8s集群</li>
</ul>
<p>K8S集群是运行容器化应用程序所需的一组物理或虚拟机以及其他基础结构资源。</p>
<ul>
<li>节点</li>
</ul>
<p>K8S集群中的每台机器都称为一个节点。每个K8S集群中有两种类型的节点：</p>
<p>主节点：承载Kubernetes控制平面并管理集群</p>
<p>工作节点：运行容器化应用程序</p>
<ul>
<li>Pods</li>
</ul>
<p>Pod是Kubernetes中最常见的资源之一。它们是一个或多个容器的集合。Pod中的容器共享网络和存储，同一Pod中的任何容器都可以通过localhost进行相互通信。</p>
<p>Pod创建后，会被分配一个唯一的IP地址。pod内的容器可以监听不同的端口。要访问容器，可以使用容器的IP地址。</p>
<p>但是，如果想在容器之间进行交互，可以使用localhost:port</p>
<p>如果Pod重启，就会分配另一个IP地址。因此，不能依赖于IP地址。通过IP直接与Pod进行通讯可能会有问题。</p>
<p>可以与Pod进行通信的抽象称为K8S服务。K8S服务为我们提供稳定的IP地址和DNS名称</p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开启ssh端口服务（22）</title>
    <url>/2020/08/31/Linux%E5%BC%80%E5%90%AFssh%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%EF%BC%8822%EF%BC%89/</url>
    <content><![CDATA[<h1 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h1><p>OpenSSH是SSH(Secure SHell)协议的免费开源实现。SSH协议族可以用来进行远程控制。</p>
<p>OpenSSH服务默认端口是22，默认配置路径是/etc/ssh/sshd_config</p>
<h1 id="安装OpenSSH"><a href="#安装OpenSSH" class="headerlink" title="安装OpenSSH"></a>安装OpenSSH</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dnf install ssh</span><br><span class="line">或</span><br><span class="line">apt-get install ssh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2020/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（14）-Mysql位（bit）数据类型</title>
    <url>/2020/06/07/Mysql%EF%BC%8814%EF%BC%89-Mysql%E4%BD%8D%EF%BC%88bit%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>最近在线上碰到了一个诡异的问题，线上有个业务模块突然查询不出数据。问题反馈的时候是上午，前一天晚上进行了上线操作，基本可以判断跟上线有关系。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>先看日志，没有任何报错，接口都能正常返回。并且此处没有降级机制，arthas跟踪到数据库查询确实没有返回。</p>
<p>拿到具体的生产查询sql，直接在生产数据库查询，没有结果。但是同样的sql放到beta可以查询出结果。</p>
<p>这里基本可以定位到是sql查询的问题了。</p>
<p>先分析了下sql，简单的单表查询，where里有四个查询条件，其中一个字段引起了注意，如下：</p>
<p>select * from table_staff where companyId = ‘demo-companyId’ and isDelete = ‘0’;</p>
<p>isDelte在业务中是一个boolean类型，对应数据库中用的是位数据类型：bit(1)，首先尝试将查询条件isDelete=’0’改为isDelete=0或者isDelete=false，<br>可以在生产数据库查出结果。</p>
<p>进一步比对生产和beta环境该表的DDL，发现isDelete字段的数据类型是一致的，但是生产比beta数据库多了一个索引 idx_companId_isDelete(companyId和isDelete的一个联合索引，而且不是唯一索引)，<br>基本确认索引问题导致。</p>
<p>此时运维确认这个索引是前天晚上上线，为了提高跑批效率手动在生产加上去的，删掉idx_companId_isDelete索引后问题解决。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>首先肯定是走了索引，导致数据查询不出来</p>
<p>数据库中isDelete数据类型是bit(1),查询该类型的知识点：</p>
<blockquote>
<p>MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。<br>MySQL把bit类型当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或者1值的字符串，而不是ASCII码的“0”或者“1”。<br>–《高性能MySQL》 P123 4.1.5-位数据类型</p>
</blockquote>
<p>MySQL把bit类型当作字符串类型，所以上例中当我们加了一个字符串索引，并且查询条件也使用的字符串查询时（isDelete=’0’），命中索引。而当我们把引号去掉或者使用false时（isDelete=0或isDelete=false）索引失效，进行了全表扫描。</p>
<p>问题在于，正常字符串索引即便是查询中使用了数字，也无非就是索引失效走全表扫描，不会查不出数据，这里明显是bit(1)数据类型的问题。</p>
<h1 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h1><p>在uat库加了跟生产同样的索引，还原了数据查询不出来的场景。</p>
<p>Explain 看了下命中索引是的执行计划，Extra中看到这样的描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible WHERE noticed after reading const tables</span><br></pre></td></tr></table></figure>

<p>走了常量表，查询mysql Manual，发现了对这段描述的解释：</p>
<p>![Mysql-extra-impossible](<a href="http://blog-pic-1254088127.picsh.myqcloud.com/mysql-impossible-const.png）" target="_blank" rel="noopener">http://blog-pic-1254088127.picsh.myqcloud.com/mysql-impossible-const.png）</a></p>
<p>但是，上例中的查询并不符合这段解释中的要求</p>
<p>![Mysql索引常量](<a href="http://blog-pic-1254088127.picsh.myqcloud.com/mysql-index-const.png）" target="_blank" rel="noopener">http://blog-pic-1254088127.picsh.myqcloud.com/mysql-index-const.png）</a></p>
<h1 id="实践和结论"><a href="#实践和结论" class="headerlink" title="实践和结论"></a>实践和结论</h1><p>MySQL官方文档及其它资料中找不到合理的解释，这里给个实践结论。</p>
<p>对bit类型的字段的查询：</p>
<ul>
<li>不使用索引<br>查询bit的参数值是无论是数值还是字符，mysql都会进行类型转化,将字符转换为数值，并比较数值对应的ascii码</li>
<li>使用索引<br>检索BIT(1)列的值, 索引存的结果是一个字符串且内容是二进制位0或1, 而不是ASCII值”0″或”1″. 这就导致了为什么我们使用ASCII值”0”没有查询出结果。</li>
</ul>
<p>简言之：bit类型索引里存的是二进制类型的值（位类型bit），我们查询参数给的是ASCII码值</p>
<p>结论：<br>1、定义为text和image和bit数据类型的列不应该增加索引<br>2、加完索引一定要explain看一下<br>3、使用unsigned tinyint代替bit(1) 来表示是否<br>   @Column(columnDefinition= “TINYINT”,length = 1)    暂未验证</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（15）-Mysql位（bit）数据类型实验</title>
    <url>/2020/06/07/Mysql%EF%BC%8815%EF%BC%89-Mysql%E4%BD%8D%EF%BC%88bit%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="bit类型字段的查询展示和计算"><a href="#bit类型字段的查询展示和计算" class="headerlink" title="bit类型字段的查询展示和计算"></a>bit类型字段的查询展示和计算</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE richey_test CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_general_ci;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use richey_test;</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE bittest(a bit(8));</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;00111001&#39;);</span><br><span class="line"></span><br><span class="line">mysql&gt; select a,a + 0 from bittest;</span><br><span class="line">+------+-------+</span><br><span class="line">| a    | a + 0 |</span><br><span class="line">+------+-------+</span><br><span class="line">| 9    |    57 |</span><br><span class="line">+------+-------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT a+b&#39;1&#39; from bittest;</span><br><span class="line">+--------+</span><br><span class="line">| a+b&#39;1&#39; |</span><br><span class="line">+--------+</span><br><span class="line">|     58 |</span><br><span class="line">+--------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a &#x3D; 9 from bittest;</span><br><span class="line">+------+</span><br><span class="line">| a &#x3D;9 |</span><br><span class="line">+------+</span><br><span class="line">|    0 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a&#x3D;&#39;9&#39; from bittest;</span><br><span class="line">+-------+</span><br><span class="line">| a&#x3D;&#39;9&#39; |</span><br><span class="line">+-------+</span><br><span class="line">|     0 |</span><br><span class="line">+-------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select a &#x3D;57 from bittest;</span><br><span class="line">+-------+</span><br><span class="line">| a &#x3D;57 |</span><br><span class="line">+-------+</span><br><span class="line">|     1 |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a&#x3D;&#39;57&#39; from bittest;</span><br><span class="line">+--------+</span><br><span class="line">| a&#x3D;&#39;57&#39; |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">+--------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT a&#x3D;b&#39;00111001&#39; from bittest;</span><br><span class="line">+---------------+</span><br><span class="line">| a&#x3D;b&#39;00111001&#39; |</span><br><span class="line">+---------------+</span><br><span class="line">|             1 |</span><br><span class="line">+---------------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select min(a) from bittest;</span><br><span class="line">+--------+</span><br><span class="line">| min(a) |</span><br><span class="line">+--------+</span><br><span class="line">| 57     |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>00111001 二进制值是57</p>
</blockquote>
<blockquote>
<p>ASCII码表中二进制00111001（转换成十进制为57）对应的字符是9</p>
</blockquote>
<blockquote>
<p>ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>当检索位类型的列时（例如BIT(8)），得到的结果是一个字符串，该字符串的值是数据库里存的二进制值对应的ASCII码字符（例：ASCII码00111001对应的字符是9）；</li>
<li>当BIT类型的值参与计算或比较时，使用的是二进制值对应的十进制数值进行计算或比较；</li>
</ul>
<blockquote>
<p>Comparison operations result in a value of 1 (TRUE), 0 (FALSE), or NULL. These operations work for both numbers and strings. Strings are automatically converted to numbers and numbers to strings as necessary.</p>
</blockquote>
<p>简言之，mysql中是将bit类型当字符串使用的，字符串参与计算或者比对的时候会先转换成数值，相应的bit类型参与计算或比较时会先转换成10进制的数值。</p>
<blockquote>
<p>InnoDB为每个bit列使用一个足够存储的最小整数类型来存放，所以并不能节省存储空间</p>
</blockquote>
<h1 id="根据bit类型字段查询（无索引）"><a href="#根据bit类型字段查询（无索引）" class="headerlink" title="根据bit类型字段查询（无索引）"></a>根据bit类型字段查询（无索引）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; 9;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; 57;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; &#39;9&#39;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; &#39;57&#39;;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a&#x3D;b&#39;00111001&#39;;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>结论：没有索引的情况下，bit类型参与比较时都是转换成二进制值对应的数值进行比较，而非二进制值对应的ASCII码所控制的字符串。</p>
<h1 id="根据bit类型字段查询（有索引）"><a href="#根据bit类型字段查询（有索引）" class="headerlink" title="根据bit类型字段查询（有索引）"></a>根据bit类型字段查询（有索引）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; alter table bittest add index idx_bit_a (a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;01111000&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;01111001&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;01111010&#39;);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;01111011&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO bittest VALUES(b&#39;01111100&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">| x    |</span><br><span class="line">| y    |</span><br><span class="line">| z    |</span><br><span class="line">| &#123;    |</span><br><span class="line">| |    |</span><br><span class="line">+------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from bittest where a &#x3D; 9;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_a     | idx_bit_a | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; 9;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from bittest where a &#x3D; &#39;9&#39;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_a     | idx_bit_a | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select * from bittest where a &#x3D; &#39;9&#39;;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select * from bittest where a &#x3D; &#39;57&#39;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain  select * from bittest where a &#x3D; &#39;57&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select * from bittest where a &#x3D; 57;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; explain  select * from bittest where a &#x3D; 57;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_a     | idx_bit_a | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from bittest where a &#x3D; b&#39;00111001&#39;;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| 9    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from bittest where a &#x3D; b&#39;00111001&#39;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_a     | idx_bit_a | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>结论：<br>走bit列索引的情况下，索引值使用ASCII码对应的字符串值，或ASCII码对应的十进制数值进行比对，（这与不走索引的规则是不同的）。</p>
<h1 id="使用bit-1-标识boolean类型"><a href="#使用bit-1-标识boolean类型" class="headerlink" title="使用bit(1)标识boolean类型"></a>使用bit(1)标识boolean类型</h1><h2 id="无索引的情况"><a href="#无索引的情况" class="headerlink" title="无索引的情况"></a>无索引的情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table bittest add column bit_boolean bit(1) ;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc bittest;</span><br><span class="line">+-------------+--------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type   | Null | Key | Default | Extra |</span><br><span class="line">+-------------+--------+------+-----+---------+-------+</span><br><span class="line">| a           | bit(8) | YES  | MUL | NULL    |       |</span><br><span class="line">| bit_boolean | bit(1) | YES  |     | NULL    |       |</span><br><span class="line">+-------------+--------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into bittest(bit_boolean) values(b&#39;1&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into bittest(bit_boolean) values(b&#39;0&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; &#39;1&#39;;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; 1;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; true;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; b&#39;1&#39;;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>没有索引的情况下使用1或者’1’或者true或者b’1’都可以检索出结果</p>
<h2 id="有索引的情况"><a href="#有索引的情况" class="headerlink" title="有索引的情况"></a>有索引的情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; alter table bittest add index idx_bit_bool (bit_boolean);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; 1;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select bin(bit_boolean) from bittest where bit_boolean &#x3D; 1;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_bool  | idx_bit_bool | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; &#39;1&#39;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select bin(bit_boolean) from bittest where bit_boolean &#x3D; &#39;1&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(bit_boolean) from bittest where bit_boolean &#x3D; true;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select bin(bit_boolean) from bittest where bit_boolean &#x3D; true;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_bool  | idx_bit_bool | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select bin(bit_boolean) from bittest where bit_boolean &#x3D; b&#39;1&#39;;</span><br><span class="line">+------------------+</span><br><span class="line">| bin(bit_boolean) |</span><br><span class="line">+------------------+</span><br><span class="line">| 1                |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; explain select bin(bit_boolean) from bittest where bit_boolean &#x3D; b&#39;1&#39;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | bittest | NULL       | ref  | idx_bit_bool  | idx_bit_bool | 2       | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>有索引的情况下，只能根据=1（二进制对应的十进制数值）或=true(实际也会转换成10进制1)进行索引。</p>
<h1 id="Mysql本身没有boolean类型"><a href="#Mysql本身没有boolean类型" class="headerlink" title="Mysql本身没有boolean类型"></a>Mysql本身没有boolean类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create table boolean_test</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;    id int primary key,</span><br><span class="line">    -&gt;    bl boolean</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc boolean_test;</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type       | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(11)    | NO   | PRI | NULL    |       |</span><br><span class="line">| bl    | tinyint(1) | YES  |     | NULL    |       |</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们创建一个boolean类型的列是可以成功的，但是实际上这列的数据格式是tinyint(1)</p>
<blockquote>
<p>MySQL BOOLEAN数据类型简介MySQL没有内置的布尔类型。 但是它使用TINYINT(1)。 为了更方便，MySQL提供BOOLEAN或BOOL作为TINYINT(1)的同义词</p>
</blockquote>
<blockquote>
<p>0被认为是false，非零值被认为是true。 要使用布尔文本，可以使用常量TRUE和FALSE来分别计算为1和0。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT true, false, TRUE, FALSE, True, False;</span><br><span class="line">+------+-------+------+-------+------+-------+</span><br><span class="line">| TRUE | FALSE | TRUE | FALSE | TRUE | FALSE |</span><br><span class="line">+------+-------+------+-------+------+-------+</span><br><span class="line">|    1 |     0 |    1 |     0 |    1 |     0 |</span><br><span class="line">+------+-------+------+-------+------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>使用 = true 或者 = false时，跟使用 = 1 或者 = 0是一样的</p>
<h2 id="true"><a href="#true" class="headerlink" title="= true"></a>= true</h2><p>true在mysql中就是1，= true同 = 1是一样的</p>
<h2 id="false"><a href="#false" class="headerlink" title="= false"></a>= false</h2><p>false 在mysql中就是0，=false同 =0是一样的</p>
<h2 id="is-false"><a href="#is-false" class="headerlink" title="is false"></a>is false</h2><p>检索出 0，等同于 = 0</p>
<h2 id="is-true"><a href="#is-true" class="headerlink" title="is true"></a>is true</h2><p>检索非0，等同于 != 0</p>
<p>注意字符串同数值比较时会转换成数值，转换有特殊规则，如‘’123abc’ 在等于号比较时转换成的数值为123</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select 0 is false, &#39;0&#39; is false ,&#39;123&#39; is false;</span><br><span class="line">+------------+--------------+----------------+</span><br><span class="line">| 0 is false | &#39;0&#39; is false | &#39;123&#39; is false |</span><br><span class="line">+------------+--------------+----------------+</span><br><span class="line">|          1 |            1 |              0 |</span><br><span class="line">+------------+--------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select 1 is true,2 is true ,&#39;1&#39; is true,&#39;123&#39; is true,-1 is true;</span><br><span class="line">+-----------+-----------+-------------+---------------+------------+</span><br><span class="line">| 1 is true | 2 is true | &#39;1&#39; is true | &#39;123&#39; is true | -1 is true |</span><br><span class="line">+-----------+-----------+-------------+---------------+------------+</span><br><span class="line">|         1 |         1 |           1 |             1 |          1 |</span><br><span class="line">+-----------+-----------+-------------+---------------+------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select 1 !&#x3D; 0,2 !&#x3D;0 ,&#39;1&#39; !&#x3D; 0,&#39;123&#39; !&#x3D; 0,-1 !&#x3D; 0;</span><br><span class="line">+--------+-------+----------+------------+---------+</span><br><span class="line">| 1 !&#x3D; 0 | 2 !&#x3D;0 | &#39;1&#39; !&#x3D; 0 | &#39;123&#39; !&#x3D; 0 | -1 !&#x3D; 0 |</span><br><span class="line">+--------+-------+----------+------------+---------+</span><br><span class="line">|      1 |     1 |        1 |          1 |       1 |</span><br><span class="line">+--------+-------+----------+------------+---------+</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，在mysql中不要使用bit(1)表示boolean类型，实际上不建议在任何场景使用bit类型的字段。查询会造成不必要的困扰和麻烦，令人难以理解。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-监控工具-innotop</title>
    <url>/2020/05/29/Mysql-%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-innotop/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>工具</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm工具-堆-jmap</title>
    <url>/2020/03/01/jvm%E5%B7%A5%E5%85%B7-%E5%A0%86-jmap/</url>
    <content><![CDATA[<h1 id="将-JAVA-HOME-bin添加到当前环境变量"><a href="#将-JAVA-HOME-bin添加到当前环境变量" class="headerlink" title="将$JAVA_HOME/bin添加到当前环境变量"></a>将$JAVA_HOME/bin添加到当前环境变量</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash">env  查看环境变量</span></span><br></pre></td></tr></table></figure>

<h1 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h1><p>当服务发生GC问题时，一般会使用jmap工具进行分析.</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>查看堆各个对象的数量、大小</li>
<li>dump堆里的对象信息,然后可以使用MAT等工具分析</li>
<li>查看堆的配置情况和GC算法</li>
<li>查看堆永久代信息</li>
</ul>
<h1 id="jmap命令"><a href="#jmap命令" class="headerlink" title="jmap命令"></a>jmap命令</h1><h2 id="jmap-histo-live-less"><a href="#jmap-histo-live-less" class="headerlink" title="jmap -histo[:live]  |less"></a>jmap -histo[:live] <pid> |less</h2><p>-histo：打印当前java堆中各个对象的数量、大小，添加了live，只会打印活跃的对象。</p>
<p>这个命令执行，JVM会先触发gc，然后再统计信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">查看对象数最多的对象，并按降序排序输出：</span><br><span class="line">jmap -histo &lt;pid&gt;|grep alibaba|sort -k <span class="number">2</span> -g -r|less</span><br><span class="line"></span><br><span class="line">查看占用内存最多的最象，并按降序排序输出：</span><br><span class="line">jmap -histo &lt;pid&gt;|grep alibaba|sort -k <span class="number">3</span> -g -r|less</span><br></pre></td></tr></table></figure>

<h2 id="jmap-dump-live-format-b-file"><a href="#jmap-dump-live-format-b-file" class="headerlink" title="jmap -dump:[live,]format=b,file= "></a>jmap -dump:[live,]format=b,file=<filename> <pid></h2><p>-dump：把java堆中的对象dump到本地文件，然后使用MAT进行分析。如果添加了live，只会dump活跃的对象。</p>
<p>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用hprof二进制形式,输出jvm的heap内容到文件</span><br><span class="line">[richey<span class="meta">@localhost</span> ~]$ jmap -dump:live,format=b,file=jmap.hprof <span class="number">6274</span></span><br><span class="line">Dumping heap to /home/richey/jmap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h2 id="让JVM在遇到OOM-OutOfMemoryError-时生成Dump文件"><a href="#让JVM在遇到OOM-OutOfMemoryError-时生成Dump文件" class="headerlink" title="让JVM在遇到OOM(OutOfMemoryError)时生成Dump文件"></a>让JVM在遇到OOM(OutOfMemoryError)时生成Dump文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/heap/dump</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can’t attach to the process<br>在ubuntu中第一次使用jmap会报错：Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can’t attach to the process，这是oracla文档中提到的一个bug:<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：" target="_blank" rel="noopener">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：</a></p>
</blockquote>
<blockquote>
<p>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 该方法在下次重启前有效。</p>
</blockquote>
<blockquote>
<p>永久有效方法 sudo vi /etc/sysctl.d/10-ptrace.conf 编辑下面这行: kernel.yama.ptrace_scope = 1 修改为: kernel.yama.ptrace_scope = 0 重启系统，使修改生效。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java4种引用类型</title>
    <url>/2020/02/01/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Java的“引用”决定了对象的存活.</p>
<p>JDK1.2之后，java提供了4中引用类型：</p>
<ul>
<li><p>强引用</p>
<p>创建对象时默认声明的就是强引用，只要强引用和还在，垃圾收集器不会回收掉被引用的对象。</p>
</li>
</ul>
<ul>
<li><p>软引用</p>
<p>用来描述一些有用，但非必须的对象。系统在内存溢出之前（内存不足的时候）会对软引用关联的对象进行回收。</p>
<p>主要应用于缓存实现，内存不足的时候释放缓存。</p>
</li>
</ul>
<ul>
<li><p>弱引用</p>
<p>被弱引用关联的对象只能存活到下一次GC之前。弱引用完全不会影响对象的生命周期。</p>
<p>索引想使用某些对象，又不想影响其本身的生命周期的时候可以使用。</p>
</li>
<li><p>虚引用（幽灵引用、幻影引用）</p>
<p>最弱的一种引用关系。无法通过虚引用来获取一个对象实例，没有单独使用的意义。</p>
<p>设置虚引用关联的唯一目的就是能在这个对象被GC会收到一个系统消息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot-validation统一异常处理</title>
    <url>/2020/01/01/springboot-validation%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常见问题总结</title>
    <url>/2019/12/01/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Mysql基本架构"><a href="#Mysql基本架构" class="headerlink" title="Mysql基本架构"></a>Mysql基本架构</h1><h1 id="Mysql中一条update语句是如何执行的"><a href="#Mysql中一条update语句是如何执行的" class="headerlink" title="Mysql中一条update语句是如何执行的"></a>Mysql中一条update语句是如何执行的</h1><h1 id="Mysql索引的实现方式，为什么这么实现"><a href="#Mysql索引的实现方式，为什么这么实现" class="headerlink" title="Mysql索引的实现方式，为什么这么实现"></a>Mysql索引的实现方式，为什么这么实现</h1><ul>
<li>Mysql索引是在存储引擎层实现的，InnoDB使用了B+树数据模型实现的索引，综合考虑了搜索效率和IO性能。</li>
<li>每个索引在InnoDB里对应一棵树</li>
</ul>
<h1 id="Mysql中有哪几种索引"><a href="#Mysql中有哪几种索引" class="headerlink" title="Mysql中有哪几种索引"></a>Mysql中有哪几种索引</h1><h1 id="什么时候使用联合索引？"><a href="#什么时候使用联合索引？" class="headerlink" title="什么时候使用联合索引？"></a>什么时候使用联合索引？</h1><h1 id="普通索引和唯一索引的区别"><a href="#普通索引和唯一索引的区别" class="headerlink" title="普通索引和唯一索引的区别"></a>普通索引和唯一索引的区别</h1><ul>
<li>查询</li>
<li>更新</li>
</ul>
<h1 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h1><h1 id="Mysql-有哪几种日志，分别有什么作用"><a href="#Mysql-有哪几种日志，分别有什么作用" class="headerlink" title="Mysql 有哪几种日志，分别有什么作用"></a>Mysql 有哪几种日志，分别有什么作用</h1><h1 id="每次更新数据都写磁盘的话，io成本会很高，mysql是如何解决的这个问题"><a href="#每次更新数据都写磁盘的话，io成本会很高，mysql是如何解决的这个问题" class="headerlink" title="每次更新数据都写磁盘的话，io成本会很高，mysql是如何解决的这个问题"></a>每次更新数据都写磁盘的话，io成本会很高，mysql是如何解决的这个问题</h1><p>WAL</p>
<h1 id="死锁产生的原因以及解决方式"><a href="#死锁产生的原因以及解决方式" class="headerlink" title="死锁产生的原因以及解决方式"></a>死锁产生的原因以及解决方式</h1>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置Kafka Broker</title>
    <url>/2019/07/07/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEKafka%20Broker/</url>
    <content><![CDATA[<h1 id="安装Kafka-Broker"><a href="#安装Kafka-Broker" class="headerlink" title="安装Kafka Broker"></a>安装Kafka Broker</h1><p>需要先安装号java和Zookeeper</p>
<p>从<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/</a>下载最新版本kafka，这里下载的是kafka_2.12-2.2.0.tgz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf kafka_2.12-2.2.0.tgz</span><br><span class="line">mv kafka_2.12-2.2.0 &#x2F;usr&#x2F;local&#x2F;kafka</span><br><span class="line">mkdir &#x2F;tmp&#x2F;kafka-logs</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-server-start.sh -daemon &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config&#x2F;server.properties</span><br></pre></td></tr></table></figure>

<p>验证是否启动成功，比如创建一个测试主题，发布一些消息，然后读取它们。</p>
<h2 id="0-90版本之后验证方式"><a href="#0-90版本之后验证方式" class="headerlink" title="0.90版本之后验证方式"></a>0.90版本之后验证方式</h2><p>创建测试主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test2-12</span><br></pre></td></tr></table></figure>

<p>查看主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class="line">test2-12</span><br></pre></td></tr></table></figure>

<p>发送消息到测试主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafconsole-producer.sh --broker-list  localhost:9092 --topic test2-12</span><br><span class="line">&gt;this is a message</span><br><span class="line">&gt;this is another message</span><br></pre></td></tr></table></figure>

<p>从测试主题读取消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test2-12 --from-beginning</span><br><span class="line">this is a message</span><br><span class="line">this is another message</span><br></pre></td></tr></table></figure>


<h2 id="0-90版本的验证方式"><a href="#0-90版本的验证方式" class="headerlink" title="0.90版本的验证方式"></a>0.90版本的验证方式</h2><p>创建并订阅主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line"># &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --describe --topic &quot;test&quot;</span><br><span class="line">Topic:test	PartitionCount:1	ReplicationFactor:1	Configs:</span><br><span class="line">	Topic: test	Partition: 0	Leader: 0	Replicas: 0	Isr: 0</span><br></pre></td></tr></table></figure>

<p>往测试主题上发布消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-console-producer.sh --broker-list  localhost:9092 --topic test</span><br><span class="line">&gt;Test Message 1</span><br><span class="line">&gt;Test Message 2</span><br><span class="line">ctrl + c</span><br></pre></td></tr></table></figure>

<p>从测试主题上读取消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;bin&#x2F;kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</span><br><span class="line">Test Message 1</span><br><span class="line">Test Message 2</span><br></pre></td></tr></table></figure>


<h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><h1 id="主题的默认配置"><a href="#主题的默认配置" class="headerlink" title="主题的默认配置"></a>主题的默认配置</h1>]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>安装zookeeper</title>
    <url>/2019/07/07/%E5%AE%89%E8%A3%85zookeeper/</url>
    <content><![CDATA[<h1 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h1><h2 id="单机服务"><a href="#单机服务" class="headerlink" title="单机服务"></a>单机服务</h2><p>从apache.org下载zookeeper,这里下载的是zookeeper-3.4.14.tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tar -zxf zookeeper-3.4.14.tar.gz</span><br><span class="line">#mv zookeeper-3.4.14 &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br><span class="line">#cat &gt; &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;conf&#x2F;zoo.cfg &lt;&lt; EOF</span><br><span class="line">&gt; tickTime&#x3D;2000</span><br><span class="line">&gt; dataDir&#x3D;&#x2F;var&#x2F;lib&#x2F;zookeeper</span><br><span class="line">&gt; clientPort&#x3D;2181</span><br><span class="line">&gt; EOF</span><br><span class="line">#&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>现在可以连接到zookeeper端口上，通过发送四字命令srvr来验证zookeeper是否安装正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#telnet localhost 2181</span><br><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line">srvr</span><br><span class="line">Zookeeper version: 3.4.14-4c25d480e66aadd371de8bd2fd8da255ac140bcf, built on 03&#x2F;06&#x2F;2019 16:18 GMT</span><br><span class="line">Latency min&#x2F;avg&#x2F;max: 0&#x2F;0&#x2F;0</span><br><span class="line">Received: 1</span><br><span class="line">Sent: 0</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x0</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 4</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>

<h2 id="Zookeeper群组"><a href="#Zookeeper群组" class="headerlink" title="Zookeeper群组"></a>Zookeeper群组</h2><p>Zookeeper集群被称为Zookeeper群组，Zookeeper使用的是一致性协议，所以每个群组里应该包含奇数个节点。因为只有群组里的大多数节点处于可用状态，zookeeper才能处理外部请求。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>使用多线程提高REST服务性能</title>
    <url>/2019/07/05/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%90%E9%AB%98REST%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="异步处理REST服务"><a href="#异步处理REST服务" class="headerlink" title="异步处理REST服务"></a>异步处理REST服务</h2><ul>
<li>使用Callable处理异步Rest服务</li>
<li>使用DefferredResult异步处理Rest服务</li>
<li>异步处理配置</li>
</ul>
<h3 id="使用Callable处理异步Rest服务"><a href="#使用Callable处理异步Rest服务" class="headerlink" title="使用Callable处理异步Rest服务"></a>使用Callable处理异步Rest服务</h3><p>副线程是由主线程调起的，即副线程的代码是写在主线程里面的。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86REST%E6%9C%8D%E5%8A%A1%20%28%E5%A4%9A%E5%BA%94%E7%94%A8%29.jpg" alt="image"></p>
<pre><code>@GetMapping(&quot;/order/async&quot;)
public Callable&lt;String&gt; ordeAsync() throws InterruptedException {
    logger.info(&quot;主线程开始&quot;);
    Callable&lt;String&gt; result =  () -&gt; {
        logger.info(&quot;副线程开始&quot;);
        Thread.sleep(2000);
        logger.info(&quot;副线程结束&quot;);
        return &quot;success&quot;;
    };
    logger.info(&quot;主线程结束&quot;);
    return result;
}</code></pre><p>对于调用方而言，该接口表现出来的还是一个同步的请求，即还是会过两秒多返回结果。这里异步的作用是提供服务方的吞吐能力。</p>
<h3 id="使用DefferredResult处理异步Rest服务"><a href="#使用DefferredResult处理异步Rest服务" class="headerlink" title="使用DefferredResult处理异步Rest服务"></a>使用DefferredResult处理异步Rest服务</h3><p>使用Callable处理Rest服务有一个限制，请求只能在一个服务中处理，即副线程必须由主线程调起。但有时候我们的业务比较复杂，比如收到请求后会先放到消息队列中，由其它服务来处理请求。这样请求的过程就不是在一个应用中处理的，这时我们需要用DefferredResult来处理异步Rest服务。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86REST%E6%9C%8D%E5%8A%A1%20.jpg" alt="多服务的异步处理"></p>
<pre><code>@GetMapping(&quot;/order/async/deferred&quot;)
public DeferredResult&lt;String&gt; ordeAsyncDeferred() throws InterruptedException {
    logger.info(&quot;主线程开始&quot;);
    String orderNumber = RandomStringUtils.randomNumeric(8);
    mockQueue.setPlaceOrder(orderNumber);

    DeferredResult&lt;String&gt; result = new DeferredResult&lt;&gt;();
    deferredResultHolder.getMap().put(orderNumber, result);
    logger.info(&quot;主线程结束&quot;);

    return result;
}</code></pre><p>模拟MQ服务：</p>
<pre><code>@Component
public class MockQueue {
    private Logger logger = LoggerFactory.getLogger(getClass());

    private String placeOrder;

    private String completeOrder;

    public String getPlaceOrder() {
        return placeOrder;
    }

    public void setPlaceOrder(String placeOrder)  {
        new Thread(()-&gt;{
            logger.info(&quot;接到下单请求：&quot; + placeOrder);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.completeOrder = placeOrder;
            logger.info(&quot;下单请求处理完毕:&quot; + placeOrder);
        }).start();


    }

    public String getCompleteOrder() {
        return completeOrder;
    }

    public void setCompleteOrder(String completeOrder) {
        this.completeOrder = completeOrder;
    }
}</code></pre><p>模拟应用２：</p>
<pre><code>@Component
public class QueueListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    private Logger logger = LoggerFactory.getLogger(getClass());


    @Autowired
    MockQueue mockQueue;

    @Autowired
    DeferredResultHolder deferredResultHolder;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        new Thread(() -&gt; {
            while (true) {
                if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())) {
                    String orderNumber = mockQueue.getCompleteOrder();
                    logger.info(&quot;返回订单处理结果：&quot; + orderNumber);
                    deferredResultHolder.getMap().get(orderNumber).setResult(&quot;place order success&quot;);
                    mockQueue.setCompleteOrder(null);
                } else {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();

    }
}</code></pre><p>DeferredResult上下文，持有DefferedResult</p>
<pre><code>@Component
public class QueueListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    private Logger logger = LoggerFactory.getLogger(getClass());


    @Autowired
    MockQueue mockQueue;

    @Autowired
    DeferredResultHolder deferredResultHolder;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        new Thread(() -&gt; {
            while (true) {
                if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())) {
                    String orderNumber = mockQueue.getCompleteOrder();
                    logger.info(&quot;返回订单处理结果：&quot; + orderNumber);
                    deferredResultHolder.getMap().get(orderNumber).setResult(&quot;place order success&quot;);
                    mockQueue.setCompleteOrder(null);
                } else {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();

    }
}</code></pre><h3 id="异步处理配置"><a href="#异步处理配置" class="headerlink" title="异步处理配置"></a>异步处理配置</h3><p>使用异步处理REST请求，默认拦截器是拦截不到异步请求的，需要配置拦截器，以及超时时间和线程可重用的线程池。</p>
<pre><code>@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {



    /**
     * 配置异步的支持
     * @param configurer
     */
    @Override
    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
        super.configureAsyncSupport(configurer);
        //注册异步的拦截器()
        configurer.registerCallableInterceptors();
        configurer.registerDeferredResultInterceptors();
        //默认超时时间
        configurer.setDefaultTimeout(30000);
        //设置可重用的线程池,默认会启用新的线程不会重用线程
//        configurer.setTaskExecutor()
    }

}</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>vim命令</title>
    <url>/2019/07/05/vim%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>vim本身提供了入门级教程，通过命令vimtutor就可以查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure>




<h1 id="命令和对象"><a href="#命令和对象" class="headerlink" title="命令和对象"></a>命令和对象</h1><p>许多文本命令都由一个操作符和一个命令组成，例如删除操作符d，配合动作命令w 组成dw，即删除当前位置至下一个单词起始位置.</p>
<p>简单的命令列表：</p>
<ul>
<li>w 当前位置至下一个单词的开始，不包含第一个字符</li>
<li>e 当前位置只单词末尾，包含最后一个字符</li>
<li>$ 当前位置至行末尾</li>
</ul>
<h1 id="在动作面前输入数字，可以使命令执行多次"><a href="#在动作面前输入数字，可以使命令执行多次" class="headerlink" title="在动作面前输入数字，可以使命令执行多次"></a>在动作面前输入数字，可以使命令执行多次</h1><ul>
<li>2w 移动两个单词，至第三个单词的开始处</li>
<li>3e 光标移动到第三个单词的末尾</li>
<li>0　光标移动到行首</li>
</ul>
<h1 id="删除类"><a href="#删除类" class="headerlink" title="删除类"></a>删除类</h1><ul>
<li><p>dw 删除光标至当前单词结尾</p>
</li>
<li><p>d$ 删除光标至当前行结尾</p>
</li>
</ul>
<h1 id="撤销类"><a href="#撤销类" class="headerlink" title="撤销类"></a>撤销类</h1><ul>
<li>u 撤销操作</li>
<li>U 撤销整行操作</li>
<li>Ctrl + R 撤销反向操作</li>
</ul>
<h1 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a>查看类</h1><ul>
<li>移动到当前行最后  shift+a</li>
</ul>
<ul>
<li><p>整页翻页 ctrl-f ctrl-b</p>
<p>  f就是forword b就是backward</p>
</li>
<li><p>翻半页 ctrl-d ctlr-u</p>
<p>  d=down u=up</p>
</li>
<li><p>滚一行 ctrl-e ctrl-y</p>
</li>
<li><p>zz 让光标所在的行居屏幕中央</p>
</li>
<li><p>zt 让光标所杂的行居屏幕最上一行 t=top</p>
</li>
<li><p>zb 让光标所杂的行居屏幕最下一行 b=bottom</p>
</li>
</ul>
<h1 id="置入类"><a href="#置入类" class="headerlink" title="置入类"></a>置入类</h1><ul>
<li>p 输入p将最后一次删除的内容置入光标之后</li>
</ul>
<h1 id="更改类"><a href="#更改类" class="headerlink" title="更改类"></a>更改类</h1><ul>
<li>c [number] motion 同删除命令一样的用法</li>
<li>ce 要改变文本直到一个单词的末尾，请输入 ce</li>
<li>cw 要改变文本直到下一个单词的开始，请输入cw </li>
<li>c$ 改变当前至行尾</li>
</ul>
<h1 id="定位及文件状态"><a href="#定位及文件状态" class="headerlink" title="定位及文件状态"></a>定位及文件状态</h1><ul>
<li>ctrl + g 显示当前编辑文件名，及当前光标位置</li>
<li>大写G跳到文件最后一行</li>
<li>gg跳到文件首行</li>
<li>行号 + 大写G 跳到指定行</li>
<li>显示行号 :set number</li>
<li>不显示行号 :set number</li>
</ul>
<h1 id="搜索类命令"><a href="#搜索类命令" class="headerlink" title="搜索类命令"></a>搜索类命令</h1><ul>
<li>输入 / 加上一个字符串可以用以在当前文件中查找该字符串</li>
<li>下一个n</li>
<li>上一个N</li>
<li>如果您想逆向查找字符串，请使用 ? 代替 / 进行</li>
</ul>
<h1 id="配对括号的查找"><a href="#配对括号的查找" class="headerlink" title="配对括号的查找"></a>配对括号的查找</h1><ul>
<li>输入 % 可以查找配对的括号 )、]、}</li>
</ul>
<h1 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h1><ul>
<li><p>r 输入r和一个字符替换光标所在位置的字符</p>
</li>
<li><p>R 输入R可连续替换多个字符</p>
</li>
<li><p>输入 :s/old/new/g 可以替换 old 为 new</p>
</li>
<li><p>输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配串</p>
</li>
<li><p>输入 :s/old/new/g 则是替换全行的匹配串，该行中所有的 “old” 都会被改变 </p>
</li>
<li><p>输入 :#,#s/old/new/g    #,# 代表的是替换操作的若干行中首尾两行的行号。</p>
</li>
<li><p>输入 :%s/old/new/g    替换整个文件中的每个匹配串。</p>
</li>
<li><p>输入 :%s/old/new/gc   找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换。</p>
</li>
</ul>
<h1 id="vim内执行外部命令"><a href="#vim内执行外部命令" class="headerlink" title="vim内执行外部命令"></a>vim内执行外部命令</h1><ul>
<li>:!+shell命令即可</li>
</ul>
<h1 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h1><ul>
<li>:w FILENAME 将文件以FILENAME为名称保存 </li>
<li>按v进行可视模式，移动光标选择要保存的内容，再按:w FILENAME 即可把选择的内容保存到名称为FILENAME的文件中</li>
</ul>
<h1 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h1><ul>
<li>按v键，进入字符可视模式，移动光标可进行选择</li>
<li>按V键，进入行可视模式,移动光标可进行选择</li>
<li>按Ctrl+v键，进入行可视模式,移动光标可进行选择<br>SHIFT+i(I) 输入要插入的内容<br>ESC 按两次，会在每行的选定的区域出现插入的内容</li>
<li>选择后，可以输入一个操作符对选中的文本进行操作，比如d 删除</li>
<li>u或U，字母大小写切换</li>
<li>d删除选中字符，D删除整行</li>
<li>y复制文本，p粘贴文本</li>
<li>还可以把 y 当作操作符来使用；例如 yw 可以用来复制一个单词</li>
</ul>
<h1 id="提取和合并文件"><a href="#提取和合并文件" class="headerlink" title="提取和合并文件"></a>提取和合并文件</h1><ul>
<li>:r FILENAME 要向当前文件中插入另外的文件的内容</li>
</ul>
<h1 id="打开类命令"><a href="#打开类命令" class="headerlink" title="打开类命令"></a>打开类命令</h1><ul>
<li>输入 o 将在光标的下方打开新的一行并进入插入模式</li>
<li>输入 O 将在光标的上方打开新的一行并进入插入模式</li>
</ul>
<h1 id="设置类命令的选项"><a href="#设置类命令的选项" class="headerlink" title="设置类命令的选项"></a>设置类命令的选项</h1><ul>
<li>要查找单词 ignore 可在正常模式下输入 /ignore &lt;回车&gt;, 要重复查找该词，可以重复按 n 键</li>
<li>然后设置 ic 选项(Ignore Case，忽略大小写)，请输入： :set ic</li>
<li>要禁用忽略大小写，请输入： :set noic</li>
<li>设置 hlsearch 和 incsearch 这两个选项，请输入： :set hls is</li>
<li>要移除匹配项的高亮显示，请输入：  :nohlsearch<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;ic&#39; &#39;ignorecase&#39;       查找时忽略字母大小写</span><br><span class="line">&#39;is&#39; &#39;incsearch&#39;        查找短语时显示部分匹配</span><br><span class="line">&#39;hls&#39; &#39;hlsearch&#39;        高亮显示所有的匹配短语</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（13）-Mysql索引总结</title>
    <url>/2019/06/24/Mysql%EF%BC%8813%EF%BC%89-Mysql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>写了几篇关于Mysql索引的文章了：</p>
<p>1.Mysql数据库索引——数据结构</p>
<p>2.Mysql数据库索引——必知必会</p>
<p>3.Mysql数据库索引——给字符串加索引</p>
<p>这里做一个总结，旨在对Mysql索引有一个整体的认识。</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/Mysql%E7%B4%A2%E5%BC%95.png" alt="Mysql索引知识体系图"></p>
<h1 id="Mysql索引总结"><a href="#Mysql索引总结" class="headerlink" title="Mysql索引总结"></a>Mysql索引总结</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>类似于目录，是用来提高查询效率的一种数据组织形式，Mysql中用索引组织数据。</p>
<h2 id="Mysql索引的实现方式"><a href="#Mysql索引的实现方式" class="headerlink" title="Mysql索引的实现方式"></a>Mysql索引的实现方式</h2><p>Mysql索引是在存储引擎层实现的，InnoDB使用了B+树数据模型实现的索引，综合考虑了搜索效率和IO性能。</p>
<p>每个索引在InnoDB里对应一棵树</p>
<p>这里引入了提高读写效率的几种数据结构：哈希表、有序数组、搜索树。</p>
<h2 id="Mysql中有哪几种索引"><a href="#Mysql中有哪几种索引" class="headerlink" title="Mysql中有哪几种索引"></a>Mysql中有哪几种索引</h2><p>主键索引（聚簇索引）：主键索引的叶子节点存的是整行的数据；</p>
<p>二级索引：二级索引的叶子节点存的是主键的值；</p>
<p>二级索引可能会产生回表操作</p>
<h2 id="索引维护成本"><a href="#索引维护成本" class="headerlink" title="索引维护成本"></a>索引维护成本</h2><h2 id="索引技巧"><a href="#索引技巧" class="headerlink" title="索引技巧"></a>索引技巧</h2><ul>
<li>索引覆盖</li>
<li>最左添缀</li>
<li>联合索引</li>
</ul>
<h2 id="什么时候使用联合索引？"><a href="#什么时候使用联合索引？" class="headerlink" title="什么时候使用联合索引？"></a>什么时候使用联合索引？</h2><h2 id="索引下推是什么？"><a href="#索引下推是什么？" class="headerlink" title="索引下推是什么？"></a>索引下推是什么？</h2><h2 id="普通索引和唯一所以的区别"><a href="#普通索引和唯一所以的区别" class="headerlink" title="普通索引和唯一所以的区别"></a>普通索引和唯一所以的区别</h2><ul>
<li>查询</li>
<li>更新</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSocial(2)-绑定和解绑处理</title>
    <url>/2019/06/20/SpringSocial(2)-%E7%BB%91%E5%AE%9A%E5%92%8C%E8%A7%A3%E7%BB%91%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="概要说明"><a href="#概要说明" class="headerlink" title="概要说明"></a>概要说明</h2><p>绑定</p>
<ul>
<li>类似于第三方登录,需要走一个授权流程</li>
<li>登录时的授流程,是没有当前的登录信息的,本身就是去哪社交帐号的信息去做登录,而绑定的授权看流程,是已经知道了当前用户是谁再去走授权流程</li>
</ul>
<p>解除绑定</p>
<ul>
<li>非常简单,就是删除一条绑定的记录</li>
</ul>
<h2 id="获取绑定信息"><a href="#获取绑定信息" class="headerlink" title="获取绑定信息"></a>获取绑定信息</h2><p>SpringSocial默认提供了查询绑定信息接口,地址为/connect,但是没有提供相关视图,所以当我们访问绑定接口的时候会报一个405的”Whitelabel Error Page”</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/SpringSecuriity-WEP.png" alt="image"><br>/connect接口在org.springframework.social.connect.web.ConnectController中提供</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(method&#x3D;RequestMethod.GET)</span><br><span class="line">public String connectionStatus(NativeWebRequest request, Model model) &#123;</span><br><span class="line">	setNoCache(request);</span><br><span class="line">	processFlash(request, model);</span><br><span class="line">	Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt; connections &#x3D; connectionRepository.findAllConnections();</span><br><span class="line">	model.addAttribute(&quot;providerIds&quot;, connectionFactoryLocator.registeredProviderIds());		</span><br><span class="line">	model.addAttribute(&quot;connectionMap&quot;, connections);</span><br><span class="line">	return connectView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到这里会拿到所有的providerIds(这里是我们系统提供的第三方应用的id,例如QQ//WeChat等),以及当前用户所有connection信息,这里包含了绑定信息.</p>
</li>
<li><p>这里通过connectView()防范返回了一个String:”connect/status”,所以Spring会去寻找名字是connect/status的视图.默认我们没有提供该视图,所以最终会抛出PageNotFound异常.</p>
</li>
<li><p>所以我们要提供一个名为”connectt/status”的视图,这个视图我们只返回第三方应用是否绑定的一个信息就可以了.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author richey</span><br><span class="line"> * SpringSocial提供了&#x2F;connect接口获取绑定第三方用户的信息,默认返回该视图</span><br><span class="line"> * @see org.springframework.social.connect.web.ConnectController#connectionStatus(NativeWebRequest, Model)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component(&quot;connect&#x2F;status&quot;)</span><br><span class="line">public class EvolutionaryConnectionStatusView extends AbstractView &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 渲染视图,这里我们只返回第三方应用及其是否绑定的信息就可以了</span><br><span class="line">     *</span><br><span class="line">     * @param map</span><br><span class="line">     * @param httpServletRequest</span><br><span class="line">     * @param httpServletResponse</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected void renderMergedOutputModel(Map&lt;String, Object&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt; connectionsMap &#x3D; (Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt;) map.get(&quot;connectionMap&quot;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Boolean&gt; result &#x3D; Maps.newHashMap();</span><br><span class="line">        connectionsMap.forEach((key, connections) -&gt;</span><br><span class="line">                result.put(key, CollectionUtils.isNotEmpty(connections))</span><br><span class="line">        );</span><br><span class="line">        httpServletResponse.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>现在登录后访问”/connect”接口就会返回我们自定义的渲染信息:</p>
<pre><code>{&quot;qq&quot;:true,&quot;weixin&quot;:false}</code></pre></li>
</ul>
<h2 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h2><p>有了绑定信息{“qq”:true,”weixin”:false},我们就可以在前台展示哪些服务已经绑定,哪些服务可以绑定,下面我们来看一下如何进行绑定操作.</p>
<ul>
<li>SpringSocial同样提供了绑定的接口/connect/{providerId},我们调用该接口即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--connect 是SpringSocial在ConnectController中提供的默认接口,qq是providerId,是QQProperties中可配置的--&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&#x2F;connect&#x2F;qq&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;submit&quot;&gt;QQ绑定&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样绑定成功后会返回一个视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   protected String connectView(String providerId) &#123;</span><br><span class="line">	return getViewPath() + providerId + &quot;Connect&quot;;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   protected String connectedView(String providerId) &#123;</span><br><span class="line">	return getViewPath() + providerId + &quot;Connected&quot;;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们提供一下该视图(connect/qqConnect):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author richey</span><br><span class="line"> * SpringSocial绑定后跳转的视图</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EvolutionaryConnectView extends AbstractView &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void renderMergedOutputModel(Map&lt;String, Object&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        httpServletResponse.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">        if (map.get(&quot;connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(&quot;&lt;h3&gt;解绑成功&lt;&#x2F;h3&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            httpServletResponse.getWriter().write(&quot;&lt;h3&gt;绑定成功&lt;&#x2F;h3&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:这里我们并没有用@Component注解直接标注,因为我们希望这是一个通用的视图,不管是qq/weixin还是其它的第三方应用都可以使用,所以,我们在相关服务的配置文件中各自配置该视图Bean,同时采用了@ConditionalOnMissingBean注解,方便用户自行提供定制化视图:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * @author richey</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnProperty(prefix &#x3D; &quot;evolutionary.security.social.qq&quot;, name &#x3D; &quot;app-id&quot;)</span><br><span class="line">public class QQAutoConfig extends SocialAutoConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean(&#123;&quot;connect&#x2F;qqConnect&quot;, &quot;connect&#x2F;qqConnected&quot;&#125;)</span><br><span class="line">    @ConditionalOnMissingBean(name &#x3D; &quot;qqConnectedView&quot;)</span><br><span class="line">    public View weixinConnectedView() &#123;</span><br><span class="line">        return new EvolutionaryConnectView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="解绑"><a href="#解绑" class="headerlink" title="解绑"></a>解绑</h2><ul>
<li>解绑是绑定的逆操作,SpringSocial为解绑提供的接口地址同绑定是相同的,不同的是绑定的请求方式是POST,解绑是DELETE</li>
<li>解绑成功同样会返回一个视图,需要我们自己提供.</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Social</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSocial(2)-第三方登录原理</title>
    <url>/2019/06/19/SpringSocial(2)-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="http://on-img.com/chart_image/5b9ccb5de4b0bd4db93d9616.png" alt="image"></p>
<p>对照上面的流程我们来分析一下SpringSocial实现第三方登录的原理:</p>
<ul>
<li>登录的实现还是用的SpringSecurity,SpringSocial只不过是将第三方登录的过程对接到了SpringSecurity</li>
<li>既然是SpringSecurity,拿核心依然是过滤器链,SpringSocial提供了SocialAuthenticationFilter.</li>
<li>SpringSocial将OAuth2认证流程封装,最终产出的结果就是标准的Connection,Connection里面包含了用户的信息</li>
<li>SocialAuthenticationService封装了取Connection的过程</li>
<li>拿到Connection相当于拿到了用户登录的Authentication,但此时的Authentication是未认证通过的,到这里相当于只是拿到了用于用于登录的数据</li>
<li>处理用户登录,当然还是要回到SpringSecurity的授权流程,通过AuthenticationManager,找到对应的AthenticationProvider,这里是SpringSocial提供了SocialAuthenticationProvider处理登录信息.</li>
<li>Connection信息维护了一个第三方用户和当前服务业务用户的一个映射关系,拿到connection,我们就可以拿到用户在当前服务的userId</li>
<li>有了userId,我们就可以通过SocialUserDetailService来得到SocialUserDeail,到这里相当于拿到了用户的信息</li>
<li>将用户信息维护进Connection再继续走授权流程,处理session等,整个第三方登录过程大致就是这样.</li>
</ul>
<p>总结:整个过程其实就是整合了SpringSecurity认证流程以及SpringSocial实现OAuth2的流程,之后前的文章我们已经分别分析了SpringSecurity及SpringSocial,流程万变不离其宗,流程和原理知道了,如果实际的开发过程中遇到问题,看一下源码也是非常便捷的.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Social</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSocial(1)-开发QQ登录</title>
    <url>/2019/06/17/SpringSocial(1)-%E5%BC%80%E5%8F%91QQ%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>在用SpringSocial开发QQ第三方登录之前，我们先来回顾下SpringSocial实现OAuth第三方登录的流程：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/SpringSocial%E5%AE%9E%E7%8E%B0OAuah%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.png" alt="image"></p>
<p>SpringSocial是同各种第三方服务进行对接最终得到的是标准的Connectionn，并最终保存到db中。</p>
<p>我们要做的就是提供生成Connection所需要的各种接口的实现类，这些接口的作用上一篇已经说了，其中SpringSocial为一些接口已经提供了抽象实现，我们继承就可以了。</p>
<p>代码细节就不说了，<a href="https://github.com/liubaolin/evolutionary/tree/master/evolutionary-security" target="_blank" rel="noopener">具体可以去github看</a>，这里分析下这个流程中几个重要的地方：</p>
<ul>
<li>在实现号所有接口后，提供具体配置</li>
</ul>
<pre><code>@Configuration
@ConditionalOnProperty(prefix = &quot;evolutionary.security.social.qq&quot;, name = &quot;app-id&quot;)
public class QQAutoConfig extends SocialAutoConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    protected ConnectionFactory&lt;?&gt; createConnectionFactory() {
        QQProperties qqConfig = securityProperties.getSocial().getQq();
        return new QQConnectionFactory(qqConfig.getProviderId(), qqConfig.getAppId(), qqConfig.getAppSecret());
    }
}</code></pre><ul>
<li><p>数据库表</p>
<p>  我们在JdbcUsersConnectionRepository相同的包路径下可以看到JdbcUsersConnectionRepository.sql，没错，考出来执行一下就可以了。</p>
</li>
<li><p>SocialCoinfig</p>
</li>
</ul>
<pre><code>@Configuration
@EnableSocial
public class SocialConfig extends SocialConfigurerAdapter {

    @Autowired
    private DataSource dataSource;

    @Override
    public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {
        JdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText());
//        repository.setTablePrefix(&quot;evolutionary_&quot;);
        return repository;
    }

    @Bean
    public SpringSocialConfigurer evolutionarySocialSecurityConfig() {
        return new SpringSocialConfigurer();
    }

}</code></pre><ul>
<li>将SpringSocial的配置配到SpringSecurity中</li>
</ul>
<pre><code>protected void configure(HttpSecurity http) throws Exception {

    http.apply(evolutionarySocialConfigurer)；

}</code></pre><ul>
<li><p>前端页面</p>
<pre><code>&lt;h3&gt;社交登录&lt;/h3&gt;
&lt;a href=&quot;/auth/qq&quot;&gt;QQ登录&lt;/a&gt;</code></pre></li>
</ul>
<pre><code>注意我们页面写的这个QQ登录的地址“/auth/qq&quot;,前面的”/auth/“是SpringSocial的默认请求处理地址前缀，是在SpringSocialAuthenticationFilter中提供的默认路径。 后面的qq是我们自己提供的，在构建ConnectionFactory时，传入了，实际上该参数就是我们封装的服务提供商Provider的标识。


public class QQProperties extends SocialProperties {

    /**
     * 用于区分不同的provider的
     */
    private String providerId = &quot;qq&quot;;

    public String getProviderId() {
        return providerId;
    }

    public void setProviderId(String providerId) {
        this.providerId = providerId;
    }
}

ConnectionFactory需要传入qqConfig.getProviderId()

@Configuration
@ConditionalOnProperty(prefix = &quot;evolutionary.security.social.qq&quot;, name = &quot;app-id&quot;)
public class QQAutoConfig extends SocialAutoConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    protected ConnectionFactory&lt;?&gt; createConnectionFactory() {
        QQProperties qqConfig = securityProperties.getSocial().getQq();
        return new QQConnectionFactory(qqConfig.getProviderId(), qqConfig.getAppId(), qqConfig.getAppSecret());
    }
}</code></pre><p><img src="http://ogiythg18.bkt.clouddn.com/OAuth%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95.png" alt="image"></p>
<p><strong>注意：</strong></p>
<p>”/auth/qq“这个地址就是上图中触发第一步：将用户导向认证服务器的地址，同时也是第三步：用户同意授权后跳转回来的地址。</p>
<h3 id="修改SpringSocial默认请求拦截路径-auth"><a href="#修改SpringSocial默认请求拦截路径-auth" class="headerlink" title="修改SpringSocial默认请求拦截路径/auth"></a>修改SpringSocial默认请求拦截路径/auth</h3><pre><code>@Configuration
@EnableSocial
public class SocialConfig extends SocialConfigurerAdapter {

    @Autowired
    private DataSource dataSource;

    @Override
    public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {
        JdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText());
//        repository.setTablePrefix(&quot;evolutionary_&quot;);
        return repository;
    }

    @Bean
    public SpringSocialConfigurer evolutionarySocialSecurityConfig() {
        return new SpringSocialConfigurer();
    }


}</code></pre><p>在SpringSocialConfigurer中将SpringsocialAuthenticationFilter放到了SpringSecurity的过滤器链上，并做了一些处理，源码如下：</p>
<pre><code>http.authenticationProvider(new SocialAuthenticationProvider(usersConnectionRepository, socialUsersDetailsService)).
addFilterBefore((Filter)this.postProcess(filter), AbstractPreAuthenticatedProcessingFilter.class);</code></pre><p>我们可以看到在加到过滤器链之前做了一个后处理操作this.postProcess(filter)，我们可以在重写这个方法，对SpringsocialAuthenticationFilter做一些定制化的操作。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Social</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSocial(0)-SpringSocial简介</title>
    <url>/2019/06/16/SpringSocial(0)-SpringSocial%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>之前我们介绍了OAuth协议，知道了OAuth协议中的各种角色及认证流程，着重说明了授权码模式的认证。这里我们以授权码默认认证为基础说一下第三方登录的流程：</p>
<p>在拿到令牌后，第三方应用就可以从服务提供商这里获取用户基本信息了，拿到用户基本信息后，我们构建Authentication并放到SecurityContext中，这样就完成了登录。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/OAuth%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95.png" alt="image"></p>
<p>这就是OAuth和Spring Security配合完成第三方登录的流程。SpringSocial将这个流程封装到了SocialAuthenticationFilter中，并放到了Spring Security的过滤器链中：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/SocialAuthenticationFilter.png" alt="image"></p>
<h2 id="SpringSocial开发第三方登录"><a href="#SpringSocial开发第三方登录" class="headerlink" title="SpringSocial开发第三方登录"></a>SpringSocial开发第三方登录</h2><p>在上面的OAuth第三方登录流程中，我们可以看出1-6步都需要同服务提供商交互，并并且对于不同的登录1-5步都是一样的，第6步不同的服务提供商提供的用户信息的数据结构不尽相同。</p>
<p>我们对照图片看一下Spring Social对上面的流程做了怎样的封装：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/SpringSocial%E5%AE%9E%E7%8E%B0OAuah%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.png" alt="image"></p>
<ul>
<li><p>对于服务提供商</p>
<ul>
<li>SpringSocial将与服务商的交互封装进了ServiceProvider，并提供了抽象的实现AbstractOAutrh2ServiceProvider；</li>
<li>SpringSocial将前5步操作封装进了OAuth2Operations，并提供了默认实现OAuth2Template；</li>
<li>对于第6步获取用户信息，由于不同的服务商提供的数据格式不一样，SpringSocial提供了一个接口，以及抽象的类AbstractOAuth2ApiBinding，方便我们继承完善。</li>
</ul>
</li>
<li><p>对于第三方应用</p>
<p>  SpringSocial将从服务提供商获取用户基本信息的整个过程封装成了一个Connection：</p>
<ul>
<li>通过ServiceProvider取用户基信息</li>
<li>通ApiAdapter处理适配用户信息数据</li>
<li>通过工厂类ConnectionFactory获取Connection</li>
<li>拿到服务提供你商提供的用户信息后，用户信息与第三方应用本身用户的映射关系存在表UserConnection中</li>
<li>通过UsersConnectionRepository操作UserConnection</li>
</ul>
</li>
</ul>
<p>上面就是SpringSocial实现OAuth2第三方登录的流程，上面的这些接口需要为我们配合实现。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Social</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-退出登录</title>
    <url>/2019/06/14/SpringSecurity-%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Spring-Security默认的退出处理逻辑"><a href="#Spring-Security默认的退出处理逻辑" class="headerlink" title="Spring Security默认的退出处理逻辑"></a>Spring Security默认的退出处理逻辑</h1><ol>
<li>是当前session失效</li>
<li>清除与当前用户相关的remember-me记录</li>
<li>清空当前的SecurityContext</li>
<li>重定向到登录页</li>
</ol>
<h1 id="与退出登录相关的配置"><a href="#与退出登录相关的配置" class="headerlink" title="与退出登录相关的配置"></a>与退出登录相关的配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.logout()</span><br><span class="line">    .logoutUrl(&quot;logout&quot;)</span><br><span class="line">&#x2F;&#x2F;  .logoutSuccessUrl(&quot;&#x2F;evolutionary-logout.html&quot;)</span><br><span class="line">    .logoutSuccessHandler(logoutSuccessHandler)</span><br><span class="line">    .deleteCookies(&quot;JSESSIONID&quot;)</span><br><span class="line">    .and()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认的退出成功处理器，如果设置了evolutionary.security.browser.signOutUrl，则跳到配置的地址上，</span><br><span class="line"> * 如果没配置，则返回json格式的响应。</span><br><span class="line"> *</span><br><span class="line"> * @author richey</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EvolutionaryLogoutSuccessHandler implements LogoutSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line">	private Logger logger &#x3D; LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">	public EvolutionaryLogoutSuccessHandler(String signOutSuccessUrl) &#123;</span><br><span class="line">		this.signOutSuccessUrl &#x3D; signOutSuccessUrl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String signOutSuccessUrl;</span><br><span class="line"></span><br><span class="line">	private ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">		logger.info(&quot;退出成功&quot;);</span><br><span class="line"></span><br><span class="line">		if (StringUtils.isBlank(signOutSuccessUrl)) &#123;</span><br><span class="line">			response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class="line">			response.getWriter().write(objectMapper.writeValueAsString(new SimpleResult(&quot;退出成功&quot;)));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			response.sendRedirect(signOutSuccessUrl);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-Session管理</title>
    <url>/2019/06/13/SpringSecurity-Session%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Sesison超时"><a href="#Sesison超时" class="headerlink" title="Sesison超时"></a>Sesison超时</h1><ul>
<li><p>Spring boot设置sesison超时时间</p>
<pre><code>spring.session.timeout = 10; // 单位是s,默认是30分钟</code></pre><p>从源码可以看出最短超时时间是1分钟,如下:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    TomcatEmbeddedServletContainerFactory#configureSession()</span><br><span class="line"></span><br><span class="line">    private long getSessionTimeoutInMinutes() &#123;</span><br><span class="line">long sessionTimeout &#x3D; getSessionTimeout();</span><br><span class="line">if (sessionTimeout &gt; 0) &#123;</span><br><span class="line">	sessionTimeout &#x3D; Math.max(TimeUnit.SECONDS.toMinutes(sessionTimeout), 1L);</span><br><span class="line">&#125;</span><br><span class="line">return sessionTimeout;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Session失效后的程序处理</p>
<p>  设置Sesison失效后的跳转路径</p>
<pre><code>.sessionManagement()
  .invalidSessionUrl(&quot;/session/invalid&quot;) //Session失效后跳转的地址
  .and()</code></pre><p>  提供session失效跳转的接口</p>
<pre><code>@GetMapping(&quot;/session/invalid&quot;)
@ResponseStatus(code = HttpStatus.UNAUTHORIZED)
public SimpleResult sessionInvalid() {
  String message = &quot;session失效&quot;;
  return new SimpleResult(message);
}</code></pre></li>
</ul>
<h1 id="Session并发控制"><a href="#Session并发控制" class="headerlink" title="Session并发控制"></a>Session并发控制</h1><ul>
<li><p>一个帐号同时只允许一个用户登录,后面登录用户踢掉前面用户</p>
<pre><code>.maximumSessions(1)
.and()</code></pre><p>对于后面session过期(后面的用户挤掉之前的用户)事件的处理策略:</p>
<pre><code>.expiredSessionStrategy(SessionInformationExpiredStrategy)</code></pre><p>下面写一个session超时策略的实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author richey</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AbstractSessionStrategy &#123;</span><br><span class="line"></span><br><span class="line">	private final Logger logger &#x3D; LoggerFactory.getLogger(getClass());</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 跳转的url</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String destinationUrl;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 系统配置信息</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private SecurityProperties securityPropertie;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 重定向策略</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private RedirectStrategy redirectStrategy &#x3D; new DefaultRedirectStrategy();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 跳转前是否创建新的session</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private boolean createNewSession &#x3D; true;</span><br><span class="line"></span><br><span class="line">	private ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public AbstractSessionStrategy(SecurityProperties securityPropertie) &#123;</span><br><span class="line">		String invalidSessionUrl &#x3D; securityPropertie.getBrower().getSession().getSessionInvalidUrl();</span><br><span class="line">		Assert.isTrue(UrlUtils.isValidRedirectUrl(invalidSessionUrl), &quot;url must start with &#39;&#x2F;&#39; or with &#39;http(s)&#39;&quot;);</span><br><span class="line">		Assert.isTrue(StringUtils.endsWithIgnoreCase(invalidSessionUrl, &quot;.html&quot;), &quot;url must end with &#39;.html&#39;&quot;);</span><br><span class="line">		this.destinationUrl &#x3D; invalidSessionUrl;</span><br><span class="line">		this.securityPropertie &#x3D; securityPropertie;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	protected void onSessionInvalid(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		logger.info(&quot;session失效&quot;);</span><br><span class="line"></span><br><span class="line">		if (createNewSession) &#123;</span><br><span class="line">			request.getSession();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String sourceUrl &#x3D; request.getRequestURI();</span><br><span class="line">		String targetUrl;</span><br><span class="line"></span><br><span class="line">		if (StringUtils.endsWithIgnoreCase(sourceUrl, &quot;.html&quot;)) &#123;</span><br><span class="line">			if(StringUtils.equals(sourceUrl, securityPropertie.getBrower().getLoginPage())</span><br><span class="line">					|| StringUtils.equals(sourceUrl, securityPropertie.getBrower().getSignOutUrl()))&#123;</span><br><span class="line">				targetUrl &#x3D; sourceUrl;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				targetUrl &#x3D; destinationUrl;</span><br><span class="line">			&#125;</span><br><span class="line">			logger.info(&quot;跳转到:&quot;+targetUrl);</span><br><span class="line">			redirectStrategy.sendRedirect(request, response, targetUrl);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			Object result &#x3D; buildResponseContent(request);</span><br><span class="line">			response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">			response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class="line">			response.getWriter().write(objectMapper.writeValueAsString(result));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected Object buildResponseContent(HttpServletRequest request) &#123;</span><br><span class="line">		String message &#x3D; &quot;session已失效&quot;;</span><br><span class="line">		if (isConcurrency()) &#123;</span><br><span class="line">			message &#x3D; message + &quot;，有可能是并发登录导致的&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		return new SimpleResult(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * session失效是否是并发导致的</span><br><span class="line">	 *</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected boolean isConcurrency() &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Determines whether a new session should be created before redirecting (to</span><br><span class="line">	 * avoid possible looping issues where the same session ID is sent with the</span><br><span class="line">	 * redirected request). Alternatively, ensure that the configured URL does</span><br><span class="line">	 * not pass through the &#123;@code SessionManagementFilter&#125;.</span><br><span class="line">	 *</span><br><span class="line">	 * @param createNewSession</span><br><span class="line">	 *            defaults to &#123;@code true&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setCreateNewSession(boolean createNewSession) &#123;</span><br><span class="line">		this.createNewSession &#x3D; createNewSession;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author richey</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EvolutionaryExpiredSessionStrategy extends AbstractSessionStrategy implements SessionInformationExpiredStrategy&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public EvolutionaryExpiredSessionStrategy(SecurityProperties securityPropertie) &#123;</span><br><span class="line">        super(securityPropertie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException &#123;</span><br><span class="line">        onSessionInvalid(event.getRequest(), event.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个帐号同时只允许一个用户登录,后面登录用户不允许登录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.maximumSessions(1)</span><br><span class="line">.maxSessionsPreventsLogin(true) &#x2F;&#x2F;session达到最大数量后,不允许后面的用户登录</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure>


<h1 id="集群Session管理"><a href="#集群Session管理" class="headerlink" title="集群Session管理"></a>集群Session管理</h1><ul>
<li><p>spring-session,将session信息单独存储</p>
<p>依赖</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Spring-session支持的存储类型</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REDIS,</span><br><span class="line">MONGO,</span><br><span class="line">JDBC,</span><br><span class="line">HAZELCAST,</span><br><span class="line">HASH_MAP,</span><br><span class="line">NONE;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定spring-session的存储类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.session.store-type&#x3D;REDIS</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/06/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="观察者模式"></p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpg" alt="观察者模式"></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>定义了一对多的关系，这样，当一方对象状态改变时，它的所有依赖都会收到通知，并自动更新。</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>Spring中的事件机制，是观察者模式思想的一种实现</p>
<h2 id="Spring中观察者模式的四个角色"><a href="#Spring中观察者模式的四个角色" class="headerlink" title="Spring中观察者模式的四个角色"></a>Spring中观察者模式的四个角色</h2><ul>
<li>事件（ApplicationEvent）</li>
</ul>
<p>ApplicationEvent 是所有事件对象的父类。ApplicationEvent 继承自 jdk 的 EventObject, 所有的事件都需要继承 ApplicationEvent, 并且通过source得到事件源。</p>
<p>下列描述了Spring提供的内置事件：</p>
<p>ContextRefreshedEvent：事件发布在 ApplicationContext 初始化或刷新时（例如：通过在 ConfigurableApplicationContext 接口使用refresh()方法）。这里,“初始化”意味着所有 bean 加载，post-processor bean 被检测到并且激活,单例预先实例化，ApplicationContext 对象可以使用了。只要上下文没有关闭,可以触发多次刷新, ApplicationContext 提供了一种可选择的支持这种“热”刷新。例如：XmlWebApplicationContext 支持热刷新,但 GenericApplicationContext 并非如此。具体是在 AbstractApplicationContext 的 finishRefresh() 方法中。</p>
<p>ContextStartedEvent：事件发布在 ApplicationContext 开始使用 ConfigurableApplicationContext 接口 start() 方法。这里,“开始”意味着所有生命周期 bean 接收到一个明确的起始信号。通常,这个信号用于明确停止后重新启动,但它也可以用于启动组件没有被配置为自动运行（例如：组件还没有开始初始化）。</p>
<p>ContextStoppedEvent：事件发布在 ApplicationContext 停止时通过使用 ConfigurableApplicationContext 接口上的 stop() 方法。在这里,“停止”意味着所有生命周期bean接收一个显式的停止信号。停止上下文可以通过重新调用start()方法。</p>
<p>ContextClosedEvent：事件发布在 ApplicationContext 关闭时通过关闭 ConfigurableApplicationContext 接口()方法。这里,“封闭”意味着所有单例 bean 被摧毁。一个封闭的环境达到生命的终结。它不能刷新或重启。</p>
<p>RequestHandledEvent：一个特定的web事件告诉所有能处理HTTP请求的bean 。这个事件是在请求完成后发布的。这个事件只适用于使用 Spring 的 DispatcherServlet 的web应用程序。</p>
<ul>
<li>事件监听（ApplicationListener）</li>
</ul>
<p>ApplicationListener 事件监听器，也就是观察者。继承自 jdk 的 EventListener，该类中只有一个方法 onApplicationEvent。当监听的事件发生后该方法会被执行。</p>
<ul>
<li>事件发布（ApplicationContext）</li>
</ul>
<p>ApplicationContext 是 Spring 中的核心容器，在事件监听中 ApplicationContext 可以作为事件的发布者，也就是事件源。因为 ApplicationContext 继承自 ApplicationEventPublisher。在 ApplicationEventPublisher 中定义了事件发布的方法 — publishEvent(Object event)</p>
<ul>
<li>事件管理（ApplicationEventMulticaster）</li>
</ul>
<p>ApplicationEventMulticaster 用于事件监听器的注册和事件的广播。监听器的注册就是通过它来实现的，它的作用是把 Applicationcontext 发布的 Event 广播给它的监听器列表。</p>
<h2 id="Spring中实现观察者模式"><a href="#Spring中实现观察者模式" class="headerlink" title="Spring中实现观察者模式"></a>Spring中实现观察者模式</h2><ol>
<li><p>自定义需要发布的事件类，需要继承 ApplicationEvent 类或 PayloadApplicationEvent (该类也仅仅是对 ApplicationEvent 的一层封装)</p>
</li>
<li><p>使用 @EventListener 来监听事件或者实现 ApplicationListener 接口。</p>
</li>
<li><p>使用 ApplicationEventPublisher 来发布自定义事件（@Autowired注入即可）</p>
<p> @TransactionalEventListener 监听器：如果事件的发布不是在事务（@Transactional）范围内，则监听不到该事件，除非将 fallbackExecution 标志设置为 true（@TransactionalEventListener(fallbackExecution = true)）;如果在事务中，可以选择在事务的哪个阶段来监听事件，默认在事务提交后监听（@TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)）。</p>
</li>
</ol>
<p>以上介绍的事件监听都是同步，如果需要开启异步支持的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventConfiguration</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Executors.newCachedThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="事件（MyEvent-java"><a href="#事件（MyEvent-java" class="headerlink" title="事件（MyEvent.java)"></a>事件（MyEvent.java)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(ApplicationContext source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        System.out.println(<span class="string">"MyEvent 构造器执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟业务逻辑执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件监听（MyListenerA-java、MyListenerB-java）"><a href="#事件监听（MyListenerA-java、MyListenerB-java）" class="headerlink" title="事件监听（MyListenerA.java、MyListenerB.java）"></a>事件监听（MyListenerA.java、MyListenerB.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListenerA</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyListenerA"</span>);</span><br><span class="line">        myEvent.echo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListenerB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyListenerB"</span>);</span><br><span class="line">        myEvent.echo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件发布（MyPublisher-java）"><a href="#事件发布（MyPublisher-java）" class="headerlink" title="事件发布（MyPublisher.java）"></a>事件发布（MyPublisher.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布事件</span></span><br><span class="line"><span class="comment">     * 监听该事件的监听者都可以获取消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> myEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publisherEvent</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---开始发布 myEvent 事件---"</span>);</span><br><span class="line">        applicationContext.publishEvent(myEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DesignPatternsApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyPublisher myPublisher;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyEvent myEvent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myPublisher.publisherEvent(myEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-Session管理 (1)</title>
    <url>/2019/06/12/SpringSecurity-Session%E7%AE%A1%E7%90%86%20(1)/</url>
    <content><![CDATA[<h1 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h1><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><ul>
<li>Session超时处理</li>
<li>Session并发控制</li>
<li>集群Session管理</li>
</ul>
<h2 id="Session超时处理"><a href="#Session超时处理" class="headerlink" title="Session超时处理"></a>Session超时处理</h2><p>在Spring Boot中Session的超时时间非常简单,在配置文件中配置即可:</p>
<pre><code>server.session.timeout=1000</code></pre><p>单位是秒,默认是30分钟,如果查看Spring Boot源代码的话,你会发现,实际生效的最短时间是1分钟:</p>
<pre><code>TomcatEmbeddedServletContainerFactory#configureSession


private void configureSession(Context context) {
    long sessionTimeout = this.getSessionTimeoutInMinutes();
    context.setSessionTimeout((int)sessionTimeout);
    if (this.isPersistSession()) {
        Manager manager = context.getManager();
        if (manager == null) {
            manager = new StandardManager();
            context.setManager((Manager)manager);
        }

        this.configurePersistSession((Manager)manager);
    } else {
        context.addLifecycleListener(new TomcatEmbeddedServletContainerFactory.DisablePersistSessionListener(null));
    }

}

private long getSessionTimeoutInMinutes() {
    long sessionTimeout = (long)this.getSessionTimeout();
    if (sessionTimeout &gt; 0L) {
        //这里拿设置的值跟一分钟做了比较,取最大值
        sessionTimeout = Math.max(TimeUnit.SECONDS.toMinutes(sessionTimeout), 1L);
    }

    return sessionTimeout;
}</code></pre><ul>
<li><p>当Session失效之后再刷新页面,我们要知道是因为Session失效,从而对应的做一些特殊的提示等操作:</p>
<p>  在配置中配置失效后请求地址</p>
<pre><code>.sessionManagement()
                    .invalidSessionUrl(&quot;/session/invalid&quot;)
                    .and()

@GetMapping(&quot;/session/invalid&quot;)
@ResponseStatus(code = HttpStatus.UNAUTHORIZED)
public SimpleResult sessionInvalid() {
    String message = &quot;session失效&quot;;
    return new SimpleResult(message);
}</code></pre><p>  将该地址设置为免校验</p>
<pre><code>.antMatchers(&quot;/session/invalid&quot;)
                .permitAll()</code></pre></li>
</ul>
<h2 id="Session并发控制"><a href="#Session并发控制" class="headerlink" title="Session并发控制"></a>Session并发控制</h2><ul>
<li><p>一个用户同时只能在一台设备登录,第二个设备登录后,第一个失效,并记录</p>
<pre><code>.sessionManagement()
    .invalidSessionUrl(&quot;/session/invalid&quot;)
    .maximumSessions(1)//最大登录数
    .expiredSessionStrategy(new EvolutionaryExpiredSessionStrategy())
    .and()
    .and()

/**
 * @author richey
 */
public class EvolutionaryExpiredSessionStrategy implements SessionInformationExpiredStrategy{</code></pre></li>
</ul>
<pre><code>    @Override
    public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException {
        //这里可以记录并发登录造成Session失效的信息
        event.getResponse().setContentType(&quot;application/json;charset=UTF-8&quot;);
        event.getResponse().getWriter().write(&quot;并发登录!&quot;);
    }
}</code></pre><ul>
<li><p>一个用户同时只能在一台设备登录,第二个设备不允许登录</p>
<pre><code>.sessionManagement()
    .invalidSessionUrl(&quot;/session/invalid&quot;)
    .maximumSessions(1)//最大登录数
    .maxSessionsPreventsLogin(true)//当Session的数量达到最大数量后,阻止后续的登录行为
    .expiredSessionStrategy(new EvolutionaryExpiredSessionStrategy())
    .and()
    .and()</code></pre></li>
</ul>
<h2 id="集群Session管理"><a href="#集群Session管理" class="headerlink" title="集群Session管理"></a>集群Session管理</h2><ul>
<li>使用redis的好处</li>
</ul>
<p>Session访问非常频繁<br>redis自带超时特性</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（11）－OAuth协议简介</title>
    <url>/2019/06/11/Spring%20Security%EF%BC%8811%EF%BC%89%EF%BC%8DOAuth%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>概览：</p>
<ul>
<li><p>OAuth协议要解决的问题</p>
</li>
<li><p>OAuth协议中的各种角色</p>
</li>
<li><p>OAuth协议运行流程</p>
</li>
</ul>
<h2 id="OAuth协议要解决的问题"><a href="#OAuth协议要解决的问题" class="headerlink" title="OAuth协议要解决的问题"></a>OAuth协议要解决的问题</h2><p>OAuth协议主要是为了解决传统的授权（比如用户名密码授权）存在的问题：</p>
<ol>
<li>授权后应用可以访问所有数据（危险）</li>
<li>用户只有修改密码才能收回授权</li>
<li>密码泄露的可能性高</li>
</ol>
<h2 id="OAuth协议中的各种角色"><a href="#OAuth协议中的各种角色" class="headerlink" title="OAuth协议中的各种角色"></a>OAuth协议中的各种角色</h2><ol>
<li><p>服务提供商（Provider)</p>
<p> 提供令牌Token</p>
<p> 在服务提供商中还存在了两个子角色：</p>
<ul>
<li>认证服务器（Authorization Server）,用于生成令牌</li>
<li>资源服务器(Resource Server)，用户保存用户数据及验证令牌</li>
</ul>
</li>
<li><p>资源所有者(Resource Owner)</p>
<p> 资源所有者一般是用户自己</p>
</li>
<li><p>第三方应用(Client)</p>
</li>
</ol>
<p><img src="http://ogiythg18.bkt.clouddn.com/OAuth%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2.png" alt="image"></p>
<h2 id="OAuth协议运行流程"><a href="#OAuth协议运行流程" class="headerlink" title="OAuth协议运行流程"></a>OAuth协议运行流程</h2><p>知道了OAuth协议中的各种角色，下面我们来看下这些角色之间是怎么协作运行的。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/OAuth%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p>上面的流程中第二步：同意授权是关键，只有用户同意授权了之后，后面的流程才会继续下去，OAuth协议中支持了4种授权模式：</p>
<ol>
<li>授权码模式(authorization code)</li>
<li>简化模式(implicit)</li>
<li>密码模式(resource owner password credentials)</li>
<li>客户端模式(client credentials)</li>
</ol>
<p>目前市场上服务提供商基本上都采用的是授权码模式来完成整个OAuth流程的，这种模式也是四种模式中年功能最完整，流程最严密的授权模式。下面我们说一下授权码模式的认证流程。</p>
<p>授权码模式：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/OAuth%E6%8E%88%E6%9D%83%E7%A0%81%E8%AE%A4%E8%AF%81.png" alt="image"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jdk自带工具jvisualvm查看.hprof文件</title>
    <url>/2019/06/10/%E4%BD%BF%E7%94%A8jdk%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7jvisualvm%E6%9F%A5%E7%9C%8B.hprof%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>使用jdk自带的jvisualvm.exe程序来查看内存溢出文件</p>
<p>位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JAVA_HOME&#x2F;bin&#x2F;jvisualvm</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（10）－短信登录开发</title>
    <url>/2019/06/10/Spring%20Security%EF%BC%8810%EF%BC%89%EF%BC%8D%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>Spring Security默认没有支持基于短信的认证方式，我们先回顾一下Spring Security开发基于表单的认流程：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/Spring%20Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>我们只需要仿照Spring Security的认证流程，添加短信登录认证相关的组件就可以了，如下：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95.png" alt="image"></p>
<p>我们需要自定义下面几个类：</p>
<ul>
<li>SmsCodeAuthenticationToken</li>
<li>SmsCodeAuthenticationFilter</li>
<li>SmsCodeAuthenticationProvider</li>
</ul>
<p>同时需要将我们自定义的filter和provider配置到Spring Security的过滤器链上</p>
<pre><code>SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = new SmsCodeAuthenticationFilter();
smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));
smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(evolutionaryAuthenticationHandler);
smsCodeAuthenticationFilter.setAuthenticationFailureHandler(evolutionaryAuthenticationFailureHandler);

SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = new SmsCodeAuthenticationProvider();
smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);

http.authenticationProvider(smsCodeAuthenticationProvider)
        .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</code></pre><p>流程就是这样，<a href="https://github.com/liubaolin/evolutionary/tree/master/evolutionary-security" target="_blank" rel="noopener">具体代码移步github项目</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/06/10/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg" alt="适配器模式"></p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li><p>抽象策略略⻆色<br>  这个是⼀一个抽象的角色，通常情况下使⽤接口或者抽象类去实现。比如我们的Comparator接⼝口。</p>
</li>
<li><p>具体策略略⻆色<br>  包装了了具体的算法和⾏行行为。比如实现了Comparator接口的一组实现类。</p>
</li>
<li><p>环境⻆角⾊色Context<br>  内部会持有⼀个抽象⻆色的引⽤用，给客户端调⽤策略模式用于封装系列的算法，这些算法通常被封装在一个被称为 Context 类中，<br>客户端程序可以⾃由选择其中一种算法，或让 Context 为客户端选择一个最佳的算法——使⽤策略模式的优势是为了⽀支持算法的自由切换。</p>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li><p>Resource和策略略模式<br>  Resource 接口就是策略模式的典型应用，Resource 接口就代表资源访问策略，但具体采⽤用哪种策略实现，Resource 接口并不理理会。<br>客户端程序只和Resource 接口耦合，并不知道底层采⽤何种资源访问策略，这样应用可以在不同的资源访问策略之间自由切换。</p>
</li>
<li><p>Spring 框架的 Context 如何“智能”地选择资源访问策略<br>  Spring提供两个标志性接口：</p>
<ul>
<li>ResourceLoader：该接口实现类的实例可以获得⼀个 Resource 实例例。</li>
<li>ResourceLoaderAware：该接口实现类的实例将获得一个 ResourceLoader 的引用。<br>在 ResourceLoader 接口里有如下方法：Resource getResource(String location)：该接口仅包含这个⽅法，该方法⽤于返回一个 Resource 实例例。</li>
</ul>
<p>ApplicationContext 的实现类都实现 ResourceLoader 接⼝，因此 ApplicationContext 可⽤于直接获取 Resource 实例。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（9）－验证码处理</title>
    <url>/2019/06/09/Spring%20Security%EF%BC%889%EF%BC%89%EF%BC%8D%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>先看一下短信接口的代码结构图：</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="验证码处理代码结构图"></p>
<p>这里我们将验证码的处理抽象为一层，不仅用于处理短信验证码，也处理图片验证码。同时将验证码生成的逻辑单独抽象为一层，这体现了代码分层的思想。当业务变动的时候我们可以较为灵活的修改某一层的代码即可。</p>
<p>代码就不多说了，感兴趣可移步<a href="https://github.com/liubaolin/evolutionary/tree/master/evolutionary-security" target="_blank" rel="noopener">github的项目地址</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>生产故障排查流程</title>
    <url>/2019/06/08/%E7%94%9F%E4%BA%A7%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="使用-top-查看系统中消耗cpu比较多的进程PID"><a href="#使用-top-查看系统中消耗cpu比较多的进程PID" class="headerlink" title="使用 top 查看系统中消耗cpu比较多的进程PID"></a>使用 top 查看系统中消耗cpu比较多的进程PID</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[richey@localhost ~]$ top |grep java</span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   2.7  11.3   5:49.83 java                                                                             </span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   1.3  11.3   5:49.87 java                                                                             </span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   1.7  11.3   5:49.92 java                                                                             </span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   1.3  11.3   5:49.96 java                                                                             </span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   1.3  11.3   5:50.00 java                                                                             </span><br><span class="line"> 7439 richey    20   0 7785472 346788  21388 S   0.3   2.1   0:06.05 java                                                                             </span><br><span class="line"> 6274 richey    20   0   10.1g   1.7g  76144 S   1.3  11.3   5:50.04 java</span><br></pre></td></tr></table></figure>
<h1 id="使用-ps-查看java相关进程的详细信息"><a href="#使用-ps-查看java相关进程的详细信息" class="headerlink" title="使用 ps 查看java相关进程的详细信息"></a>使用 ps 查看java相关进程的详细信息</h1><p>可以看出java进程JVM的详细配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[richey@localhost ~]$ ps -ef|grep java|grep 6274</span><br><span class="line"></span><br><span class="line">[richey@localhost ~]$ ps -ef|grep java|grep 6274</span><br><span class="line">richey    6274  6220 39 23:32 ?        00:05:52 /opt/idea-IU-172.4155.36/jre64/bin/java -Xbootclasspath/a:/opt/idea-IU-172.4155.36/lib/boot.jar -classpath /opt/idea-IU-172.4155.36/lib/bootstrap.jar:/opt/idea-IU-172.4155.36/lib/extensions.jar:/opt/idea-IU-172.4155.36/lib/util.jar:/opt/idea-IU-172.4155.36/lib/jdom.jar:/opt/idea-IU-172.4155.36/lib/log4j.jar:/opt/idea-IU-172.4155.36/lib/trove4j.jar:/opt/idea-IU-172.4155.36/lib/jna.jar:/opt/idea-IU-172.4155.36/jre64/lib/tools.jar -Xms2048m -Xmx6144m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Dawt.useSystemAAFontSettings=lcd -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine -XX:ErrorFile=/home/richey/java_error_in_IDEA_%p.log -XX:HeapDumpPath=/home/richey/java_error_in_IDEA.hprof -Didea.paths.selector=IntelliJIdea2017.2 -Djb.vmOptionsFile=/opt/idea-IU-172.4155.36/bin/idea64.vmoptions -Didea.jre.check=true com.intellij.idea.Main</span><br></pre></td></tr></table></figure>

<h1 id="使用-top-H-p-PID-来查看当前进程中比较消耗cpu的线程"><a href="#使用-top-H-p-PID-来查看当前进程中比较消耗cpu的线程" class="headerlink" title="使用 top -H -p PID 来查看当前进程中比较消耗cpu的线程"></a>使用 top -H -p PID 来查看当前进程中比较消耗cpu的线程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -H -p 6274</span><br></pre></td></tr></table></figure>

<p>拿到消耗cpu比较高的线程pid,先转换成16进制的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将16进制的pid 1077 转换成10进制</span><br><span class="line">rintf &quot;%x\n&quot; 1077</span><br></pre></td></tr></table></figure>

<p>最后使用jstack pid|grep 16进制的线程id，就可以定位到问题代码。</p>
]]></content>
      <categories>
        <category>生产故障</category>
      </categories>
      <tags>
        <tag>问题定位</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（8）－添加记住我功能</title>
    <url>/2019/06/08/Spring%20Security%EF%BC%888%EF%BC%89%EF%BC%8D%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>概要：</p>
<p>记住我功能基本原理</p>
<p>记住我功能具体实现</p>
<p>记住我功能Spring Security源码解析</p>
<h2 id="1-记住我功能基本原理"><a href="#1-记住我功能基本原理" class="headerlink" title="1.记住我功能基本原理"></a>1.记住我功能基本原理</h2><p><img src="http://ogiythg18.bkt.clouddn.com/%E8%AE%B0%E4%BD%8F%E6%88%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%861.png" alt="image"></p>
<ol>
<li>浏览器登录请求，UserNamePasswordAuthenticationFilter进行认证</li>
<li>认证成功后调用RemeberMeService，RememberMeService将Token写入浏览器Cookie，并通过TokenRepository将Token写入数据库</li>
<li>当浏览器再次发起请求时，如果Spring Security过滤器链上在rememberMeAuthenticationFilter之前没能认证成功，则rememberMeAuthenticationFilter会调用RememberMeService，尝试通过TokenRepository根据请求Cookie中的Token从数据库中查找Token及用户名</li>
<li>找到用户名后调用UserDetailService，进行默认登录操作。</li>
</ol>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E8%AE%B0%E4%BD%8F%E6%88%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89.png" alt="image"></p>
<h2 id="2-记住我功能具体实现"><a href="#2-记住我功能具体实现" class="headerlink" title="2.记住我功能具体实现"></a>2.记住我功能具体实现</h2><ul>
<li><p>前端添加记住我check-box,这里要注意的是name属性必须等于“remember-me”</p>
<pre><code>&lt;tr&gt;
    &lt;!--这里的name必须是remember-me--&gt;
    &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;/&gt;记住我&lt;/td&gt;
&lt;/tr&gt;</code></pre></li>
</ul>
<ul>
<li>配置记住我功能</li>
</ul>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
    validateCodeFilter.setAuthenticationFailureHandler(evolutionaryAuthenticationFailureHandler);
    validateCodeFilter.setSecurityProperties(securityProperties);
    validateCodeFilter.afterPropertiesSet();

    http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
            .formLogin()  //表单登录
                .loginPage(&quot;/authentication/require&quot;) //如果需要身份认证则跳转到这里
                .loginProcessingUrl(&quot;/authentication/form&quot;)//登录请求的url
                .successHandler(evolutionaryAuthenticationHandler)
                .failureHandler(evolutionaryAuthenticationFailureHandler)
                .and()
            //配置记住我功能
            .rememberMe()
                .tokenRepository(persistentTokenRepository())
                .tokenValiditySeconds(securityProperties.getBrower().getRememberSeconds())
                .userDetailsService(userDetailsService)
            .and()
            .authorizeRequests()
            .antMatchers(&quot;/authentication/require&quot;,
                    securityProperties.getBrower().getLoginPage(),
                    &quot;/code/image&quot;)
            .permitAll()
            .anyRequest()
            .authenticated()
            .and().csrf().disable();

}


    @Bean
    public PersistentTokenRepository persistentTokenRepository() {
        JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
        tokenRepository.setDataSource(dataSource);
        //第一次启动的时候自动创建表或者提供sql自行创建表
        //tokenRepository.setCreateTableOnStartup(true);
        return tokenRepository;
    }</code></pre><p>基于Spring Security开发记住我功能非常简单，下面我们根据基本原理分析下源码</p>
<h2 id="3-记住我功能Spring-Security源码解析"><a href="#3-记住我功能Spring-Security源码解析" class="headerlink" title="3.记住我功能Spring Security源码解析"></a>3.记住我功能Spring Security源码解析</h2><p>第一次登录的时候进UsernamePasswordAuthenticationFilter#attemptAuthentication</p>
<pre><code>authResult = attemptAuthentication(request, response);</code></pre><p>认证成功后又调了successfulAuthentication方法</p>
<pre><code>protected void successfulAuthentication(HttpServletRequest request,
        HttpServletResponse response, FilterChain chain, Authentication authResult)
        throws IOException, ServletException {


    SecurityContextHolder.getContext().setAuthentication(authResult);

    //注意
    rememberMeServices.loginSuccess(request, response, authResult);


    successHandler.onAuthenticationSuccess(request, response, authResult);
}</code></pre><p>这里调用了rememberMeServices#loginSuccess方法，做了几件事情，生成一个Token，将Token写到浏览器Cookie中以及将Token保存到数据库中。</p>
<pre><code>protected void onLoginSuccess(HttpServletRequest request,
        HttpServletResponse response, Authentication successfulAuthentication) {
    String username = successfulAuthentication.getName();



    PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(
            username, generateSeriesData(), generateTokenData(), new Date());

    tokenRepository.createNewToken(persistentToken);
        addCookie(persistentToken, request, response);
}</code></pre><p>到这第一次登录过程就结束了,当我们重启服务再次（跳过登录）访问时，会进到RememberMeAuthenticationFilter中</p>
<pre><code>public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) res;

    if (SecurityContextHolder.getContext().getAuthentication() == null) {
        Authentication rememberMeAuth = rememberMeServices.autoLogin(request,
                response);

        if (rememberMeAuth != null) {
            // Attempt authenticaton via AuthenticationManager
                rememberMeAuth = authenticationManager.authenticate(rememberMeAuth);

                // Store to SecurityContextHolder
                SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);

                onSuccessfulAuthentication(request, response, rememberMeAuth);



        chain.doFilter(request, response);
    }else {


        chain.doFilter(request, response);
    }
}</code></pre><p>这里会判断当前上下文是否又认证信息，没有的话调用rememberMeServices.autoLogin(request,esponse);</p>
<pre><code>public final Authentication autoLogin(HttpServletRequest request,
        HttpServletResponse response) {
    String rememberMeCookie = extractRememberMeCookie(request);


    UserDetails user = null;

    String[] cookieTokens = decodeCookie(rememberMeCookie);
    user = processAutoLoginCookie(cookieTokens, request, response);
    userDetailsChecker.check(user);

    logger.debug(&quot;Remember-me cookie accepted&quot;);

    return createSuccessfulAuthentication(request, user);

    cancelCookie(request, response);
    return null;
}</code></pre><p>这里会从request中的cookie中拿到token，然后调用processAutoLoginCookie方法拿到useDetail,这个过程如下：</p>
<pre><code>protected UserDetails processAutoLoginCookie(String[] cookieTokens,
            HttpServletRequest request, HttpServletResponse response) {

    if (cookieTokens.length != 2) {
        throw new InvalidCookieException(&quot;Cookie token did not contain &quot; + 2
                + &quot; tokens, but contained &apos;&quot; + Arrays.asList(cookieTokens) + &quot;&apos;&quot;);
    }

    final String presentedSeries = cookieTokens[0];
    final String presentedToken = cookieTokens[1];

    PersistentRememberMeToken token = tokenRepository
            .getTokenForSeries(presentedSeries);




    if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L &lt; System
            .currentTimeMillis()) {
        throw new RememberMeAuthenticationException(&quot;Remember-me login has expired&quot;);
    }



    PersistentRememberMeToken newToken = new PersistentRememberMeToken(
            token.getUsername(), token.getSeries(), generateTokenData(), new Date());

    tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(),
                newToken.getDate());
        addCookie(newToken, request, response);

    return getUserDetailsService().loadUserByUsername(token.getUsername());
}</code></pre><p>通过tokenRepository从数据库查到之前保存的token，然后调用UserDetailsService().loadUserByUsername(token.getUsername())拿到userDetail信息。</p>
<p>最后会用userDetail信息自动登录，这就是整个“记住我”的简单源码分析，建议自己打断点走一遍。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（7）－图片验证码重构</title>
    <url>/2019/06/07/Spring%20Security%EF%BC%887%EF%BC%89%EF%BC%8D%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>上一篇我们写了图片验证码的功能，但是有几个问题需要思考优化一下</p>
<ul>
<li><p>验证码基本参数可配置</p>
<p>  比如超时时间、图片大小等。同时可在多个维度提供配置，比如默认配置、应用级别配置、请求级别配置</p>
</li>
</ul>
<ul>
<li><p>验证码拦截的接口可配置</p>
<p>  之前我们拦截验证码的接口地址是hard code,如果我们有多个请求需要校验验证码怎么办？我们希望可以任意配置拦截地址该怎么做？</p>
</li>
<li><p>验证码的生成逻辑可配置</p>
<p>  做为一个可重用的模块，如果别人要我用我们提供的验证码生成逻辑，要自定义逻辑怎么实现？</p>
</li>
</ul>
<p>上面这些问题是我们在写完第一版验证码后需要思考的问题，下面就不一一提供代码了，只罗列一些关键的实现，其实非常简单，重在思考。</p>
<h3 id="验证码基本参数可配置"><a href="#验证码基本参数可配置" class="headerlink" title="验证码基本参数可配置"></a>验证码基本参数可配置</h3><p>没什么可说的，提供参数配置就好了</p>
<h3 id="验证码拦截的接口可配置"><a href="#验证码拦截的接口可配置" class="headerlink" title="验证码拦截的接口可配置"></a>验证码拦截的接口可配置</h3><p>这里要注意的一点是，接口的匹配，比如/user/<em>,这种接口不能用equals去匹配，因为/user/1,/user/2,/user/a等这种都是匹配/user/</em>的，这时要用一个Spring的工具类</p>
<pre><code>private AntPathMatcher pathMatcher = new AntPathMatcher();


@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    boolean action = false;
    for (String url : urls) {
        if (pathMatcher.match(url, request.getRequestURI())) {
            action = true;
            break;
        }
    }

    if (action) {
        try {
            validate(new ServletWebRequest(request));
        } catch (ValidateCodeException e) {
            authenticationFailureHandler.onAuthenticationFailure(request, response, e);
            return;
        }
    }
    filterChain.doFilter(request, response);
}</code></pre><h3 id="验证码的生成逻辑可配置"><a href="#验证码的生成逻辑可配置" class="headerlink" title="验证码的生成逻辑可配置"></a>验证码的生成逻辑可配置</h3><p>提供一个默认的实现：</p>
<pre><code>public class ImageCodeGenetor implements ValidateCodeGenerator {

    private DefaultKaptcha captchaProducer = null;

    private SecurityProperties securityProperties;

    @Override
    public ImageCode generate(ServletWebRequest request) {
        String code = captchaProducer.createText();
        return new ImageCode(captchaProducer.createImage(code), code, securityProperties.getCode().getImage().getExpireIn());
    }

    public DefaultKaptcha getCaptchaProducer() {
        return captchaProducer;
    }

    public void setCaptchaProducer(DefaultKaptcha captchaProducer) {
        this.captchaProducer = captchaProducer;
    }

    public SecurityProperties getSecurityProperties() {
        return securityProperties;
    }

    public void setSecurityProperties(SecurityProperties securityProperties) {
        this.securityProperties = securityProperties;
    }
}</code></pre><p>配置验证码生成bean，注意这里的细节，我们没有用@Component去注解ImageCodeGenetor，而是在配置中new一个，在这里就可以先用@ConditionalOnMissingBean注解判读是否已经有相应的实现了，有的话我们就不去实例该bean了。</p>
<pre><code>@Configuration
public class ValidateCodeBeanConfig {

    @Autowired
    private DefaultKaptcha captchaProducer = null;

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 在初始化该bean之前看是否已经有名为imageCodeGenerator的bean了，有就不初始化了
     *
     * @return
     */
    @Bean
    @ConditionalOnMissingBean(name = &quot;imageCodeGenerator&quot;)
    public ValidateCodeGenerator imageCodeGenerator() {
        ImageCodeGenetor imageCodeGenetor = new ImageCodeGenetor();
        imageCodeGenetor.setCaptchaProducer(captchaProducer);
        imageCodeGenetor.setSecurityProperties(securityProperties);
        return imageCodeGenetor;
    }

}</code></pre><p>自定义一个验证码生成器，代替系统默认的：</p>
<pre><code>@Component(&quot;imageCodeGenerator&quot;)
public class DemoImageCodeGenerator implements ValidateCodeGenerator {
    @Override
    public ImageCode generate(ServletWebRequest request) {
        //todo
        System.out.println(&quot;更高级的图形验证码生成代码&quot;);
        return null;
    }
}</code></pre><p>这就是本篇的所有内容，不多，但是重在思考。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2019/06/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="适配器模式"></p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/spring%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fdemo.jpg" alt="spring适配器模式demo"></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的接口可以合作无间。</p>
<h1 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h1><ul>
<li>采用组合模式</li>
<li>不仅可以适配某类，还可以适配该类的任何子类。</li>
</ul>
<h1 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h1><ul>
<li>采用继承模式</li>
<li>不需要重新实现整个被适配者，必要的时候可以覆盖被适配者的行为。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（6）－图片验证码</title>
    <url>/2019/06/06/Spring%20Security%EF%BC%886%EF%BC%89%EF%BC%8D%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p>概要：</p>
<ul>
<li>根据随机数生成图片</li>
<li>将随机数存到Session中</li>
<li>将生成的图片写到接口的响应中</li>
</ul>
<h2 id="1、配置google-kaptcha"><a href="#1、配置google-kaptcha" class="headerlink" title="1、配置google kaptcha"></a>1、配置google kaptcha</h2><p>这里我们用google kaptcha生成验证码：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;
    &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;
    &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt;


@Configuration
public class GoogleKaptchaConfig {

    @Bean
    public DefaultKaptcha getDefaultKaptcha() {
        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        Properties properties = new Properties();
        properties.setProperty(&quot;kaptcha.border&quot;, &quot;yes&quot;);
        properties.setProperty(&quot;kaptcha.border.color&quot;, &quot;105,179,90&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;blue&quot;);
        properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;125&quot;);
        properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;45&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;45&quot;);
        properties.setProperty(&quot;kaptcha.session.key&quot;, &quot;code&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);
        properties.setProperty(&quot;kaptcha.textproducer.font.names&quot;, &quot;宋体,楷体,微软雅黑&quot;);
        Config config = new Config(properties);
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }

}</code></pre><h2 id="2、生成验证码"><a href="#2、生成验证码" class="headerlink" title="2、生成验证码"></a>2、生成验证码</h2><p>生成验证码，并将验证码放到session中</p>
<p>验证码类：</p>
<pre><code>/**
 * @author richey
 * 验证码
 */
public class ImageCode {

    private BufferedImage image;

    private String code;

    /**
     * 过期时间
     */
    private LocalDateTime expireTime;

    public ImageCode() {
    }

    public ImageCode(BufferedImage image, String code, LocalDateTime expireTime) {
        this.image = image;
        this.code = code;
        this.expireTime = expireTime;
    }

    /**
     * @param image
     * @param code
     * @param expireIn 秒数，在x秒后过期
     */
    public ImageCode(BufferedImage image, String code, int expireIn) {
        this.image = image;
        this.code = code;
        this.expireTime = LocalDateTime.now().plusSeconds(expireIn);
    }


    public BufferedImage getImage() {
        return image;
    }

    public void setImage(BufferedImage image) {
        this.image = image;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public LocalDateTime getExpireTime() {
        return expireTime;
    }

    public void setExpireTime(LocalDateTime expireTime) {
        this.expireTime = expireTime;
    }

    public boolean isExpired() {
        return this.expireTime == null || this.expireTime.isBefore(LocalDateTime.now());
    }
}</code></pre><p>验证码校验异常类：</p>
<pre><code>public class ValidateCodeException extends AuthenticationException {

    public ValidateCodeException(String msg) {
        super(msg);
    }
}</code></pre><p>验证码接口</p>
<pre><code>@RestController
public class ValidateCodeController {

    public static final String SESSION_KEY = &quot;SESSION_KEY_IMAGE_CODE&quot;;

    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    @Autowired
    private DefaultKaptcha captchaProducer = null;

    @GetMapping(&quot;/code/image&quot;)
    public void createCode(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ImageCode imageCode = createImageCode();
        sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
        ImageIO.write(imageCode.getImage(), &quot;JPEG&quot;, response.getOutputStream());
    }

    private ImageCode createImageCode() {
        String code = captchaProducer.createText();
        return new ImageCode(captchaProducer.createImage(code), code, 60);
    }
}</code></pre><h2 id="3、前台传递验证码"><a href="#3、前台传递验证码" class="headerlink" title="3、前台传递验证码"></a>3、前台传递验证码</h2><pre><code>&lt;td&gt;验证码&lt;/td&gt;
&lt;td&gt;
    &lt;input type=&quot;text&quot; name=&quot;imageCode&quot; id=&quot;imageCode&quot;/&gt;
    &lt;img src=&quot;/code/image&quot;&gt;
    &lt;a href=&quot;javascript:changeKaptcha()&quot;&gt;看不清，换一张&lt;/a&gt;
&lt;/td&gt;</code></pre><h2 id="4、配置校验验证码的过滤器"><a href="#4、配置校验验证码的过滤器" class="headerlink" title="4、配置校验验证码的过滤器"></a>4、配置校验验证码的过滤器</h2><pre><code>public class ValidateCodeFilter extends OncePerRequestFilter {

    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    @Autowired
    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        if (StringUtils.equals(&quot;/authentication/form&quot;, request.getRequestURI()) &amp;&amp;
                StringUtils.equalsIgnoreCase(request.getMethod(), &quot;post&quot;)) {
            try {
                validate(new ServletWebRequest(request));
            } catch (ValidateCodeException e) {
                authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                return;
            }
        }
        filterChain.doFilter(request, response);
    }

    private void validate(ServletWebRequest request) throws ServletRequestBindingException {
        ImageCode codeInSession = (ImageCode) sessionStrategy.getAttribute(request, ValidateCodeController.SESSION_KEY);
        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), &quot;imageCode&quot;);

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException(&quot;验证码的值不能为空&quot;);
        }

        if (codeInSession == null) {
            throw new ValidateCodeException(&quot;验证码不存在&quot;);
        }

        if (codeInSession.isExpired()) {
            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
            throw new ValidateCodeException(&quot;验证码已过期&quot;);
        }

        if (!StringUtils.equalsIgnoreCase(codeInRequest, codeInSession.getCode())) {
            throw new ValidateCodeException(&quot;验证码不匹配&quot;);
        }

        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
    }


    public AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return authenticationFailureHandler;
    }

    public void setAuthenticationFailureHandler(AuthenticationFailureHandler authenticationFailureHandler) {
        this.authenticationFailureHandler = authenticationFailureHandler;
    }
}</code></pre><p>将验证码过滤器配置在UsernamePasswordAuthenticationFilter之前：</p>
<pre><code>@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    @Autowired
    private EvolutionaryAuthenticationSuccessHandler evolutionaryAuthenticationHandler;

    @Autowired
    private EvolutionaryAuthenticationFailureHandler evolutionaryAuthenticationFailureHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(evolutionaryAuthenticationFailureHandler);

        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin()  //表单登录
                .loginPage(&quot;/authentication/require&quot;) //如果需要身份认证则跳转到这里
                .loginProcessingUrl(&quot;/authentication/form&quot;)//登录请求的url
                .successHandler(evolutionaryAuthenticationHandler)
                .failureHandler(evolutionaryAuthenticationFailureHandler)
                .and()
                .authorizeRequests()
                .antMatchers(&quot;/authentication/require&quot;,
                        securityProperties.getBrower().getLoginPage(),
                        &quot;/code/image&quot;)
                .permitAll()
                .anyRequest()
                .authenticated()
                .and().csrf().disable();

    }
}</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（12）-Mysql事务隔离是如何实现的</title>
    <url>/2019/06/05/Mysql%EF%BC%8812%EF%BC%89-Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    <content><![CDATA[<h1 id="事务的启动时机。"><a href="#事务的启动时机。" class="headerlink" title="事务的启动时机。"></a>事务的启动时机。</h1><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p>
<p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的；<br>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p>
<h1 id="在-MySQL-里，有两个“视图”的概念"><a href="#在-MySQL-里，有两个“视图”的概念" class="headerlink" title="在 MySQL 里，有两个“视图”的概念"></a>在 MySQL 里，有两个“视图”的概念</h1><p>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p>
<p>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p>
<h1 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h1><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/mysql%E6%95%B0%E6%8D%AEMVVC.jpg" alt="Mysql数据MVVC"></p>
<p>中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p>
<p>可重复读的定义：一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</p>
<p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p>
<h1 id="事务的可重复读的能力是怎么实现的？"><a href="#事务的可重复读的能力是怎么实现的？" class="headerlink" title="事务的可重复读的能力是怎么实现的？"></a>事务的可重复读的能力是怎么实现的？</h1><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<h1 id="读提交的逻辑和可重复读的区别"><a href="#读提交的逻辑和可重复读的区别" class="headerlink" title="读提交的逻辑和可重复读的区别"></a>读提交的逻辑和可重复读的区别</h1><p>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</p>
<p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p>
<ul>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li>
<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>
<li>而当前读，总是读取已经提交完成的最新版本。</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（5）－认证流程源码详解</title>
    <url>/2019/06/05/Spring%20Security%EF%BC%885%EF%BC%89%EF%BC%8D%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>概要：</p>
<ul>
<li>认证处理流程说明</li>
<li>认证结果如何在多个请求间共享</li>
<li>获取认证用户信息</li>
</ul>
<h2 id="认证处理流程说明"><a href="#认证处理流程说明" class="headerlink" title="认证处理流程说明"></a>认证处理流程说明</h2><p><img src="http://ogiythg18.bkt.clouddn.com/Spring%20Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<pre><code>public class UsernamePasswordAuthenticationFilter extends
        AbstractAuthenticationProcessingFilter {

        public Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException {
        if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) {
            throw new AuthenticationServiceException(
                    &quot;Authentication method not supported: &quot; + request.getMethod());
        }

        String username = obtainUsername(request);
        String password = obtainPassword(request);

        if (username == null) {
            username = &quot;&quot;;
        }

        if (password == null) {
            password = &quot;&quot;;
        }

        username = username.trim();

        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
                username, password);

        // Allow subclasses to set the &quot;details&quot; property
        setDetails(request, authRequest);

        return this.getAuthenticationManager().authenticate(authRequest);
    }
}</code></pre><p>表单登录通过UsernamePasswordAuthenticationFilter处理认证逻辑，可以这里拿到用户名和密码，并以此创建了一个UsernamePasswordAuthenticationToken对象</p>
<pre><code>public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
        super(null);
        this.principal = principal;
        this.credentials = credentials;
        setAuthenticated(false);
    }</code></pre><p>UsernamePasswordAuthenticationToken其实就是Authentication的实现类，用来表示用户的认证信息。这里先调用了父类的构造，但是传了一个null进去，我们看一下它的父类构造：</p>
<pre><code>//父类构造的入参是权限集合
public AbstractAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities)</code></pre><p>显然这里还并为进行认证和授权所以传了一个空值进去，再看下面setAuthenticated(false);也是赋值说明当前是未认证的。所以这里只是初始化了一个Authenticatyion对象，并将请求中的一些信息放了进去。</p>
<pre><code>setDetails(request, authRequest); //这里也是设置了一些请求信息到Authentication对象</code></pre><p>看最后一句：</p>
<pre><code>this.getAuthenticationManager().authenticate(authRequest);</code></pre><p>这里先是取到了AuthenticationManager对象，该对象维护了许多的AuthenticationProvider，这些AuthenticationProvider分别用来认证不同类型的请求，比如表单认证，第三方认证等等。</p>
<p>我们来看一下AuthenticationManager的authenticate方法：</p>
<pre><code>public Authentication authenticate(Authentication authentication)
            throws AuthenticationException {
        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();
        AuthenticationException lastException = null;
        Authentication result = null;
        boolean debug = logger.isDebugEnabled();

        for (AuthenticationProvider provider : getProviders()) {
            if (!provider.supports(toTest)) {
                continue;
            }

            result = provider.authenticate(authentication);

                if (result != null) {
                    copyDetails(authentication, result);
                    break;
                }

            try {

            }

        }

        ...
    }</code></pre><p>可以看出这里遍历了所有的AuthenticationProvider，并找到对应的provider进行了认证：</p>
<pre><code>result = provider.authenticate(authentication);</code></pre><p>看一下provider的authentication方法,这里我会只保留重要的几行代码：</p>
<pre><code>public Authentication authenticate(Authentication authentication)
        throws AuthenticationException {


    // Determine username
    String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;
            : authentication.getName();

    boolean cacheWasUsed = true;
    UserDetails user = this.userCache.getUserFromCache(username);

    user = retrieveUser(username,
                    (UsernamePasswordAuthenticationToken) authentication);
    try {
        preAuthenticationChecks.check(user);
        additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
    }


    postAuthenticationChecks.check(user);


    return createSuccessAuthentication(principalToReturn, authentication, user);
}</code></pre><p>这里的retrieveUser方法根据用户名和包含了登录信息的Authentication对象处理得到了UserDetail对象：</p>
<pre><code>protected final UserDetails retrieveUser(String username,
        UsernamePasswordAuthenticationToken authentication)
        throws AuthenticationException {
    UserDetails loadedUser;

    try {
        loadedUser = this.getUserDetailsService().loadUserByUsername(username);
    }

    return loadedUser;
}</code></pre><p>这里就调用了loadUserByUsername方法，该方法大家应该比较熟悉了，我们实现UserDetailsService接口并在该方法中认证并返回用户信息。</p>
<p>经过retrieveUser方法返回的信息是进行了认证的用户信息，至于有没人认证通过就要看下面的三个方法的校验了</p>
<pre><code>preAuthenticationChecks.check(user);
additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
postAuthenticationChecks.check(user);</code></pre><p>前置校验校验了用户是否冻结、是否删除、帐号是否过期<br>额外的校验校验了用户名密码；<br>后置校验检查密码是否过期；</p>
<p>然后返回了一个认证过的Authentication信息。</p>
<p>接下来调用了AbstractAuthenticationProcessingFilter.successfulAuthentication,这里大家也比较熟悉了，我们复写了改方法，用来处理登录成功后的逻辑。</p>
<h2 id="认证结果如何在多个请求间共享"><a href="#认证结果如何在多个请求间共享" class="headerlink" title="认证结果如何在多个请求间共享"></a>认证结果如何在多个请求间共享</h2><p>在多个请求中共享我们首先想到的是放到了Session中，那么Spring Security是什么时候把什么东西放到了Session中呢？什么时候又从Sesion中读出来的？</p>
<pre><code>protected void successfulAuthentication(HttpServletRequest request,
        HttpServletResponse response, FilterChain chain, Authentication authResult)
        throws IOException, ServletException {


    SecurityContextHolder.getContext().setAuthentication(authResult);

    rememberMeServices.loginSuccess(request, response, authResult);

    // Fire event
    if (this.eventPublisher != null) {
        eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(
                authResult, this.getClass()));
    }

    successHandler.onAuthenticationSuccess(request, response, authResult);
}</code></pre><p>这里可以看出Spring Security在认证成功且调用我们自定义的认证成功处理组件之前执行了下面的代码：</p>
<pre><code>SecurityContextHolder.getContext().setAuthentication(authResult);</code></pre><p>显然是将认证成的额那个Authentication对象放到了SecurityContext中，SecutityContext非常简单，就是包装了一个Authentication对象，并重写了equalts和hashCode方法。</p>
<p>同时Spring Security用SecurityContextHolder（用ThreadLocal的封装的）保存了SecurityContext。</p>
<p>那问题来了，这里只是把认证过的Authentication对象放到了SecurityContextHolder中，最多也就只能做到认证结果的单请求同线程共享，如果要多请求共享还是要放到session中，而且每个请求过来的时候都要从session中取一次，这么分析下来感觉用一个Filter处理上述的操作很合适。没错，Spring Security提供了这样一个过滤器，而且是其过滤器链上的第一个过滤器：SecurityContextPersistenceFilter。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/Spring%20Security%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image"></p>
<p>该过滤器的作用就是当请求过来的时候，检查session中有没有SecurityContext，有的话放到SecurityContextHolder中，这样当前线程在任何地方都可以获取到SecurityContext信息；当请求返回的时候，会检查SecurityContextHolder中是否有SecurityContext信息，有的话就将其放到session中，这样就实现了认证信息在多个请求间的共享。</p>
<h2 id="获取认证用户信息"><a href="#获取认证用户信息" class="headerlink" title="获取认证用户信息"></a>获取认证用户信息</h2><p>通过前面的分析，获取认证用户信息对我们来说已经不是事了，相信你也已经理解了。</p>
<pre><code>@GetMapping(&quot;/me&quot;)
public Object getCurrentUser(Authentication authentication) {
    //return SecurityContextHolder.getContext().getAuthentication();
    return authentication;
}

@GetMapping(&quot;/meToo&quot;)
public Object getCurrentUserToo(@AuthenticationPrincipal UserDetails userDetails) {
    return userDetails;
}</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（4）－个性化用户认证流程（二）</title>
    <url>/2019/06/04/Spring%20Security%EF%BC%884%EF%BC%89%EF%BC%8D%E4%B8%AA%E6%80%A7%E5%8C%96%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>概要：</p>
<ul>
<li>自定义登录页面</li>
<li>自定义登录成功处理</li>
<li>自定义登录失败处理</li>
</ul>
<p>上一篇我们讲了自定义登录页面，本篇我们来看一下自定义登录成功和失败的处理。</p>
<h2 id="自定义登录成功处理"><a href="#自定义登录成功处理" class="headerlink" title="自定义登录成功处理"></a>自定义登录成功处理</h2><p>默认情况下Spring Security登录成功后会跳到之前引发登录的请求。但是目前前端很多情况下是SPA模式的，登录本身可能不是一个表单提交的同步方式，而是一个ajax请求，我们希望返回的是json格式的登录用户信息而不是跳转。</p>
<p>那么我们就需要自定义成功处理逻辑，在Spring security中我们只需要实现AuthenticationSuccessHandler接口就可以了。该接口只有一个方法：</p>
<pre><code>onAuthenticationSuccess(HttpServletRequest request,
                        HttpServletResponse response,
                        Authentication authentication)</code></pre><p>其中参数Authentication也是Spring security的一个核心接口，用来封装我们的认证信息，包括发起的认证请求里的一些信息，比如请求ip、session以及认证通过后认证通过后userDetail中的用户信息也是包装在Authentication中的。</p>
<pre><code>@Component(&quot;evolutionaryAuthenticationHandler&quot;)
public class EvolutionaryAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {

    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * spring MVC 启动的时候会为我们注册一个objectMapper
     */
    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 登录成功会调用该方法
     * @param request
     * @param response
     * @param authentication
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        logger.info(&quot;登录成功！&quot;);
        if (LoginInType.JSON.equals(securityProperties.getBrower().getLoginInType())) {
            response.setContentType(&quot;application/json;charset=UTF-8&quot;);
            response.getWriter().write(objectMapper.writeValueAsString(authentication));
        }else{
            super.onAuthenticationSuccess(request, response, authentication);
        }

    }
}</code></pre><p>然后我们需要配置一下，登录成功的处理方式。</p>
<pre><code>@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    @Autowired
    private EvolutionaryAuthenticationSuccessHandler evolutionaryAuthenticationHandler;

    @Autowired
    private EvolutionaryAuthenticationFailureHandler evolutionaryAuthenticationFailureHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()  //表单登录
                .loginPage(&quot;/authentication/require&quot;) //如果需要身份认证则跳转到这里
                .loginProcessingUrl(&quot;/authentication/form&quot;)
                .successHandler(evolutionaryAuthenticationHandler)
                .failureHandler(evolutionaryAuthenticationFailureHandler)
                .and()
                .authorizeRequests()
                .antMatchers(&quot;/authentication/require&quot;, securityProperties.getBrower().getLoginPage())
                .permitAll()
                .anyRequest()
                .authenticated()
                .and().csrf().disable();

    }
}</code></pre><h2 id="自定义登录失败处理"><a href="#自定义登录失败处理" class="headerlink" title="自定义登录失败处理"></a>自定义登录失败处理</h2><p>登录失败后的处理逻辑是一样的，实现AuthenticationFailureHandler接口进行相应的处理。</p>
<pre><code>@Component
public class EvolutionaryAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

    private Logger logger = LoggerFactory.getLogger(getClass());
    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public void onAuthenticationFailure(HttpServletRequest request,
                                        HttpServletResponse response,
                                        AuthenticationException exception) throws IOException, ServletException {
        logger.info(&quot;登录失败！&quot;);
        if (LoginInType.JSON.equals(securityProperties.getBrower().getLoginInType())) {
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            response.setContentType(&quot;application/json;charset=UTF-8&quot;);
            response.getWriter().write(objectMapper.writeValueAsString(exception));
        } else {
            super.onAuthenticationFailure(request, response, exception);
        }

    }
}</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（3）－个性化用户认证流程（一）</title>
    <url>/2019/06/03/Spring%20Security%EF%BC%883%EF%BC%89%EF%BC%8D%E4%B8%AA%E6%80%A7%E5%8C%96%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>概要：</p>
<ul>
<li>自定义登录页面</li>
<li>登录成功处理</li>
<li>登录失败处理</li>
</ul>
<h2 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h2><pre><code>@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //        http.httpBasic();  http Basic的认证方式
        http.formLogin()  //表单登录
                .loginPage(&quot;/evolutionary-loginIn.html&quot;) //指定登录页面所在的url
                .loginProcessingUrl(&quot;/authentication/form&quot;) //登录请求的url
                .and()
                .authorizeRequests()
                .antMatchers(&quot;/evolutionary-loginIn.html&quot;, securityProperties.getBrower().getLoginPage())
                .permitAll()
                .anyRequest()
                .authenticated()
                .and().csrf().disable();

    }
}</code></pre><p>evolutionary-loginIn.html页面：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;标准登录页面&lt;/h2&gt;
&lt;h3&gt;表单登录&lt;/h3&gt;
&lt;form action=&quot;/authentication/form&quot; method=&quot;post&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;用户名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;密码：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;
                &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="优化处理"><a href="#优化处理" class="headerlink" title="优化处理"></a>优化处理</h3><ul>
<li><p>目前我们的请求如果没有权限会直接跳转登录页面，但是我们希望如果是restFul请求返回的是json数据，如果是html结尾的请求可以跳转到登录页。</p>
</li>
<li><p>让开发者自定义用户登录页面，如果没有找到用户自定义的页面再用我们提供的登录页面。</p>
</li>
</ul>
<p><img src="http://ogiythg18.bkt.clouddn.com/%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="image"></p>
<p>之前当需要认证时，Spring Security会根据我们的配置跳转到登录页面：</p>
<pre><code>http.formLogin()
    .loginPage(&quot;/evolutionary-loginIn.html&quot;)//跳转到登录页面</code></pre><p>现在我们要自定义一个Controller，并修改配置当需要认证的时候跳转到该Controller上。</p>
<p>修改配置：</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin()  //表单登录
            //.loginPage(&quot;/evolutionary-loginIn.html&quot;)
            .loginPage(&quot;/authentication/require&quot;) //如果需要身份认证则跳转到这里
            .and()
            .authorizeRequests()
            .antMatchers(&quot;/authentication/require&quot;,securityProperties.getBrower().getLoginPage())//不校验我们配置的登录页面
            .permitAll()
            .anyRequest()
            .authenticated()
            .and().csrf().disable();

}</code></pre><p>提供自定义Controller：</p>
<pre><code>@RestController
public class BrowerSecurityController {

    private Logger logger = LoggerFactory.getLogger(getClass());

    private RequestCache requestCache = new HttpSessionRequestCache();

    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Autowired
    private SecurityProperties securityProperties;

    @RequestMapping(&quot;/authentication/require&quot;)
    @ResponseStatus(code = HttpStatus.UNAUTHORIZED)
    public SimpleResult requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException {
        SavedRequest savedRequest = requestCache.getRequest(request, response);
        if (savedRequest != null) {
            String targetUrl =  savedRequest.getRedirectUrl();
            logger.info(&quot;引发跳转的请求是：&quot; + targetUrl);
            if (StringUtils.endsWithIgnoreCase(targetUrl, &quot;.html&quot;)) {
                redirectStrategy.sendRedirect(request, response, securityProperties.getBrower().getLoginPage());
            }
        }
        return new SimpleResult(&quot;访问的服务需要登录页面，请引导用户到登录页&quot;);
    }

}</code></pre><p>做完上面的操作，我们就可以针对不同的请求类型作出不同的响应了。你可能注意了，上面我们用了securityProperties.getBrower().getLoginPage()。这就是我们为方便配置不同的登录页面提供的配置类。</p>
<pre><code>@Configuration
@EnableConfigurationProperties(SecurityProperties.class)
public class SecurityCoreConfig {


}

@ConfigurationProperties(prefix = &quot;evolutionary.security&quot;)
public class SecurityProperties {

    private BrowerProperties brower = new BrowerProperties();

    public BrowerProperties getBrower() {
        return brower;
    }

    public void setBrower(BrowerProperties brower) {
        this.brower = brower;
    }
}


public class BrowerProperties {

    private String loginPage = &quot;/evolutionary-loginIn.html&quot;;//默认跳转

    private LoginInType loginInType = LoginInType.JSON;

    public String getLoginPage() {
        return loginPage;
    }

    public void setLoginPage(String loginPage) {
        this.loginPage = loginPage;
    }

    public LoginInType getLoginInType() {
        return loginInType;
    }

    public void setLoginInType(LoginInType loginInType) {
        this.loginInType = loginInType;
    }
}


evolutionary.security.brower.loginPage = /demo-signIn.html
evolutionary.security.brower.loginInType=REDIRECT</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（11）-有意思的Mysql问题</title>
    <url>/2019/06/03/Mysql%EF%BC%8811%EF%BC%89-%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84Mysql%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>当备库用–single-transaciton做逻辑备份的时候,如果主库的binlog传来一个DDL语句会怎样？</li>
</ol>
<p>备份操作是一个过程，DDL从主库传过来时，备份过程可能处于不同的阶段，所以DDL对备份的影响也不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">&#x2F;* other tables *&#x2F;</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">&#x2F;* 时刻 1 *&#x2F;</span><br><span class="line">Q4:show create table &#96;t1&#96;;</span><br><span class="line">&#x2F;* 时刻 2 *&#x2F;</span><br><span class="line">Q5:SELECT * FROM &#96;t1&#96;;</span><br><span class="line">&#x2F;* 时刻 3 *&#x2F;</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">&#x2F;* 时刻 4 *&#x2F;</span><br><span class="line">&#x2F;* other tables *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);</p>
<p>启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；</p>
<p>设置一个保存点，这个很重要（Q3）；</p>
<p>show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。</p>
<p>答案如下：</p>
<ul>
<li><p>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</p>
</li>
<li><p>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</p>
</li>
<li><p>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</p>
</li>
<li><p>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</p>
</li>
</ul>
<p>总结就是在拿到表结构之前到达，没影响；在拿到表结构之后，备份数据之前到，会报错；在备份后到达，主从延迟</p>
<ol start="2">
<li>Mysql选错索引的一个案例分析<br>//todo 待分析</li>
</ol>
<p>在生产上遇见了一个非常经典的Mysql选错索引的问题，简述如下：有一张日志表，id是自增主键，假设还有一个字段是code，code字段也有索引；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;log_test&#96;(</span><br><span class="line">  &#96;id&#96; INT  AUTO_INCREMENT,</span><br><span class="line">  &#96;key&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  index idx_key(&#96;key&#96;)</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line">create procedure idata()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i&#x3D;1;</span><br><span class="line">  while(i&lt;&#x3D;100000)do</span><br><span class="line">    insert into log_test values(i, i);</span><br><span class="line">    set i&#x3D;i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（2）－自定义用户认证逻辑</title>
    <url>/2019/06/02/Spring%20Security%EF%BC%882%EF%BC%89%EF%BC%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>在上一篇基本原理中，我们引入了Spring security依赖包，并定义了认证方式为表单认证。但是认证的用户名和密码都用的是默认的，本文我们将继续讲用户自定义认证逻辑，主要包括下面几点：</p>
<ul>
<li>处理用户信息获取逻辑（比如从数据库读取用户信息）</li>
<li>处理用户校验逻辑（获取用户信息后如何验证）</li>
<li>处理密码加解密</li>
</ul>
<h2 id="处理用户信息获取逻辑"><a href="#处理用户信息获取逻辑" class="headerlink" title="处理用户信息获取逻辑"></a>处理用户信息获取逻辑</h2><p>UserDetailsService就是用来处理用户信息获取逻辑的接口，我们通过实现该接口在loadUserByUsername方法的实现中获取用户信息，并将其传递给Spring Security。如下我们假设密码“123456”就是我们从数据库获取到的信息。</p>
<pre><code>@Component
public class MyUserDetailService implements UserDetailsService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        logger.info(&quot;登录用户名：&quot; + username);

        return new User(username, &quot;123456&quot;, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;));

    }
}</code></pre><p>现在就可以用任意用户名和密码：“123456”登录系统了。</p>
<h2 id="处理用户校验逻辑"><a href="#处理用户校验逻辑" class="headerlink" title="处理用户校验逻辑"></a>处理用户校验逻辑</h2><p>获取到用户信息后，就需要进行信息校验，用户校验逻辑的处理可大致分为两部分，一部分是密码是否匹配，另一部分就是其它信息的校验。从Spring Security的校验返回结果UserDetail中我们可以看到都有哪些信息是可以校验的。</p>
<pre><code>public interface UserDetails extends Serializable {


    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}</code></pre><p>UserDetail是Spring提供的用户信息的接口，我们可以自定义用户类并实现该接口，或者使用Spring Security提供的User类（已经实现了UserDetail接口）。</p>
<p>可以看到该接口需要提供权限、用户名、密码、帐号是否过期、帐号是否被锁定、密码是否过期、帐号是否被删除。这些信息都需要我们根据业务逻辑自己提供，并通过标准的接口UserDetail提供给Spring Security就可以了。</p>
<pre><code>@Component
public class MyUserDetailService implements UserDetailsService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        logger.info(&quot;登录用户名：&quot; + username);
        String password = &quot;123456&quot;
        logger.info(&quot;数据库密码是:&quot; + password);
        return new User(username,
                password ,
                true,
                true,
                true,
                true,
                AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admi)
        );
    }
}</code></pre><h2 id="处理密码加解密"><a href="#处理密码加解密" class="headerlink" title="处理密码加解密"></a>处理密码加解密</h2><p>通常我们的密码是不会以明文的方式存到数据库里的，Spring Security提供了org.springframework.security.crypto.password.PasswordEncoder接口来处理密码的加密和匹配操作。</p>
<pre><code>public interface PasswordEncoder {
    //加密
    String encode(CharSequence rawPassword);
    //匹配
    boolean matches(CharSequence rawPassword, String encodedPassword);
}</code></pre><p>我们可以自己实现passwordEncoder来提供我们自己的加解密算法。这里我们配置一个Spring Security提供的passwordEncoder实现类。</p>
<pre><code>@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }


}</code></pre><p>配置了passwordEncoder后我们再登录spring Securiyt就会加密我们的登录密码跟（从数据库）获取到的密码进行校验。</p>
<pre><code>@Component
public class MyUserDetailService implements UserDetailsService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        logger.info(&quot;登录用户名：&quot; + username);
        //这里模拟数据库读出来的密码
        String password = passwordEncoder.encode(&quot;123456&quot;);
        logger.info(&quot;数据库密码是:&quot; + password);
        return new User(username,
                password ,
                true,
                true,
                true,
                true,
                AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)
        );
    }
}</code></pre><p>值得注意的一点是通过passwordEncoder加密生成的密码每次都是不一样的，因为在生成的时候它会随机生成盐并混到要加密的串里去。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security（１）－基本原理</title>
    <url>/2019/06/01/Spring%20Security%EF%BC%88%EF%BC%91%EF%BC%89%EF%BC%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>引入Spring-security包</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;top.evolutionary.security&lt;/groupId&gt;
    &lt;artifactId&gt;evolutionary-security-core&lt;/artifactId&gt;
    &lt;version&gt;${evolutionary.security.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>在Spring-boot中如果classPath下有spring security的jar包，那么Spring boot 会自动的做一些默认的配置，默认是开启的，我们可以修改配置文件来关掉。</p>
<pre><code>#security.basic.enabled=false</code></pre><p>引入Spring security包后，如果我们什么也不做，这时通过浏览器访问服务时，会弹出http Basic的认证框让我们进行身份验证。用户名是默认的”user”,密码会在Spring boot服务启动的时候在控制台打印出来”Using default security password:…..“。所以当我们什么也不做的时候Spring security会把所有的后台服务都保护起来。</p>
<h3 id="覆盖Spring-security默认认证方式"><a href="#覆盖Spring-security默认认证方式" class="headerlink" title="覆盖Spring security默认认证方式"></a>覆盖Spring security默认认证方式</h3><pre><code>/**
 * @author richey
 */

@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {


    @Override
    protected void configure(HttpSecurity http) throws Exception {

        //http.httpBasic();  http Basic的认证方式
        //使用表单认证，所有请求都需要身份认证后才能访问
        http.formLogin()
                .and()
                .authorizeRequests()
                .anyRequest()
                .authenticated();

    }
}</code></pre><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="http://ogiythg18.bkt.clouddn.com/Spring%20Security%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image"></p>
<ul>
<li>Spring security最核心的就是过滤器链，其实就是一组过滤器，所有服务的请求都会经过这些过滤器，同样返回也会从这些过滤器中过。Spring security提供的所有的功能都是建立在过滤器链上的。</li>
<li>Spring boot会在服务启动的时候把这些过滤器都配置进去。</li>
<li>最核心的是用来认证用户身份的那些过滤器（图中绿色块表示），每个过滤器负责处理一种认证方式。这些过滤器检查当前的请求中是否有当前过滤器所需要的信息，如果有则会拿这些信息进行验证登录，如果没有则交给下一个过滤器认证。只要其中任何一个过滤器成功完成了用户登录后，则会在当前请求上做一个标记，表示认证成功。注意，该类型的过滤器是可以在程序中配置是否生效的。</li>
<li>请求最终会到FilterSecurityInterceptor过滤器（图中橙色块），该过滤器决定了请求最终是否有权限访问。依据的就是代码中的配置，如果没有权限则会根据原因抛出不同的异常。</li>
<li>在FilterSecurityInterceptor过滤器前面会有一个ExceptionTranslactionFilter（图中蓝色块）,这个过滤器就是用来处理当请求没有通过FilterSecurityInterceptor过滤器时抛出的异常，它会根据抛出来的异常以及程序中的配置来进行相应的处理。比如这里抛出的是未登录的异常，而我们在程序中配置的登录方式是表单登录，则这里就会引导用户去登录。</li>
</ul>
<p>Spring security的基本原理就是这样的，很好理解，我们可以在上面提到的这几个Filter里面分别打上断点，发一个请求看一下，每一步是不是按照我们说的走的，这里就不演示了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（10）-Mysql备份</title>
    <url>/2019/05/29/Mysql%EF%BC%8810%EF%BC%89-Mysql%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="确定数据库大小"><a href="#确定数据库大小" class="headerlink" title="确定数据库大小"></a>确定数据库大小</h1><pre><code>SELECT
    ROUND(SUM(data_length + index_length) / 1024 / 1024) AS total_mb,
    ROUND(SUM(data_length) / 1024 / 1024) AS data_mb,
    ROUND(SUM(index_length) / 1024 / 1024) AS index_mb
FROM
    INFORMATION_SCHEMA.tables;</code></pre><p>执行mysqldump所得的备份文件的大小与数据库大小相同，但是为了安全起见，保存备份的磁盘空间要有10%到15%的冗余。</p>
<p>确认mysql实例所使用的存储引擎，及表信息：</p>
<pre><code>SELECT table_schema,engine,COUNT(*) AS tables from  information_schema.TABLES
WHERE table_schema NOT IN(&apos;INFORMATION_SCHEMA&apos;,&apos;PERFORMANCE_SCHEMA&apos;)
GROUP BY table_schema,engine
ORDER BY 3 DESC;</code></pre><p>组合查询</p>
<pre><code>SELECT
    table_schema,
    engine,
    ROUND(SUM(data_length + index_length) / 1024 / 1024) AS total_mb,
    ROUND(SUM(data_length) / 1024 / 1024) AS data_mb,
    ROUND(SUM(index_length) / 1024 / 1024) AS index_mb,
    COUNT(*) AS tables
FROM
    INFORMATION_SCHEMA.tables
GROUP BY
    table_schema,
    engine
ORDER BY
    3 DESC;</code></pre><h1 id="SQL导出备份"><a href="#SQL导出备份" class="headerlink" title="SQL导出备份"></a>SQL导出备份</h1><h2 id="最简单的备份方式："><a href="#最简单的备份方式：" class="headerlink" title="最简单的备份方式："></a>最简单的备份方式：</h2><pre><code>$time mysqldump -uroot -p --all-databases &gt; backup.sql
$echo $0
$ls -lh backup.sql</code></pre><p>第一句，对所有的库进行备份；<br>第二句，确认第一个命令执行结束，若是非0结果，说明备份过程发生了问题。如果有错误发生，就会显示在屏幕中；<br>第三句，显示备份文件的大小；</p>
<h2 id="将备份数据转移到安全位置"><a href="#将备份数据转移到安全位置" class="headerlink" title="将备份数据转移到安全位置"></a>将备份数据转移到安全位置</h2><pre><code>$ time gzip backup.sql
$ time scp backup.sql.gz another-server:backup-dir</code></pre><h2 id="备份选项"><a href="#备份选项" class="headerlink" title="备份选项"></a>备份选项</h2><p>所选择的锁策略，决定了在执行备份期间应用程序是否可以对数据库进行写操作。</p>
<pre><code>--lock-tables</code></pre><p>锁表，默认是关闭的，当备份MyISAM引擎时，–lock-tables对于数据一致性是非常必要的。但是一次也只能锁一个模式的表，<br>换言之，在备份过程中操作数据库，还是可能会产生不一致的数据。</p>
<pre><code>--lock-all-tables</code></pre><p>锁所有的表</p>
<pre><code>--single-transaction</code></pre><p>为一个事务中的所有表，创建一个版本一致的快照。仅能用在InnoDB或者MVCC的引擎中。使用这一选项时，将自动关闭–lock-tables。</p>
<pre><code>--routines</code></pre><p>如果数据库中包含存储过程或函数，则–routine是必须的</p>
<pre><code>--master-data</code></pre><p>时间点恢复</p>
<pre><code>--all-databases
--databases  指定特定数据库
--tables  指定特定表
--ignore-table  排除表</code></pre><p>指定导出相关的信息</p>
<pre><code>--skip-quote-names</code></pre><p>去掉导出文件对象名两端的单引号（`）</p>
<pre><code>--hex-blob</code></pre><p>当数据库包含二进制文件时，–hex-blob将提供最大的兼容性</p>
<pre><code>--no-data</code></pre><p>不导出数据，只导表结构</p>
<pre><code>--no-create-info</code></pre><p>记录binlog日志，加了下面的配置恢复的数据会进binlog日志<br>    –set-gtid-purged=off</p>
<p>不导建表语句，配置–routines 只导出函数和存储过程</p>
<pre><code>mysqldump -h localhost -uroot -p --no-data --all-databases &gt; backup-schema.sql

mysqldump -h localhost -uroot -p --no-data --no-create-info --routines --all-databases &gt; backup-routines.sql</code></pre><h1 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h1><p>需要关闭MYSQL实例，对文件系统上的文件进行物理复制。</p>
<p>MYSQL配置变量定义了各种文件的位置，要仔细检查这些文件的位置，并将其包含在要备份的文件列表中。my.cnf中并不会包含所有的变量，mysql对未定义的变量使用预先设定的默认值。所以最好在myslq实例运行时，获取这些变量的值。</p>
<ul>
<li>datadir MYSQL数据目录</li>
<li>innodb_data_home_dir InnoDB Data数据目录</li>
<li>innodb_data_file_path 单独的InnoDB数据文件，它可能包含特定的不同目录</li>
<li>log-bin 二进制文件目录</li>
<li>log-bin-index 二进制日志索引文件</li>
<li>relay-log 中继日志文件</li>
<li>relay-log-index 中继日志索引文件</li>
<li>mysql的配置文件my.conf</li>
</ul>
<h1 id="表抽取"><a href="#表抽取" class="headerlink" title="表抽取"></a>表抽取</h1><pre><code>mysqldump -h localhost -uroot -p --no-create-info --tab=. --fields-terminated-by=, --fields-optionally-enclosed-by=\&quot; book-management tb_books;</code></pre><p>或</p>
<pre><code>select * from tb_books into outfile &apos;/tmp/books.cvs&apos;  fields terminated by &apos;,&apos; optionally enclosed by &apos;&quot;&apos;;</code></pre><h1 id="文件系统快照"><a href="#文件系统快照" class="headerlink" title="文件系统快照"></a>文件系统快照</h1><h1 id="备份的时间节点"><a href="#备份的时间节点" class="headerlink" title="备份的时间节点"></a>备份的时间节点</h1>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC请求处理流程</title>
    <url>/2019/05/25/Spring%20MVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spring请求处理流程图："><a href="#Spring请求处理流程图：" class="headerlink" title="Spring请求处理流程图："></a>Spring请求处理流程图：</h1><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/SpringMvc%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="Spring请求处理流程"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC</title>
    <url>/2019/05/20/Spring%20MVC/</url>
    <content><![CDATA[<h1 id="一、Spring-MVC-Quick-Start"><a href="#一、Spring-MVC-Quick-Start" class="headerlink" title="一、Spring MVC Quick Start"></a>一、Spring MVC Quick Start</h1><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><h3 id="Spring-MVC最简单的配置"><a href="#Spring-MVC最简单的配置" class="headerlink" title="Spring MVC最简单的配置"></a>Spring MVC最简单的配置</h3><ol>
<li><p>在web.xml中配置Servlet</p>
<p> Spring MVC的本质就是一个Servlet</p>
<pre><code>&lt;!-- spring mvc 配置开始 --&gt;
&lt;!-- Spring MVC本质上就是一个Servlet --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--  contextConfigLocation参数来指定Spring MVC配置文件的位置，默认为WEB-INF/[Servlet-Name]-servlet.xml文件  --&gt;
    &lt;!--  &lt;init-param&gt;
          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
          &lt;param-value&gt;&lt;/param-value&gt;
      &lt;/init-param&gt;--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;!-- spring mvc 配置结束 --&gt;</code></pre></li>
<li><p>创建Spring MVC的xml配置文件</p>
 <!--
         mvc:annotation-driven是 Spring MVC提供的一键式配置方法
         配置此标签后Spring MVC会帮我们自动做一些注册组件之类的事情
     -->
<pre><code>&lt;mvc:annotation-driven/&gt;
&lt;!--扫描通过注解配置的类--&gt;
&lt;context:component-scan base-package=&quot;top.richpeople&quot;&gt;
    &lt;!--如果使用了spring,可以用context:include-filter设置只扫描@Controller别的交给Spring容器去管理--&gt;
    &lt;!--&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt;
&lt;/context:component-scan&gt;</code></pre></li>
<li><p>创建Controller和view</p>
<pre><code>/**
 * 处理HEAD类型的&quot;/&quot;请求
 * 此方法可以用来检测服务器的状态,因为它不返回body,所以笔GET请求更节省网络资源
 * @return
 */
@RequestMapping(value = &quot;/&quot;, method = RequestMethod.HEAD)
public String head() {
    return &quot;go.jsp&quot;;
}

/**
 * 处理GET类型的&quot;/index&quot;和&quot;/&quot;请求
 */
@RequestMapping(value = {&quot;/index&quot;, &quot;/&quot;}, method = RequestMethod.GET)
public String testMapPathUri(Model model) {

    model.addAttribute(&quot;msg&quot;, &quot;Go Go Go!&quot;);
    return &quot;go.jsp&quot;;
}</code></pre><p> 如果没有配置ViewResolver，Spring MVC将默认使用org.springframework.web.servlet.view.InternalResourcViewResolver作为ViewResolver，而且prefix和suffix都为空</p>
</li>
</ol>
<h1 id="二、Spring-MVC-架构分析"><a href="#二、Spring-MVC-架构分析" class="headerlink" title="二、Spring MVC 架构分析"></a>二、Spring MVC 架构分析</h1><p><img src="http://ogiythg18.bkt.clouddn.com/DispatcherServlet.png" alt="DispatcherServlet"></p>
<p>XXXAware在Spring中表示对XXX可感知，通俗点讲就是：如果在某个类里想用Spring的某个东西，就实现相应的XXXAware接口，Spring看到后就会给你送过来。</p>
<h3 id="Spring中3个类的具体创建过程"><a href="#Spring中3个类的具体创建过程" class="headerlink" title="Spring中3个类的具体创建过程"></a>Spring中3个类的具体创建过程</h3><p>//TODO  这里要撸源码进行分析</p>
<ul>
<li><p>HttpServletBean</p>
<p>  没有参与实际请求的处理</p>
</li>
<li><p>FrameworkServlet</p>
<p>  将不同的请求合并到了processRequest方法统一处理，processRequest方法中做了三件事：</p>
<ul>
<li>调用了doService模板方法具体处理请求</li>
<li>将当请求的LocaleContext和ServletRequestAttributes在处理请求前设置到了LocaleContextHolder和RequestContextHolder,并在请求处理完后恢复。</li>
<li>请求完后发布了ServletRequestHandledEvent消息</li>
</ul>
</li>
<li><p>DispatcherServlet</p>
<p>  doService方法给request设置了一些属性并将请求交给doDispatch方法具体处理</p>
</li>
</ul>
<h1 id="三、Spring-MVC组件分析"><a href="#三、Spring-MVC组件分析" class="headerlink" title="三、Spring MVC组件分析"></a>三、Spring MVC组件分析</h1><p>这里的组件指的是DispatcherServlet中直接初始化的那九个组件，不同的组件内部可能还会用到一些子组件。</p>
<h3 id="1、-HandlerMapping"><a href="#1、-HandlerMapping" class="headerlink" title="1、 HandlerMapping"></a>1、 HandlerMapping</h3><p>它的作用是根据request找到相应的处理器Handler和Interceptors，该接口只有一个方法：</p>
<pre><code>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</code></pre><p>HandlerMapping编写出来后要注册到Spring MVC的容器里面才可以使用，注册和那简单，只需要在配置文件里配置一个Bean就可以了（或者使用注解）。</p>
<p>如果有多个HandlerMapping匹配到了同一个处理器Hander，这时就要设置HandlerMapping的顺序。HandlerMapping的顺序通过实现Order接口设置order属性来定义。</p>
<p>查找Handler是按顺序遍历所有的HandlerMapping，当找到一个HandlerMapping后立即停止并返回。</p>
<h3 id="2、HandlerAdapter"><a href="#2、HandlerAdapter" class="headerlink" title="2、HandlerAdapter"></a>2、HandlerAdapter</h3><p>可以理解为使用处理器Handler干活的人</p>
<p>为什么使用handlerAdapter?</p>
<pre><code>Spring MVC没有对处理器Handler做任何的限制，处理器可以是任何合理的方式，可以是类、方法或者别的合理的方式，所以我们要用不用的Adapter去使用这些Handler</code></pre><p>我们自定义Adapter只需要实现HandlerAdapter，完成相应的逻辑就可以了，同样可以实现Order接口，默认使用第一个按顺序找到的Adapter。HandlerAdapter同样需要注册到Spring MVC容器中，只需要配置一个Bean就可以了。</p>
<h3 id="3、HandlerExceptionResolver"><a href="#3、HandlerExceptionResolver" class="headerlink" title="3、HandlerExceptionResolver"></a>3、HandlerExceptionResolver</h3><p>此组件的作用是根据异常设置ModelAndView，之后再交给render方法去渲染。</p>
<h3 id="4、ViewResolver"><a href="#4、ViewResolver" class="headerlink" title="4、ViewResolver"></a>4、ViewResolver</h3><p>用来将String类型的视图名（有地方也叫逻辑视图，都是同一个东西）和Locale解析为View类型的视图。</p>
<p>一般情况下我们只需要根据视图名找到视图，然后进行渲染，并不需要对不同的区域使用不同的视图。</p>
<p>View是用来渲染页面的，通俗点将就是将程序返回的参数填入到模板里，生成html（或者是其它类型）的文件。这里有两个关键的问题：</p>
<ul>
<li>使用什么模板</li>
<li>用什么技术或规则填入参数</li>
</ul>
<p>这起是就是ViewResolver要做的工作。</p>
<pre><code>View resolveViewName(String viewName, Locale locale) throws Exception;</code></pre><ul>
<li><p>UrlBasedViewResolver系列解析器都是针对单一视图类型进行解析的</p>
<ul>
<li>InternalResourceViewResolver 只解析jsp类型的视图</li>
<li>FreeMarkerViewResolver只针对FreeMarker</li>
<li>VelocityViewResolver只针对Velocity</li>
</ul>
</li>
<li><p>ResourceBundleViewResolver、XmlViewResolver、BeanNameViewResolver等解析器可以同时解析多种类型的视图。</p>
</li>
</ul>
<p>ViewResolver的使用需要注册到Spring MVC容器里，默认使用的是org.springframework.web.servlet.view.InternalResourceViewResolver。</p>
<h3 id="5、RequestToViewNameTranslator"><a href="#5、RequestToViewNameTranslator" class="headerlink" title="5、RequestToViewNameTranslator"></a>5、RequestToViewNameTranslator</h3><p>ViewResolver是根据viewName查找View，但是有的Handler处理完后没有这只View也没有设置viewName，这时需要从request中获取viewName，而如何从request中获取viewName就是RequestToViewNameTranslator要做的事情。</p>
<pre><code>String getViewName(HttpServletRequest request) throws Exception;</code></pre><p>具体的处理逻辑需要我们自己实现，要注意的是RequestToViewNameTranslator在Spring MVC容器中只能配置一个，所有的request到viewName的转换都要在一个Rranslator中实现。</p>
<h3 id="6、LocaleResolver"><a href="#6、LocaleResolver" class="headerlink" title="6、LocaleResolver"></a>6、LocaleResolver</h3><p>视图的解析需要两个参数，一个是视图名，一个是Locale，视图名是从Handler返回的（或者是使用RequestToViewNameTranslator解析的默认视图名），而Locale是LocaleResolver从request中解析出来的。</p>
<pre><code>Locale resolveLocale(HttpServletRequest request);

void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale);</code></pre><p>org.springframework.web.servlet.i18n.LocaleChangeInterceptor拦截器为我么那提供了默认修改Locale的便捷方式。</p>
<h3 id="7、ThemeResolver"><a href="#7、ThemeResolver" class="headerlink" title="7、ThemeResolver"></a>7、ThemeResolver</h3><h3 id="8、MultipartResolver"><a href="#8、MultipartResolver" class="headerlink" title="8、MultipartResolver"></a>8、MultipartResolver</h3><p>MultipartResolver用于处理上传请求，处理方法就是将普通的request包装成HttpServletRequest，后者可以直接调用getFile方法获取到File，如果上传多个文件，还可以调用getFileMap得到fileName-File结构的Map。</p>
<p>其实如果上传请求不用MutipartResolver封装成HttpServletRequest，直接用原来的request也是可以的，所以Spring MVC中没有为此组件提供默认值。</p>
<h3 id="9、FlashMapManager"><a href="#9、FlashMapManager" class="headerlink" title="9、FlashMapManager"></a>9、FlashMapManager</h3>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(7)-Spring Boot 两种多数据源配置：JdbcTemplate、Spring-data-jpa</title>
    <url>/2019/05/18/Spring%20Boot(7)-Spring%20Boot%20%E4%B8%A4%E7%A7%8D%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%EF%BC%9AJdbcTemplate%E3%80%81Spring-data-jpa/</url>
    <content><![CDATA[<p>在单数据源的情况下，spring Boot的数据源配置非常简单，只要在applicatrion.properties中配置连接参数即可。但是随着业务的发展我们常常会对数据库拆分或者引入其它的数据库，从而需要配置多个数据源。下面我们就基于JdbcTemplate和Spring-data-jap介绍配置多数据源的方式。</p>
<h2 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h2><p>创建一个Spring配置类，定义两个DataSource用来读取application.properties中的不同配置。如下例子中，主数据源配置为spring.datasource.primary开头的配置，第二数据源配置为spring.datasource.secondary开头的配置。</p>
<pre><code>/**
 * 多数据源配置
 */
@Configuration
public class DataSourceConfig {

    @Bean(name = &quot;primaryDataSource&quot;)
    @Primary
    @ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = &quot;secondaryDataSource&quot;)
    @ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }


}</code></pre><p>对应application.properties中的配置如下：</p>
<pre><code># 多数据源配置
spring.datasource.primary.url=jdbc:mysql://localhost:3306/spring-boot-db1?useUnicode=true&amp;characterEncoding=utf8
spring.datasource.primary.username=root
spring.datasource.primary.password=root
spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver

spring.datasource.secondary.url=jdbc:mysql://localhost:3306/spring-boot-db2?useUnicode=true&amp;characterEncoding=utf8
spring.datasource.secondary.username=root
spring.datasource.secondary.password=root
spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver</code></pre><h2 id="JdbcTemplate配置多数据源"><a href="#JdbcTemplate配置多数据源" class="headerlink" title="JdbcTemplate配置多数据源"></a>JdbcTemplate配置多数据源</h2><p>为JdbcTemplate配置多数据源比较简单，只要为其注入不同的Datasource即可，如下：</p>
<pre><code>/**
 * JdbcTemplate支持多数据源
 */
@Configuration
public class JdbcTemplateConfig {

    @Bean(name = &quot;primaryJdbcTemplate&quot;)
    public JdbcTemplate primaryJdbcTemplate(
            @Qualifier(&quot;primaryDataSource&quot;) DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    @Bean(name = &quot;secondaryJdbcTemplate&quot;)
    public JdbcTemplate secondaryJdbcTemplate(
            @Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

}</code></pre><h2 id="测试JdbcTemplate多数据源"><a href="#测试JdbcTemplate多数据源" class="headerlink" title="测试JdbcTemplate多数据源"></a>测试JdbcTemplate多数据源</h2><pre><code>@RunWith(SpringRunner.class)
@SpringBootTest(classes = SpringBootDemoApplication.class)
public class MultipleDatasource4JdbcTemplateTest {

    @Autowired
    @Qualifier(&quot;primaryJdbcTemplate&quot;)
    protected JdbcTemplate jdbcTemplate1;

    @Autowired
    @Qualifier(&quot;secondaryJdbcTemplate&quot;)
    protected JdbcTemplate jdbcTemplate2;

    @Before
    public void setUp() {
        jdbcTemplate1.update(&quot;delete from user &quot;);
        jdbcTemplate2.update(&quot;delete from user &quot;);
    }


    @Test
    public void test() throws Exception {

        // 往第一个数据源中插入两条数据
        jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);
        jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 2, &quot;bbb&quot;, 30);

        // 往第二个数据源中插入一条数据，若插入的是第一个数据源，则会主键冲突报错
        jdbcTemplate2.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);

        // 查一下第一个数据源中是否有两条数据，验证插入是否成功
        Assert.assertEquals(&quot;2&quot;, jdbcTemplate1.queryForObject(&quot;select count(1) from user&quot;, String.class));

        // 查一下第一个数据源中是否有两条数据，验证插入是否成功
        Assert.assertEquals(&quot;1&quot;, jdbcTemplate2.queryForObject(&quot;select count(1) from user&quot;, String.class));

    }

}</code></pre><h2 id="Spring-data-jpa配置多数据源"><a href="#Spring-data-jpa配置多数据源" class="headerlink" title="Spring-data-jpa配置多数据源"></a>Spring-data-jpa配置多数据源</h2><p>对于数据源的配置可以沿用上例中DataSourceConfig的实现。</p>
<p>配置Spring-data-jpa多数据源时要注意，需要指定数据源对应的Entity实体和Repository定义位置。用@Primary区分主数据源。</p>
<p>配置第一数据源：</p>
<pre><code>@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactoryPrimary&quot;,
        transactionManagerRef=&quot;transactionManagerPrimary&quot;,
        basePackages=&quot;top.evolutionary.springbootdemo.repository.primary&quot;//设置Repository所在位置
)
public class SpringDataJpaPrimaryConfig {

    @Autowired
    @Qualifier(&quot;primaryDataSource&quot;)
    private DataSource primaryDataSource;

    @Primary
    @Bean(name = &quot;entityManagerPrimary&quot;)
    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
        return entityManagerFactoryPrimary(builder).getObject().createEntityManager();
    }


    @Primary
    @Bean(name = &quot;entityManagerFactoryPrimary&quot;)
    public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(primaryDataSource)
                .properties(getVendorProperties(primaryDataSource))
                .packages(&quot;top.evolutionary.springbootdemo.dto.primary&quot;) //设置实体类所在位置
                .persistenceUnit(&quot;primaryPersistenceUnit&quot;)
                .build();
    }


    @Autowired
    private JpaProperties jpaProperties;

    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {
        return jpaProperties.getHibernateProperties(dataSource);
    }

    @Primary
    @Bean(name = &quot;transactionManagerPrimary&quot;)
    public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) {
        return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());
    }

}</code></pre><p>配置第二数据源：</p>
<p>@Configuration<br>@EnableTransactionManagement<br>@EnableJpaRepositories(entityManagerFactoryRef = “entityManagerFactorySecondary”,<br>        transactionManagerRef=”transactionManagerSecondary”,<br>        basePackages=”top.evolutionary.springbootdemo.repository.secdary”//设置Repository所在位置<br>)<br>public class SpringDataJpaSecdaryConfig {</p>
<pre><code>@Autowired
@Qualifier(&quot;secondaryDataSource&quot;)
private DataSource primaryDataSource;

@Bean(name = &quot;entityManagerSecondary&quot;)
public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
    return entityManagerFactoryPrimary(builder).getObject().createEntityManager();
}


@Bean(name = &quot;entityManagerFactorySecondary&quot;)
public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(primaryDataSource)
            .properties(getVendorProperties(primaryDataSource))
            .packages(&quot;top.evolutionary.springbootdemo.dto.secdary&quot;) //设置实体类所在位置
            .persistenceUnit(&quot;secondaryPersistenceUnit&quot;)
            .build();
}


@Autowired
private JpaProperties jpaProperties;

private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {
    return jpaProperties.getHibernateProperties(dataSource);
}

@Bean(name = &quot;transactionManagerSecondary&quot;)
public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) {
    return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());
}</code></pre><p>}</p>
<h2 id="测试Spring-data-jpa多数据源"><a href="#测试Spring-data-jpa多数据源" class="headerlink" title="测试Spring-data-jpa多数据源"></a>测试Spring-data-jpa多数据源</h2><pre><code>@RunWith(SpringRunner.class)
@SpringBootTest(classes = SpringBootDemoApplication.class)
public class MultipleDatasource4JpaTest {

    @Autowired
    private StaffRepository staffRepository;
    @Autowired
    private CompanyRepository companyRepository;

    @Before
    public void delete() {
        staffRepository.deleteAll();
        companyRepository.deleteAll();
    }


    @Test
    public void test() throws Exception{
        staffRepository.save(new Staff(&quot;richey1&quot;,18));
        staffRepository.save(new Staff(&quot;richey2&quot;,19));
        staffRepository.save(new Staff(&quot;richey3&quot;,20));

        Assert.assertEquals(3, staffRepository.findAll().size());

        companyRepository.save(new Company(&quot;company1&quot;, &quot;add1&quot;));
        companyRepository.save(new Company(&quot;company2&quot;, &quot;add2&quot;));

        Assert.assertEquals(2, companyRepository.findAll().size());


    }

}</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(6)-测试</title>
    <url>/2019/05/16/Spring%20Boot(6)-%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><a href="http://www.spring4all.com/article/252" target="_blank" rel="noopener">本文转自http://www.spring4all.com/article/252</a></p>
<h3 id="集成测试自动配置"><a href="#集成测试自动配置" class="headerlink" title="集成测试自动配置"></a>集成测试自动配置</h3><ul>
<li><p>@SpringJUini4ClassRunner</p>
<p>  开启了Spring集成测试的支持。<br>  自Spring 2.5开始，集成测试支持的形式就变成了SpringJUini4ClassRunner。这是一个Junit测试类运行器，会为Junit测试加载Spring上下文，并为测试类自动织入所需要的Bean。</p>
</li>
<li><p>SpringRunner</p>
<p>  SpringRunner继承了SpringJUini4ClassRunner，但是没有扩展任何的接口，只是名字简短了，所以它跟SpringJUini4ClassRunner左右是一样的，没有区别。</p>
</li>
<li><p>@ContextConfiguration</p>
<p>  指定了如何加载应用上下文。</p>
</li>
<li><p>@SpringApplicationConfiguration</p>
<p>  不仅加载应用上下文，还会开启日志/加载外部属性(application.properties等)以及其它的Spring Boot特性。大多数情况下，我们会用@SpringApplicationConfiguration代替@ContextConfiguration。</p>
</li>
</ul>
<ul>
<li><p>@SpringBootTest</p>
<p>  不仅加载应用上下文，还会开启日志/加载外部属性(application.properties等)以及其它的Spring Boot特性。较新版本的Spring Boot取消了@SpringApplicationConfiguration，改用@SpringBootTest就可以了.</p>
</li>
</ul>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest(classes = SpringBootDemoApplication.class)
public class HelloWorldTest {

    @Autowired
    private HelloWorldService helloWorldService;

    @Test
    public void testSayHello() {
        Assert.assertEquals(helloWorldService.sayHello(), &quot;Hello World!&quot;);
    }

}</code></pre><h3 id="测试Web应用程序"><a href="#测试Web应用程序" class="headerlink" title="测试Web应用程序"></a>测试Web应用程序</h3><p>要恰当的测试Web应用程序，需要使用一些真实的HTTP请求，测试我们的程序可以正确的处理这些请求。Spring Boot为我们提供了两种方案来实现这类测试。</p>
<ul>
<li><p>Spring Mock MVC</p>
<p>  能在一个近似真实的模拟Servlet容器里测试控制器，而不用实际启动应用服务器。</p>
</li>
<li><p>Web集成测试</p>
<p>  在嵌入式Servlet容器里（如Tomcat、Jetty）启动应用程序，在真实的应用服务器里执行测试。</p>
</li>
</ul>
<h4 id="Spring-Mock-MVC"><a href="#Spring-Mock-MVC" class="headerlink" title="Spring Mock MVC"></a>Spring Mock MVC</h4><p>要在测试里使用Mock MVC，可以使用MockMVCbuilders,该类提供了两个静态方法：</p>
<ul>
<li><p>standaloneSetup（）</p>
<p>  构建一个Mock MVC，提供一个或多个手工创建并配置的控制器。</p>
</li>
<li><p>webAppContextSetup（）</p>
<p>  使用Spring应用上下文（WebApplicationcontext）来构建MVC，上下文里可以包含一个或多个配置号的控制器。</p>
</li>
</ul>
<p>两者的区别是，standaloneSetup（）希望我们手工初始化并注入我们测试的控制器，而webAppContextSetup（）基于一个WebApplicationContext的实例，由Spring加载。前者可能只想让它专注于单一控制器的测试，而后者让Spring加载控制器及依赖。</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest(classes = DemoApplication.class)
public class UserControllerTest {

    @Autowired
    private WebApplicationContext applicationContext;

    private MockMvc mockMvc;

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext).build();
    }

    @Test
    public void whenQuerySuccess() throws Exception {
        String result = mockMvc.perform(get(&quot;/user&quot;)
                .param(&quot;username&quot;, &quot;richey&quot;)
                .param(&quot;age&quot;, &quot;18&quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;$.length()&quot;).value(3))
                .andReturn().getResponse().getContentAsString();
        System.out.println(result);
    }



    @Test
    public void whenCreateSuccess() throws Exception {
        Date date = new Date();
        System.out.println(date.getTime());
        String content = &quot;{\&quot;id\&quot;:null,\&quot;userName\&quot;:\&quot;richey\&quot;,\&quot;password\&quot;:null,\&quot;birthday\&quot;:&quot; + date.getTime() + &quot;}&quot;;
        String result = mockMvc.perform(post(&quot;/user&quot;).contentType(MediaType.APPLICATION_JSON_UTF8).content(content))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;$.id&quot;).value(&quot;1&quot;))
                .andReturn().getResponse().getContentAsString();
        System.out.println(result);
    }



}</code></pre><h4 id="测试Web安全"><a href="#测试Web安全" class="headerlink" title="测试Web安全"></a>测试Web安全</h4><p>应用程序里使用了Spring Security的测试模块后，需要创建MockMVC实例运行时的Spring Security配置器。</p>
<p>//TODO</p>
<h4 id="测试运行中的应用程序"><a href="#测试运行中的应用程序" class="headerlink" title="测试运行中的应用程序"></a>测试运行中的应用程序</h4><p>Spring Boot支持Tomcat或Jetty这样的嵌入式Servlet容器作为运行中应用程序的一部分，而且可以用相同的机制在测试的过程中用嵌入式Servlet容器来启动应用程序。</p>
<ul>
<li><p>@WebIntegrationTest</p>
<p>  启动一个嵌入式的Servlet容器，默认是8080端口。一旦应用程序运行在嵌入式容器中，就可以发真实的HTTP请求（比如使用RestTemplate），断言结果了。</p>
</li>
<li><p>使用随机端口启动服务器</p>
<p>  将server.port属性设置为0，让Spring Boot选一个随机的端口。@WebIntegrationTest的value属性支持一个String数组，数组中的每项都是键值对，形如name=value用来设置测试中使用的属性，如：</p>
<pre><code>@WebIntegrationTest(value={&quot;server.port=0&quot;})</code></pre><p>  @WebIntegrationTest还提供了一个randomPort属性，更明确的表示让服务器在随机的端口上启动。</p>
<p>  Spring Boot将local.server.port值设置为了选中的端口，所以我们使用的时候将该属性注入即可：</p>
<pre><code>@Value(&quot;$local.server.port&quot;)
private int port;</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(５)-常用属性配置</title>
    <url>/2019/05/15/Spring%20Boot(%EF%BC%95)-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>默认Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。</p>
<h5 id="使用其它日志实现替换Logback"><a href="#使用其它日志实现替换Logback" class="headerlink" title="使用其它日志实现替换Logback"></a>使用其它日志实现替换Logback</h5><p>一般来说我们不需要切换日志实现，但是如果我们决定使用Log4j或Log4j2，那么只需要修改依赖，引入相应日志的起步依赖，同时排除掉Logback。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><h5 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h5><p>要完全掌握日志配置可以在Classpath的根目录(src/min/resources)里创建logback.xml文件。具体配置可以参考Logback文档。</p>
<p>除了日志格式外，加lockback.xml配置和不加该配置文件的默认配置差不多。</p>
<p>实际上，我们对日配置最常做的改动就是修改日志级别和指定日志输出文件，使用了Spring Boot的配置属性后，我们可以在不创建logback文件的情况下修改这些配置：</p>
<pre><code>logging.level.root=warn
logging.level.top.evolutionary=debug
logging.path=/var/logs
logging.file=evolutionary.log
# 默认情况下，日志文件的大小达到１０Ｍ会切分一次
logging.file.max-size=20M</code></pre><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>只需要通过属性配置数据库的URL和身份信息等就可以了。</p>
<pre><code># 数据源
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/evolutionary_security?useUnicode=true&amp;characterEncoding=utf8
spring.datasource.username=root
spring.datasource.password=root</code></pre><p>在自动配置DataSource Bean的时候，Spring Boot 会使用这里的连接数据。DataSource Bean是一个连接池，如果Classpath里有Tomcat的连接池DataSource，那么会使用这个连接池，否则Spring Boot会在Classpath下找以下连接池:</p>
<ul>
<li>HikariCP</li>
<li>Commons DBCP</li>
<li>Commons DBCP2</li>
</ul>
<p>这里列出的只是自动配置支持的连接池，我们还可以自己配DataSource Bean,用我们喜欢的各种连接池。</p>
<pre><code># 从jndi里查找DataSource
#spring.datasource.jndi-name=</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(4)-属性配置介绍</title>
    <url>/2019/05/14/Spring%20Boot(4)-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="一、自动配置"><a href="#一、自动配置" class="headerlink" title="一、自动配置"></a>一、自动配置</h3><p>在使用Spring Boot之前，我们自己整合Spring应用时需要进行繁琐的xml配置，Spring Boot通过起步依赖和自动配置，使我们只需要引入起步依赖的相关模块就可以了，其中各个模块有自己的默认配置，我们只要在application.properties中完成一些属性的配置就可以了。比如数据库连接、日志相关配置等。</p>
<p>Spring Boot 不单单从 application.properties获取配置，所以我们可以在程序中多种设置配置属性。按照以下列表的优先级排列：</p>
<ol>
<li>命令行参数</li>
<li>java:comp/env 里的 JNDI 属性</li>
<li>JVM 系统属性</li>
<li>操作系统环境变量</li>
<li>RandomValuePropertySource 属性类生成的 random.* 属性</li>
<li>应用以外的 application.properties（或 yml）文件</li>
<li>打包在应用内的 application.properties（或 yml）文件</li>
<li>在应用 @Configuration 配置类中，用 @PropertySource 注解声明的属性文件</li>
<li>SpringApplication.setDefaultProperties 声明的默认属性</li>
</ol>
<h3 id="二、自定义属性"><a href="#二、自定义属性" class="headerlink" title="二、自定义属性"></a>二、自定义属性</h3><p>除了各个模块默认的配置，我们在程序开发的过程中可能还需要一些自定义的配置，本篇我们学习一下自定义配置。</p>
<h5 id="1-定义自己使用的属性"><a href="#1-定义自己使用的属性" class="headerlink" title="1. 定义自己使用的属性"></a>1. 定义自己使用的属性</h5><p>直接在application.properties文件中定义即可，比如</p>
<pre><code>top.richpeople.blog.author=&apos;richey&apos;
top.richpeople.blog.age=18</code></pre><p>然后在程序中通过@Value(“${top.richpeople.blog.author}”)注解来加载对应的配置属性</p>
<pre><code>@Component
public class MyProperties {

    @Value(&quot;${top.richpeople.blog.author}&quot;)
    private String name ;

    @Value(&quot;${top.richpeople.blog.age}&quot;)
    private int age;

}</code></pre><h5 id="2-参数间的引用"><a href="#2-参数间的引用" class="headerlink" title="2. 参数间的引用"></a>2. 参数间的引用</h5><pre><code>top.richpeople.blog.desc=${top.richpeople.blog.author}的年龄是${top.richpeople.blog.age}</code></pre><h5 id="3-使用随机数"><a href="#3-使用随机数" class="headerlink" title="3. 使用随机数"></a>3. 使用随机数</h5><p>Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值.</p>
<pre><code># 使用随机数
# 随机字符串
top.richpeople.blog.value=${random.value}
# 随机int
top.richpeople.blog.number=${random.int}
# 随机long
top.richpeople.blog.bignumber=${random.long}
# 20以内的随机数
top.richpeople.blog.limit10=${random.int(10)}
# 10-20的随机数
top.richpeople.blog.between=${random.int[10,20]}</code></pre><h5 id="4-命令行中设置属性值"><a href="#4-命令行中设置属性值" class="headerlink" title="4. 命令行中设置属性值"></a>4. 命令行中设置属性值</h5><p>例如：</p>
<pre><code>java -jar xxx.jar --server.port=8080</code></pre><p>在命令行中连续两个减号–就是对application.properties中的属性进行赋值的标识。</p>
<p>通过命令行修改属性值是不完全的，所以Spring Boot 提供了屏蔽命令号访问属性值的设置：</p>
<pre><code>SpringApplication.setAddCommandLineProperties(false)。</code></pre><h5 id="5-多环境配置"><a href="#5-多环境配置" class="headerlink" title="5. 多环境配置"></a>5. 多环境配置</h5><p>通常我们的程序会部署到不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都可能会不同。对于多环境的配置，我们通常会配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包。</p>
<p>Spring Boot多环境配置文件名需要满足application-{profile}.proferties的格式，其中{profile}对应环境的标识，比如：</p>
<ul>
<li>application-dev.properties:开发环境</li>
<li>application-test.properties:测试环境</li>
<li>application-prod.properties:生产环境</li>
</ul>
<p>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值，如：</p>
<pre><code>spring.profiles.active=test</code></pre><p>也可以在打包时通过设置-Dspring.profiles.active=prod 去指定相应的配置:</p>
<pre><code>mvn package
java -jar -Dspring.profiles.active=prod springboot-properties-0.0.1-SNAPSHOT.jar</code></pre><p>总结：</p>
<ul>
<li>application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置</li>
<li>application-{profile}.properties中配置各个环境不同的内容</li>
<li>通过命令行方式去激活不同环境的配置</li>
<li>常用样板配置在Spring Boot官方文档给出：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a></li>
</ul>
<h3 id="三、自定义配置文件"><a href="#三、自定义配置文件" class="headerlink" title="三、自定义配置文件"></a>三、自定义配置文件</h3><p>如果想从我们自定义的配置文件中读配置怎么办呢？Spring Boot同样做了很好的支持。</p>
<p>例如我们新建了一个配置文件：evolutionary.properties</p>
<pre><code>top.evolutionary.blog.title=SpringBoot自定义配置



@Component
@PropertySource(&quot;classpath:evolutionary.properties&quot;)
@ConfigurationProperties(prefix = &quot;top&quot;)
public class EvolutionaryProperties {

    @Value(&quot;${top.evolutionary.blog.title}&quot;)
    private String title;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</code></pre><p>springboot1.5版本以下@ConfigurationProperties有两个属性locations（指定配置文件的所在位置），    prefix（指定配置文件中键名称的前缀）。但是1.5版本及以上的版本取消了locations属性，为了指定配置文件的位置，使用@PropertySource(value = “自定义配置文件路径”)指定文件所在位置。</p>
<hr>
<p>感谢资料</p>
<p><a href="http://www.spring4all.com/article/267" target="_blank" rel="noopener">http://www.spring4all.com/article/267</a></p>
<p>《Spring Boot实战》，丁雪峰译</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(3)-快速入门</title>
    <url>/2019/05/12/Spring%20Boot(3)-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>先看一下上一篇我们通过Spring initializr快速构建的Spring Boot项目结构。</p>
<p><img src="http://ogiythg18.bkt.clouddn.com/spring-boot-project-structure.png" alt="image"></p>
<ul>
<li><p>application.properties:用于配置应用程序和Spring Boot的属性</p>
</li>
<li><p>SpringBootDemoApplication.java</p>
<p>起配置和启动引导的作用。首先，这时Spring的主要配置类。虽然Spring Boot的自动配置免除了很多Spring配置，但我们还是需要进行少量的配置以启动自动配置。</p>
<p>@SpringBootApplication用于开启组件扫描和自动配置，实际上是将三个有用的注解组合在了一起：</p>
<ul>
<li>Spring的@Configuration</li>
<li>Spring的@ConponentScan</li>
<li>Spring Boot的@EnableAutoConfiguration，就是这一行配置开启了Spring Boot自动配置的魔力。</li>
</ul>
</li>
</ul>
<ul>
<li>SpringApplication.run:负责启动引打敖应用程序，这里的main方法，让我们可以在命令行中把应用程序当成一个可执行的jar来运行。</li>
</ul>
<pre><code>@SpringBootApplication
public class SpringBootDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootDemoApplication.class, args);
    }
}</code></pre><hr>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(2)-Intellij使用Spring Initializr快速构建工程</title>
    <url>/2019/05/11/Spring%20Boot(2)-Intellij%E4%BD%BF%E7%94%A8Spring%20Initializr%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="使用Intellij中的Spring-Initializr来快速构建"><a href="#使用Intellij中的Spring-Initializr来快速构建" class="headerlink" title="使用Intellij中的Spring Initializr来快速构建"></a>使用Intellij中的Spring Initializr来快速构建</h3><p>在Intellig中使用Spring Initialzr来构建Spring Boot项目非常简单，基本只需要一只点下一步就可以了。</p>
<ul>
<li>菜单栏中选择File=&gt;New=&gt;Project..。其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址。</li>
</ul>
<p><img src="http://ogiythg18.bkt.clouddn.com/intellig-spring-initializr1.png" alt="Initializr"></p>
<ul>
<li>Next,在这里我们可以编辑我们想要创建的工程信息。其中，Type可以改变我们要构建的工程类型，比如：Maven、Gradle；Language可以选择：Java、Groovy、Kotlin。</li>
</ul>
<p><img src="http://ogiythg18.bkt.clouddn.com/intellig-spring-boot2.png" alt="Initializr"></p>
<ul>
<li>Next，进入选择Spring Boot版本和依赖管理的窗口。在这里值的我们关注的是，它不仅包含了Spring Boot Starter POMs中的各个依赖，还包含了Spring Cloud的各种依赖。</li>
</ul>
<p><img src="http://ogiythg18.bkt.clouddn.com/intelliij-spring-initializr3.png" alt="Initializr"></p>
<ul>
<li>Next,最后是工程物理存储的一些细节，最后Finesh就完成工程的构建了。</li>
</ul>
<hr>
<p><a href="http://www.spring4all.com/article/247" target="_blank" rel="noopener">参考自Spring4all</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot(1)-简介</title>
    <url>/2019/05/10/Spring%20Boot(1)-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”…Most Spring Boot applications need very little Spring configuration.</p>
</blockquote>
<p>Spring Boot(英文中是“引导”的意思)，是用来简化Spring应用的搭建到开发的过程。应用开箱即用，只要通过 “just run”（可能是 java -jar 或 tomcat 或 maven插件run 或 shell脚本），就可以启动项目。二者，Spring Boot 只要很少的Spring配置文件（例如那些xml，property）。 因为“习惯优先于配置”的原则，使得Spring Boot在快速开发应用和微服务架构实践中得到广泛应用。   Javaer装好JDK环境和Maven工具就可以开始学习Boot了~</p>
<h3 id="Spring-Boot-概要"><a href="#Spring-Boot-概要" class="headerlink" title="Spring Boot 概要"></a>Spring Boot 概要</h3><ul>
<li><p>自动配置</p>
<p>  针对Spring应用程序常见的功能，Spring能自动提供相关配置</p>
</li>
<li><p>起步依赖</p>
<p>  告诉Spring Boot需要什么样的功能，他就能引入需要的库</p>
</li>
<li><p>命令行界面</p>
</li>
</ul>
<ul>
<li>Actuator</li>
</ul>
<h4 id="1-自动配置"><a href="#1-自动配置" class="headerlink" title="1. 自动配置"></a>1. 自动配置</h4><p>如果在Classpath里发现JdbcTemplate，那么Spring Boot就会自动配置一个JdbcTemplate的Bean，我们无需操心这种Bean的配置，Spring Boot会做好准备，随时都可以将其注入到我们的Bean中。</p>
<h4 id="2-起步依赖"><a href="#2-起步依赖" class="headerlink" title="2. 起步依赖"></a>2. 起步依赖</h4><p>起步依赖其实就是特殊的Maven依赖或Gradle依赖，利用了传递依赖解析，把常用的库聚合在一起，组成了几个为特定功能而定制的依赖。</p>
<p>我们无需关注这些库的版本，Spring Boot起步依赖引入的库版本都是经过测试的，它们之间不会出现不兼容的情况。</p>
<p>例：Spring Boot的web起步依赖</p>
<pre><code>org.springframework.boot:spring-boot-starter-web</code></pre><h4 id="3-命令行界面"><a href="#3-命令行界面" class="headerlink" title="3. 命令行界面"></a>3. 命令行界面</h4><p>不常用。</p>
<h4 id="4-Actuator"><a href="#4-Actuator" class="headerlink" title="4. Actuator"></a>4. Actuator</h4><p>Actuator提供了在运行使检测应用程序内部情况的能力。，包括以下细节：</p>
<ul>
<li>Spring应用程序里配置的Bean</li>
<li>Spring Boot的自动配置做的决策</li>
<li>应用程序里线程的当前状态</li>
<li>应用程序最近处理过的HTTP请求的追踪情况</li>
<li>各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标</li>
</ul>
<h3 id="Spring-Boot的几点说明"><a href="#Spring-Boot的几点说明" class="headerlink" title="Spring Boot的几点说明"></a>Spring Boot的几点说明</h3><h4 id="1-Spring-Boot不是应用服务器"><a href="#1-Spring-Boot不是应用服务器" class="headerlink" title="1. Spring Boot不是应用服务器"></a>1. Spring Boot不是应用服务器</h4><p>Spring Boot 可以把Ｗｅｂ应用程序变为可自执行的JAR文件，不用部署到传统web服务器中，就可以在命令行中执运行，这是因为Spring boot 内嵌了一个Servlet容器（Tomcat/Jetty或Undertow)，而不是Spring Boot实现的。</p>
<h4 id="2-类似的Spring-也没有实现JPA或JMS"><a href="#2-类似的Spring-也没有实现JPA或JMS" class="headerlink" title="2. 类似的Spring 也没有实现JPA或JMS"></a>2. 类似的Spring 也没有实现JPA或JMS</h4><h4 id="3-Spring-Boot本质上就是Spring"><a href="#3-Spring-Boot本质上就是Spring" class="headerlink" title="3. Spring Boot本质上就是Spring"></a>3. Spring Boot本质上就是Spring</h4><hr>
<p><a href="http://www.spring4all.com/article/266" target="_blank" rel="noopener">Spring Boot 自述</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（9）-数据库索引——给字符串加索引</title>
    <url>/2019/05/01/Mysql%EF%BC%889%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E2%80%94%E2%80%94%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引长度限制"><a href="#索引长度限制" class="headerlink" title="索引长度限制"></a>索引长度限制</h1><p>默认情况下，InnoDB 引擎单一字段索引的长度最大为 767 字节</p>
<blockquote>
<p>If innodb_large_prefix is enabled (the default in 5.7.7 ), the index key prefix limit is 3072 bytes for InnoDB tables that use DYNAMIC or COMPRESSED row format. If innodb_large_prefix is disabled(the default in 5.7.6), the index key prefix limit is 767 bytes for tables of any row format.</p>
</blockquote>
<blockquote>
<p>MySQL assumes 3 bytes per utf8 character. 255 characters is the maximum index size you can specify per column, because 256x3=768, which breaks the 767 byte limit. If you don’t specify index size, MySQL chooses the maximum size (i.e. 255 per column)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE &#96;foo&#96; (  </span><br><span class="line">    -&gt;       &#96;a&#96; varchar(255) DEFAULT NULL,  </span><br><span class="line">    -&gt;       &#96;b&#96; varchar(255) DEFAULT NULL,  </span><br><span class="line">    -&gt;       &#96;c&#96; varchar(255) DEFAULT NULL,  </span><br><span class="line">    -&gt;       &#96;d&#96; varchar(255) DEFAULT NULL,  </span><br><span class="line">    -&gt;       &#96;e&#96; varchar(255) DEFAULT NULL,  </span><br><span class="line">    -&gt;        KEY &#96;a-b-c-d&#96; (&#96;a&#96;,&#96;b&#96;,&#96;c&#96;,&#96;d&#96;,&#96;e&#96;)  </span><br><span class="line">    -&gt; ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">ERROR 1071 (42000): Specified key was too long; max key length is 3072 bytes</span><br></pre></td></tr></table></figure>
<h1 id="为什么3072"><a href="#为什么3072" class="headerlink" title="为什么3072"></a>为什么3072</h1><p>我们知道InnoDB一个page的默认大小是16k。由于是Btree组织，要求叶子节点上一个page至少要包含两条记录（否则就退化链表了）。</p>
<p>所以一个记录最多不能超过8k。</p>
<p>又由于InnoDB的聚簇索引结构，一个二级索引要包含主键索引，因此每个单个索引不能超过4k （极端情况，pk和某个二级索引都达到这个限制）。</p>
<p>由于需要预留和辅助空间，扣掉后不能超过3500，取个“整数”就是(1024*3)。</p>
<h1 id="单列索引限制"><a href="#单列索引限制" class="headerlink" title="单列索引限制"></a>单列索引限制</h1><p>上面有提到单列索引限制767，起因是256×3-1。这个3是字符最大占用空间（utf8）。但是在5.5以后，开始支持4个字节的uutf8。255×4&gt;767, 于是增加了一个参数叫做 innodb_large_prefix。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_large_prefix&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>innodb_large_prefix is enabled by default in MySQL 5.7. This change coincides with the default value change for innodb_file_format, which is set to Barracuda by default in MySQL 5.7. Together, these default value changes allow larger index key prefixes to be created when using DYNAMIC or COMPRESSED row format. If either option is set to a non-default value, index key prefixes larger than 767 bytes are silently truncated.</p>
</blockquote>
<p>innodb_large_prefix is deprecated and will be removed in a future release. innodb_large_prefix was introduced to disable large index key prefixes for compatibility with earlier versions of InnoDB that do not support large index key prefixes.</p>
<h1 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h1><p>使用了前缀索引，就用不上覆盖索引对查询性能的优化了。</p>
<p>前缀索引无法进行排序优化</p>
<h1 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h1><p>只支持等值查询，不支持范围查询；</p>
<p>无法进行排序优化；</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（8）-搞定Mysql字符集及校对规则</title>
    <url>/2019/04/06/Mysql%EF%BC%888%EF%BC%89-%E6%90%9E%E5%AE%9AMysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%8F%8A%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="MySQL的字符集（Character-Set"><a href="#MySQL的字符集（Character-Set" class="headerlink" title="MySQL的字符集（Character Set)"></a>MySQL的字符集（Character Set)</h1><p>关于字符集，之前转载了一篇文章讲的非常好——<a href="">关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）</a></p>
<p>常见字符集：</p>
<ul>
<li>ASCII字符集：基于罗马字母表的一套字符集，它采用1个字节的低7位表示字符，高位始终为0。</li>
<li>LATIN1字符集：相对于ASCII字符集做了扩展，仍然使用一个字节表示字符，但启用了高位，扩展了字符集的表示范围。</li>
<li>GBK字符集：支持中文，字符有一字节编码和两字节编码方式。</li>
<li>UTF8字符集：Unicode字符集的一种，是计算机科学领域里的一项业界标准，支持了所有国家的文字字符，utf8采用1-4个字节表示字符。</li>
</ul>
<h1 id="MySQL与字符集"><a href="#MySQL与字符集" class="headerlink" title="MySQL与字符集"></a>MySQL与字符集</h1><p>查看NySQL系统变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%character%&#39;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure>
<p>正确使用字符集</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>变量作用</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_client</td>
<td>客户端来源数据使用的字符集</td>
</tr>
<tr>
<td>character_set_connection</td>
<td>连接层字符集</td>
</tr>
<tr>
<td>character_set_database</td>
<td>当前选中数据库的默认字符集</td>
</tr>
<tr>
<td>character_set_results</td>
<td>查询结果字符集</td>
</tr>
<tr>
<td>character_set_server</td>
<td>默认的内部操作字符集</td>
</tr>
<tr>
<td>character_set_system</td>
<td>数据元数据（字段名等）字符集</td>
</tr>
</tbody></table>
<p>这些字符集参数的作用说明：</p>
<ol>
<li>设置库、表、列字符集<ul>
<li>建库时，若未明确指定字符集，则采用character_set_server指定的字符集。</li>
<li>建表时，若未明确指定字符集，则采用当前库所采用的字符集。</li>
<li>新增时，修改表字段时，若未明确指定字符集，则采用当前表所采用的字符集。</li>
</ul>
</li>
<li>更新查询涉及的字符集变量<ul>
<li>更新流程字符集转换过程：character_set_client–&gt;character_set_connection–&gt;表字符集。</li>
<li>查询流程字符集转换过程：表字符集–&gt;character_set_result</li>
</ul>
</li>
<li>character_set_database<ul>
<li>当前默认数据库的字符集，比如执行use xxx后，当前数据库变为xxx，若xxx的字符集为utf8，那么此变量值就变为utf8(供系统设置，无需人工设置)。</li>
</ul>
</li>
</ol>
<h1 id="MySQL客户端与字符集"><a href="#MySQL客户端与字符集" class="headerlink" title="MySQL客户端与字符集"></a>MySQL客户端与字符集</h1><p>1.对于输入来说：</p>
<p>客户端使用的字符集必须通过character_set_client、character_set_connection体现出来：</p>
<ul>
<li>在客户端对数据进行编码（Linux：utf8、windows：gbk）</li>
<li>MySQL接到SQL语句后(比如insert)，发现有字符，询问客户端通过什么方式对字符编码：客户端通过character_set_client参数告知MySQL客户端的编码方式(所以此参数需要正确反映客户端对应的编码)</li>
<li>当MySQL发现客户端的client所传输的字符集与自己的connection不一样时，会将client的字符集转换为connection的字符集</li>
<li>MySQL将转换后的编码存储到MySQL表的列上，在存储的时候再判断编码是否与内部存储字符集（按照优先级判断字符集类型）上的编码一致，如果不一致需要再次转换</li>
</ul>
<p>2.对于查询来说：</p>
<p>客户端使用的字符集必须通过character_set_results来体现，服务器询问客户端字符集，通过character_set_results将结果转换为与客户端相同的字符集传递给客户端。(character_set_results默认等于character_set_client)</p>
<h1 id="字符集常见处理操作"><a href="#字符集常见处理操作" class="headerlink" title="字符集常见处理操作"></a>字符集常见处理操作</h1><p>查看字符集编码设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%character%&#39;;</span><br></pre></td></tr></table></figure>

<p>运行时设置字符集编码</p>
<p>运行时修改（重启后会失效，如果想要重启后保持不变，需要写进配置文件里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set names &#39;utf8&#39;;</span><br><span class="line"></span><br><span class="line">相当于同时：</span><br><span class="line"></span><br><span class="line">set character_set_client &#x3D; utf8;</span><br><span class="line">set character_set_results &#x3D; utf8;</span><br><span class="line">set character_set_connection &#x3D; utf8;</span><br></pre></td></tr></table></figure>
<p>修改数据库字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter database database_name character set xxx;</span><br></pre></td></tr></table></figure>
<p>只修改库的字符集，影响后续创建的表的默认定义；对于已创建的表的字符集不受影响。（一般在数据库实现字符集即可，表和列都默认采用数据库的字符集）</p>
<p>修改表的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 只修改表的字符集，影响后续该表新增列的默认定义，已有列的字符集不受影响。</span><br><span class="line">mysql&gt; alter table table_name character set xxx；</span><br><span class="line"></span><br><span class="line">-- 同时修改表字符集和已有列字符集，并将已有数据进行字符集编码转换。</span><br><span class="line">mysql&gt; alter table table_name convert to character set xxx;</span><br></pre></td></tr></table></figure>
<p>修改列的字符集</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY</span><br><span class="line">column_name &#123;CHAR | VARCHAR | TEXT&#125; (column_length)</span><br><span class="line">    [CHARACTER SET charset_name]</span><br><span class="line">    [COLLATE collation_name]</span><br><span class="line">mysql&gt; alter table table_name modify col_name varchar(col_length) character set xxx;</span><br></pre></td></tr></table></figure>
<p>启动服务时指定字符集</p>
<p>可以在MySQL服务启动时，指定server字符集、字符序。如不指定，默认的字符序分别为latin1、latin1_swedish_ci</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --character-set-server&#x3D;latin1 \</span><br><span class="line">       --collation-server&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>
<p>单独指定server字符集，此时，server字符序为latin1的默认字符序latin1_swedish_ci。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --character-set-server&#x3D;latin1</span><br></pre></td></tr></table></figure>
<p>配置文件指定字符集</p>
<p>除了在命令行参数里指定，也可以在配置文件里指定，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">collation-server &#x3D; utf8_unicode_ci</span><br><span class="line">init-connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server &#x3D; utf8</span><br></pre></td></tr></table></figure>
<p>字符集的正确实践<br>MySQL软件工具本身是没有字符集的，主要是因为工具所在的OS的字符集（Windows：gbk、Linux：utf8），所以字符集的正确实践非常重要：</p>
<ol>
<li>对于insert来说，character_set_client、character_set_connection相同，而且正确反映客户端使用的字符集</li>
<li>对于select来说，character_set_results正确反映客户端字符集</li>
<li>数据库字符集取决于我们要存储的字符类型</li>
<li>字符集转换最多发生一次，这就要求character_set_client、character_set_connection相同</li>
<li>所有的字符集转换都发生在数据库端</li>
</ol>
<p>综述：</p>
<ol>
<li>建立数据库的时候注意字符集（gbk、utf8）；</li>
<li>连接数据库以后，无论是执行dml还是select，只要涉及到varchar、char列，就需要设置正确的字符集参数。</li>
</ol>
<h1 id="MySQL的校对规则"><a href="#MySQL的校对规则" class="headerlink" title="MySQL的校对规则"></a>MySQL的校对规则</h1><p>字符集是一套符号和对应的编号</p>
<ol start="4">
<li><p>查看数据库支持的所有字符集(charset)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show character set;</span><br></pre></td></tr></table></figure>
<p>校对规则(collation)是在字符集内用于字符比较和排序的一套规则，比如有的规则区分大小写，有的则无视。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t1(id int,name varchar(20)); -- t1建表没有指定校对规则</span><br><span class="line">mysql&gt; insert into t1 values (1,&#39;A&#39;),(2,&#39;a&#39;);</span><br><span class="line">mysql&gt; select * from t1 where name &#x3D; &#39;a&#39;;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | A    |</span><br><span class="line">|    2 | a    |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure>
<p>查看数据库支持的校对规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show collation;</span><br></pre></td></tr></table></figure>
<p>查看当前字符集和校对规则设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show variables like &#39;collation_%&#39;;</span><br><span class="line">+----------------------+-------------------+</span><br><span class="line">| Variable_name        | Value             |</span><br><span class="line">+----------------------+-------------------+</span><br><span class="line">| collation_connection | utf8_general_ci   |</span><br><span class="line">| collation_database   | utf8_general_ci   |</span><br><span class="line">| collation_server     | latin1_swedish_ci |</span><br><span class="line">+----------------------+-------------------+</span><br></pre></td></tr></table></figure>
<p>校对规则特征：</p>
</li>
<li><p>两个不同的字符集不能有相同的校对规则；</p>
</li>
<li><p>每个字符集有一个默认校对规则；</p>
</li>
<li><p>存在校对规则命名约定：以其相关的字符集名开始，中间包括一个语言名，并且以_ci（大小写不敏感）、_cs（大小写敏感）或_bin（二元）结束。<br>注意：</p>
</li>
</ol>
<p>系统使用utf8字符集，若使用utf8_bin校对规则执行SQL查询时区分大小写，使用utf8_general_ci不区分大小写(默认的utf8字符集对应的校对规则是utf8_general_ci)。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t2(id int,name varchar(20)) character set&#x3D;utf8 collate&#x3D;utf8_bin;</span><br><span class="line">mysql&gt; insert into t1 values (1,&#39;A&#39;),(2,&#39;a&#39;);</span><br><span class="line">mysql&gt; select * from t1 where name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | a    |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure>
<p>相关连接</p>
<p><a href="https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html" target="_blank" rel="noopener">再见乱码：5分钟读懂MySQL字符集设置</a></p>
<p><a href="https://www.cnblogs.com/geaozhang/p/6724393.html" target="_blank" rel="noopener">MySQL字符集及校对规则的理解</a></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>maven必知必会</title>
    <url>/2019/04/06/maven%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>对于Maven来说，仓库只分为两类：本地仓库和远程仓库。当Maven需要根据坐标寻找构件的时候，它首先会查找本地仓库，如果本地仓库有此构件，则直接使用；</p>
<p>如果本地仓库没有此构件或许需要查看此构件是否有更新版本Maven会去远程仓库查找，发现需要的构件后，会先下载到本地仓库再使用。如果本地仓库和远程仓库都没有找到需要的构件，则Maven会报错。</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/5ca8497de4b0ec8ff3663e7d"></iframe>

<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h2><p>中央仓库是默认的远程仓库，Maven安装文件中自带的超级POM中自带了中央仓库的配置，所有的Maven项目都会继承Maven的这个超级POM.</p>
<p>超级POM中的中央仓库配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span> central<span class="tag">&lt;/<span class="name">id</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span> Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span> default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 不从该仓库下载快照版本的构件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span> false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>覆盖中央仓库的默认地址</p>
<p>在setting.xml里面配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>        </span><br><span class="line">…        </span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span> maven-net-cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span> Maven China Mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span> central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>        </span><br><span class="line">…        </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>central表示只为central仓库做镜像，如果想为所有的仓库做镜像可以将central改为： *</p>
<h2 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h2><p>在repositories元素下，可以使用repository子元素声明一个或多个远程仓库。</p>
<p>作用于当先项目</p>
<p>添加如下配置到pom的第一层（xml），只作用于当前项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可添加多个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 仓库地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否下载该仓库的release类型包，true下载，false不下载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否下载该仓库的snapshots类型包，true下载，false不下载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- Maven从远程仓库检查的频率，默认是daily --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="snapshots和releases元素的子元素："><a href="#snapshots和releases元素的子元素：" class="headerlink" title="snapshots和releases元素的子元素："></a>snapshots和releases元素的子元素：</h2><ul>
<li><p>updatePolicy</p>
<p>Maven从远程仓库检查的频率，默认是daily，表示Maven每天检查一次。其它可用的值包括：never——从不检查更新；<br>always——每次构建都检查更新；X——每隔X分钟检查一次（X为任意整数）。</p>
</li>
<li><p>checksumPolicy<br>用来配置Mavne校验和文件的策略。当部署构件到仓库时会同时部署校验和文件。下载构件时Maven会验证校验和文件。如果验证失败，怎么办？<br>当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其它可能的值包括：fail——验证不通过时，让构建失败；ignore——使<br>Maven完全忽略验证错误。</p>
</li>
<li><p>作用于全局</p>
<p>在settings文件中添加配置，添加profiles后，mirrors可以省略</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>besttop_nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 激活此profile --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--all requests to nexus via the mirror --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可添加多个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 自定义 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 自定义 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 仓库地址 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 是否下载该仓库的release类型包，true下载，false不下载 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 是否下载该仓库的snapshots类型包，true下载，false不下载 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h2><p>大部分远程仓库无需认证就可以访问，但有时候出于安全方面的考虑，我们需要提供认证信息才能访问一些仓库。比如组织内部的私有仓库。</p>
</li>
</ul>
<p>仓库信息可以配置子啊POM中，但是认证信息必须配置在setting.xml文件中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proj<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>pwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>这里的关键是id，这里的id必须要与POM中需要认证的repository元素的id完全一致。换句话说，正是这个id将认证信息与仓库联系在一起。</p>
<p>部署至远程仓库<br>私服的一大作用就是部署第三方构件，包括组织内部生成的构件及一些无法从外部仓库直接获取的构件。<br>无论是日常开发中生成的构件，还是正式版本发布的构件，都需要部署到仓库中，供其它团队成员使用。</p>
<p>配置distributionManagement元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 发布版本的构件仓库 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>false<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- id是仓库的唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>corp1<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- name是为了方便人阅读 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Corporate Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 表示该仓库的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://repo/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 快照版本的构件仓库 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>propSnap<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Propellors Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>sftp://propellers.net/maven<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Maven的快照版本，在发布的过程中会自动打上时间戳，有了时间戳，Maven就能找到相同快照版本的最新文件。<br>当我们下载某一个版本的快照时，Maven会从远程仓库检查该构件是否有更新，有的话会先下载更新到本地仓库。<br>注意Maven并不会每次都去检查，默认会每天检查一次（根据updatePolicy配置），我们可以使用-U命令，让Maven强制更新，比如：mvn clean install -U.</p>
<p>其它Maven配置详解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                               http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>localRepository</p>
<p>表示本地库的保存位置，也就是maven2主要的jar保存位置，默认在${user.dir}/.m2/repository，如果需要另外设置，就换成其他的路径。</p>
</li>
<li><p>offline</p>
<p>设置为true后，不会每次编译，都去查找远程中心库。当然前提是你已经下载了必须的依赖包。实际开发过程中迭代频繁的情况下，构件经常变动，不建议设置为true。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ci/cd</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis02-命令速查</title>
    <url>/2019/04/06/Redis02-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h1><pre><code>127.0.0.1:6379&gt; SET expirecode foo
OK
127.0.0.1:6379&gt; TTL expirecode
(integer) -1
127.0.0.1:6379&gt; EXPIRE expirecode 60
(integer) 1
127.0.0.1:6379&gt; ttl expirecode
(integer) 54
127.0.0.1:6379&gt; set expirecode boo # set修改后,过期时间失效
OK
127.0.0.1:6379&gt; ttl expirecode
(integer) -1</code></pre><h1 id="redis客户端连接"><a href="#redis客户端连接" class="headerlink" title="redis客户端连接"></a>redis客户端连接</h1><pre><code>./redis-cli    (本地)
./redis-cli -h [host] -p [port] -a [password] (远程服务器)</code></pre><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><ol>
<li><p>连接操作命令</p>
<pre><code>quit：关闭连接（connection）

auth：简单密码认证

help cmd： 查看cmd帮助，例如：help quit</code></pre></li>
<li><p>持久化</p>
<pre><code>save：将数据同步保存到磁盘

bgsave：将数据异步保存到磁盘

lastsave：返回上次成功将数据保存到磁盘的Unix时戳

shutdown：将数据同步保存到磁盘，然后关闭服务</code></pre></li>
<li><p>远程服务控制</p>
<pre><code>info：提供服务器的信息和统计

monitor：实时转储收到的请求

slaveof：改变复制策略设置

config：在运行时配置Redis服务器</code></pre></li>
<li><p>对key操作的命令</p>
<pre><code>exists(key)：确认一个key是否存在

del(key)：删除一个key

type(key)：返回值的类型

keys(pattern)：返回满足给定pattern的所有key

randomkey：随机返回key空间的一个

keyrename(oldname, newname)：重命名key

dbsize：返回当前数据库中key的数目

expire：设定一个key的活动时间（s）

ttl：获得一个key的活动时间

select(index)：按索引查询

move(key, dbindex)：移动当前数据库中的key到dbindex数据库

flushdb：删除当前选择数据库中的所有key

flushall：删除所有数据库中的所有key</code></pre></li>
<li><p>String</p>
<pre><code>set(key, value)：给数据库中名称为key的string赋予值value

get(key)：返回数据库中名称为key的string的value

getset(key, value)：给名称为key的string赋予上一次的value

mget(key1, key2,…, key N)：返回库中多个string的value

setnx(key, value)：添加string，名称为key，值为value

setex(key, time, value)：向库中添加string，设定过期时间time

mset(key N, value N)：批量设置多个string的值

msetnx(key N, value N)：如果所有名称为key i的string都不存在

incr(key)：名称为key的string增1操作

incrby(key, integer)：名称为key的string增加integer

decr(key)：名称为key的string减1操作

decrby(key, integer)：名称为key的string减少integer

append(key, value)：名称为key的string的值附加value

substr(key, start, end)：返回名称为key的string的value的子串</code></pre></li>
<li><p>List</p>
<pre><code>rpush(key, value)：在名称为key的list尾添加一个值为value的元素

lpush(key, value)：在名称为key的list头添加一个值为value的 元素

llen(key)：返回名称为key的list的长度

lrange(key, start, end)：返回名称为key的list中start至end之间的元素

ltrim(key, start, end)：截取名称为key的list

lindex(key, index)：返回名称为key的list中index位置的元素

lset(key, index, value)：给名称为key的list中index位置的元素赋值

lrem(key, count, value)：删除count个key的list中值为value的元素

lpop(key)：返回并删除名称为key的list中的首元素

rpop(key)：返回并删除名称为key的list中的尾元素

blpop(key1, key2,… key N, timeout)：lpop命令的block版本。

brpop(key1, key2,… key N, timeout)：rpop的block版本。

rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</code></pre></li>
<li><p>Set</p>
<pre><code>sadd(key, member)：向名称为key的set中添加元素member

srem(key, member) ：删除名称为key的set中的元素member

spop(key) ：随机返回并删除名称为key的set中一个元素

smove(srckey, dstkey, member) ：移到集合元素

scard(key) ：返回名称为key的set的基数

sismember(key, member) ：member是否是名称为key的set的元素

sinter(key1, key2,…key N) ：求交集

sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合

sunion(key1, (keys)) ：求并集

sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合

sdiff(key1, (keys)) ：求差集

sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合

smembers(key) ：返回名称为key的set的所有元素

srandmember(key) ：随机返回名称为key的set的一个元素</code></pre></li>
<li><p>Hash</p>
<pre><code>hset(key, field, value)：向名称为key的hash中添加元素field

hget(key, field)：返回名称为key的hash中field对应的value

hmget(key, (fields))：返回名称为key的hash中field i对应的value

hmset(key, (fields))：向名称为key的hash中添加元素field

hincrby(key, field, integer)：将名称为key的hash中field的value增加integer

hexists(key, field)：名称为key的hash中是否存在键为field的域

hdel(key, field)：删除名称为key的hash中键为field的域

hlen(key)：返回名称为key的hash中元素个数

hkeys(key)：返回名称为key的hash中所有键

hvals(key)：返回名称为key的hash中所有键对应的value

hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis01-入门及基础数据结构</title>
    <url>/2019/04/05/Redis01-%E5%85%A5%E9%97%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><ol>
<li>使用 Docker 安装。</li>
<li>通过 Github 源码编译。</li>
<li>直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。</li>
</ol>
<h2 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h2><pre><code># 拉取 redis 镜像
&gt; docker pull redis
# 运行 redis 容器
&gt; docker run --name myredis -d -p6379:6379 redis
# 执行容器中的 redis-cli，可以直接使用命令行操作 redis
&gt; docker exec -it myredis redis-cli
Github 源码编译方式</code></pre><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><pre><code>&gt; git clone --branch 2.8 --depth 1 git@github.com:antirez/redis.git
&gt; cd redis
# 编译
&gt; make
&gt; cd src
# 运行服务器，daemonize表示在后台运行
&gt; ./redis-server --daemonize yes
# 运行命令行
&gt; ./redis-cli</code></pre><h2 id="直接安装方式"><a href="#直接安装方式" class="headerlink" title="直接安装方式"></a>直接安装方式</h2><pre><code># mac
&gt; brew install redis
# ubuntu
&gt; apt-get install redis
# redhat
&gt; yum install redis
# 运行客户端
&gt; redis-cli...</code></pre><h1 id="二、Redis基础数据结构"><a href="#二、Redis基础数据结构" class="headerlink" title="二、Redis基础数据结构"></a>二、Redis基础数据结构</h1><ol>
<li>string(字符串)</li>
<li>list(列表)</li>
<li>set(集合)</li>
<li>hash(哈系)</li>
<li>zset(有序集合)</li>
</ol>
<p>Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。</p>
<h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string(字符串)"></a>string(字符串)</h2><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。</p>
<ul>
<li><p>键值对    </p>
<pre><code>[richey@192 ~]$ redis-cli
127.0.0.1:6379&gt; set name richey
OK
127.0.0.1:6379&gt; get name
&quot;richey&quot;
127.0.0.1:6379&gt; exists name
(integer) 1
127.0.0.1:6379&gt; EXISTS name
(integer) 1
127.0.0.1:6379&gt; DEL name
(integer) 1
127.0.0.1:6379&gt;</code></pre></li>
<li><p>批量键值对</p>
<pre><code>127.0.0.1:6379&gt; set name1 richey
OK
127.0.0.1:6379&gt; set name2 kelly
OK
127.0.0.1:6379&gt; MGET name1 name2 name3
1) &quot;richey&quot;
2) &quot;kelly&quot;
3) (nil)</code></pre></li>
</ul>
<pre><code>127.0.0.1:6379&gt; mset name1 aoo name2 boo name3 coo
OK
127.0.0.1:6379&gt; mget name1 name2 name3
1) &quot;aoo&quot;
2) &quot;boo&quot;</code></pre><ul>
<li><p>过期和set命令扩展</p>
<pre><code>127.0.0.1:6379&gt; set name richey
OK
127.0.0.1:6379&gt; get name
&quot;richey&quot;
127.0.0.1:6379&gt; EXPIRE name 5
(integer) 1
... wait for 5s
127.0.0.1:6379&gt; get name
(nil)</code></pre></li>
</ul>
<pre><code>127.0.0.1:6379&gt; SETEX name 5 richey # 设置name并在5s后过期 相当于set+expire
OK
127.0.0.1:6379&gt; get name
&quot;richey&quot;
127.0.0.1:6379&gt; get name
(nil)

127.0.0.1:6379&gt; SETNX name richey # 如果name不存在就执行set创建
(integer) 1
127.0.0.1:6379&gt; get name
&quot;richey&quot;
127.0.0.1:6379&gt; SETNX name kelly # 因为name已经存在所以执行set创建不成功
(integer) 0
127.0.0.1:6379&gt; get name
&quot;richey&quot;</code></pre><ul>
<li><p>计数</p>
<p>  如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。</p>
<pre><code>127.0.0.1:6379&gt; set age 18
OK
127.0.0.1:6379&gt; INCR age
(integer) 19
127.0.0.1:6379&gt; INCRBY age 5
(integer) 24
127.0.0.1:6379&gt; INCRBY age -5
(integer) 19
127.0.0.1:6379&gt; set maxInteger 9223372036854775807 # Long.Max
OK
127.0.0.1:6379&gt; INCR maxInteger
(error) ERR increment or decrement would overflow</code></pre></li>
</ul>
<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>Redis的列表相当于java的LinkedList,是链表.</p>
<ul>
<li><p>右边进左边出(或左边进右边出):队列</p>
<pre><code>27.0.0.1:6379&gt; LPOP books
&quot;java&quot;
127.0.0.1:6379&gt; LPUSH movies m1 m2 m3
(integer) 3
127.0.0.1:6379&gt; RPOP movies
&quot;m1&quot;
127.0.0.1:6379&gt; RPOP movies
&quot;m2&quot;
127.0.0.1:6379&gt; RPOP movies
&quot;m3&quot;
127.0.0.1:6379&gt; RPOP movies
(nil)</code></pre></li>
<li><p>右边进右边出(或左边进左边出):栈</p>
<pre><code>127.0.0.1:6379&gt; LPUSH book java python go
(integer) 3
127.0.0.1:6379&gt; LPOP book
&quot;go&quot;</code></pre></li>
<li><p>慢操作</p>
<pre><code>127.0.0.1:6379&gt; RPUSH books java go python
(integer) 3
127.0.0.1:6379&gt; LINDEX books 1 #相当于get(int index)
&quot;go&quot;
127.0.0.1:6379&gt; LRANGE books 0 -1 # -1表示倒数第一个元素
1) &quot;java&quot;
2) &quot;go&quot;
3) &quot;python&quot;
127.0.0.1:6379&gt; LTRIM books 1 -1 #保留第2个到最后一个元素
OK
127.0.0.1:6379&gt; LRANGE books 0 -1 #获取所有元素
1) &quot;go&quot;
2) &quot;python&quot;

127.0.0.1:6379&gt; LTRIM books 1 0 # 相当于清空真个列表,因为区间长度为负
OK
127.0.0.1:6379&gt; LLEN books
(integer) 0</code></pre></li>
</ul>
<h2 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash(字典)"></a>hash(字典)</h2><p>Redis的字典相当于java的HashMap,它是无序字典.</p>
<p>hash也可以用来存储用户信息,不同于字符串一次性需要序列化整个对象,hash可以对用户结构中的每个字段单独存储.这样当我们需要获取用户的信息时可以单独获取.而以字符串的形式存储就只能一次性全部读取,这样会比较浪费网络流量.</p>
<p>hash也有缺点,hash的存储消耗要高于单个字符串,到底要用hash还是字符串要根据具体情况分析权衡.</p>
<pre><code>127.0.0.1:6379&gt; HSET books java &quot;think in java&quot;
(integer) 1
127.0.0.1:6379&gt; HSET books go &quot;concurrency in go&quot;
(integer) 1
127.0.0.1:6379&gt; HSET books python &quot;python cookbook&quot;
(integer) 1
127.0.0.1:6379&gt; HGETALL books
1) &quot;java&quot;
2) &quot;think in java&quot;
3) &quot;go&quot;
4) &quot;concurrency in go&quot;
5) &quot;python&quot;
6) &quot;python cookbook&quot;
127.0.0.1:6379&gt; HLEN books
(integer) 3
127.0.0.1:6379&gt; HGET books go
&quot;concurrency in go&quot;
127.0.0.1:6379&gt; HMSET books java &quot;effective java&quot; python &quot;learning python&quot; go &quot;modern golang&quot;
OK
127.0.0.1:6379&gt; HGETALL books
1) &quot;java&quot;
2) &quot;effective java&quot;
3) &quot;go&quot;
4) &quot;modern golang&quot;
5) &quot;python&quot;
6) &quot;learning python&quot;    </code></pre><ul>
<li><p>计数</p>
<p>  hash结构中的单个子key的value也可以计数</p>
<pre><code>127.0.0.1:6379&gt; HINCRBY richey age 1
(integer) 1
127.0.0.1:6379&gt; HGET richey age
&quot;1&quot;
127.0.0.1:6379&gt; HINCRBY richey age 2
(integer) 3
127.0.0.1:6379&gt; HGET richey age
&quot;3&quot;</code></pre></li>
</ul>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h2><p>Redis中的集合相当于java中的HashSet,它内部的键值对是无序的唯一的.</p>
<pre><code>127.0.0.1:6379&gt; SADD books java
(integer) 1
127.0.0.1:6379&gt; SADD books java # 重复加不进去
(integer) 0
127.0.0.1:6379&gt; SADD books java python
(integer) 1
127.0.0.1:6379&gt; SADD books golang
(integer) 1
127.0.0.1:6379&gt; SMEMBERS books # 注意顺序跟加进去的顺序不一致,是无序的
1) &quot;python&quot;
2) &quot;golang&quot;
3) &quot;java&quot;
127.0.0.1:6379&gt; SISMEMBER books java #查询某个value是否存在
(integer) 1
127.0.0.1:6379&gt; SISMEMBER books js
(integer) 0
127.0.0.1:6379&gt; SCARD books # 获取集合长度
(integer) 3
127.0.0.1:6379&gt; SPOP books # 弹出一个
&quot;java&quot;
127.0.0.1:6379&gt;</code></pre><h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h2><p>zset类似与java中的SortedSEt和HashMap的结合.一方便它是一个set,保证了内部value的唯一性,另一个方面它可以给每个value赋予一个score,代表这个value的排序权重.</p>
<p>zset可以用来存储学生的成绩,value值是学生的id,score是他的考试成绩.可以根据成绩进行排序.</p>
<pre><code>127.0.0.1:6379&gt; ZADD books 9.0 &quot;think in java&quot;
(integer) 1
127.0.0.1:6379&gt; ZADD books 8.5 &quot;java concurrency&quot;
(integer) 1
127.0.0.1:6379&gt; ZADD books 8.1 &quot;java cookbook&quot;
(integer) 1
127.0.0.1:6379&gt; ZRANGE books 0 -1  # 按score排序列出,参数区间为排名范围
1) &quot;java cookbook&quot;
2) &quot;java concurrency&quot;
3) &quot;think in java&quot;
127.0.0.1:6379&gt; ZREVRANGE books 0 -1 # 逆序
1) &quot;think in java&quot;
2) &quot;java concurrency&quot;
3) &quot;java cookbook&quot;
127.0.0.1:6379&gt; ZCARD books # 相当于count()
(integer) 3
127.0.0.1:6379&gt; ZSCORE books &quot;think in java&quot; # 获取指定value的score
&quot;9&quot;
127.0.0.1:6379&gt; ZRANK books &quot;java concurrency&quot; #排名
(integer) 1
127.0.0.1:6379&gt; ZRANK books &quot;think in java&quot;
(integer) 2
127.0.0.1:6379&gt; ZRANGEBYSCORE books 0 8.91 # 根据分数区间遍历zset
1) &quot;java cookbook&quot;
2) &quot;java concurrency&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE books -inf 8.91 # 根据分数区间遍历zset inf代表infinite,无穷大的意思
1) &quot;java cookbook&quot;
2) &quot;java concurrency&quot;
127.0.0.1:6379&gt; ZREM books &quot;think in java&quot; # 删除
(integer) 1
127.0.0.1:6379&gt; ZRANGE books 0 -1
1) &quot;java cookbook&quot;
2) &quot;java concurrency&quot;</code></pre>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（7）-Mysql锁</title>
    <url>/2019/04/02/Mysql%EF%BC%887%EF%BC%89-Mysql%E9%94%81/</url>
    <content><![CDATA[<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/mysql%E9%94%81.jpg" alt="Mysql锁"></p>
<p>数据库锁设计的初衷是处理并发问题。</p>
<p>Mysql加锁范围分类</p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p>
<p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。</p>
<p>官方自带的逻辑备份工具是mysqldump。当 mysqldump使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC的支持，这个过程中数据是可以正常更新的。</p>
<p>single-transaction方法只适用于所有的表使用事务引擎的库。对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
<p>既然要全库只读，为什么不使用 set global readonly=true 的方式呢？</p>
<p>确实，readonly方式也可以让全库进入只读状态，但还是会建议使用 FTWRL 方式，主要有两个原因：</p>
<p>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</p>
<p>二是，在异常处理机制上有差异。如果执行 FTWRL命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</p>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables主动释放锁，也可以在客户端断开的时候自动释放。</p>
<h2 id="元数据锁（meta-data-lock，MDL"><a href="#元数据锁（meta-data-lock，MDL" class="headerlink" title="元数据锁（meta data lock，MDL)"></a>元数据锁（meta data lock，MDL)</h2><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。</p>
<p>在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p>
<p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
<p>事务中的 MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p>如何安全地给小表加字段？</p>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在 MySQL 的 information_schema 库的 innodb_trx表中，你可以查到当前执行中的事务</span><br></pre></td></tr></table></figure>
<p>如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p>
<p>如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p>
<p>MariaDB 已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ...</span><br></pre></td></tr></table></figure>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。</p>
<p>InnoDB 支持行锁，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>
<h2 id="InnoDB-的行锁"><a href="#InnoDB-的行锁" class="headerlink" title="InnoDB 的行锁"></a>InnoDB 的行锁</h2><p>两阶段锁</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s.</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。<br>正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</li>
</ul>
<p>主动死锁监测：</p>
<p>当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
<p>怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 CPU 资源.<br>。</p>
<ul>
<li><p>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
</li>
<li><p>另一个思路是控制并发度。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。<br>因此，这个并发控制要做在数据库服务端。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。在中间件或者Mysql 源码中修。</p>
</li>
<li><p>通过业务层面实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（5）-数据库索引（必知必会）</title>
    <url>/2019/03/28/Mysql%EF%BC%885%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%88%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>二级索引已经“覆盖了”我们的查询需求，不需要再回表查整行记录，我们称为覆盖索引。</p>
<p>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>索引项是按照索引定义里面出现的字段顺序排序的。正因为如此根据最左前缀，我们找到第一条数据位置，然后遍历到最后一条匹配到最左前缀的就可以了（因为按照顺序相同最左前缀的都排在一块）。</p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<h3 id="在建立联合索引的时候，如何安排索引内的字段顺序。"><a href="#在建立联合索引的时候，如何安排索引内的字段顺序。" class="headerlink" title="在建立联合索引的时候，如何安排索引内的字段顺序。"></a>在建立联合索引的时候，如何安排索引内的字段顺序。</h3><p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。提高索引的复用能力，比如根据最左前缀原则，当已经有了 (a,b)这个联合索引后，一般就不需要单独在 a 上建立索引了。</p>
<p>第二原则，考虑的是空间。</p>
<p>如果a，b要建联合索引，且单查a或b的时候都要走索引，那么就要再a或b上再加一个索引，此时就要考虑空间。比如a字段b字段更占空间那就建一个（a，b）的联合索引和一个b的索引。</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>MySQL 5.6引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><p>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p>
<h3 id="重建二级索引索引"><a href="#重建二级索引索引" class="headerlink" title="重建二级索引索引"></a>重建二级索引索引</h3><p>alter table T drop index k;<br>alter table T add index(k);</p>
<h3 id="重建主键索引："><a href="#重建主键索引：" class="headerlink" title="重建主键索引："></a>重建主键索引：</h3><p>alter table T engine=InnoDB</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（6）-数据库索引（数据结构）</title>
    <url>/2019/03/28/Mysql%EF%BC%886%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<h2 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h2><p>索引是为了提高数据库的查询效率。</p>
<h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>三种简单的，比较常见的可以有效提高读写效率的数据结构：</p>
<ul>
<li>哈希表</li>
<li>有序数组</li>
<li>搜索树</li>
</ul>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是一种以键 - 值（key-value）存储数据的结构。</p>
<p>哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>哈希表这种结构适用于只有等值查询的场景。因为哈希值不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。</p>
<p>  有序的数组，可以用二分法快速查出指定值，时间复杂度是O(log(N))。同样区间查询也可以用二分法先找到前值，然后编辑到后值。</p>
<p>有序数组索引只适用于静态存储引擎。</p>
<p>  因为有序数组在需要更新数据的时候，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。</p>
<p>搜索指定节点的时间复杂度是O(log(N))。</p>
<p>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p>
<h3 id="N叉树（B树）"><a href="#N叉树（B树）" class="headerlink" title="N叉树（B树）"></a>N叉树（B树）</h3><p>多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。使用多叉树是为了降低树高，减少磁盘寻址次数。</p>
<p>数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<p>B树，就是一个N叉查找树。</p>
<h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在 MySQL 中，索引是在存储引擎层实现的。</p>
<p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p>
<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<h3 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h3><p>非主键索引，又称二级索引，二级索引里面存的是主键值。通过二级索引查询的时候，要先查寻二级索引的B+树，查到主键值，再查询主键索引的B+树，查找对应的记录，需要查两次，这个过程称为回表。</p>
<p>因此，我们在应用中应该尽量使用主键查询。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>InnoDB中，每一张表就是多棵B+树，主键索引key是主键值，叶子节点是整行数据。每加一个索引都会新建一棵B+树，key是索引值，叶子节点是主键值，所以二级索引查询要有回表过程。</p>
<h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维。</p>
<h3 id="推荐使用自增主键"><a href="#推荐使用自增主键" class="headerlink" title="推荐使用自增主键"></a>推荐使用自增主键</h3><ol>
<li><p>如果索引字段值是无序的，则可能需要挪动既有数据，会造成页分裂，或合并，影响性能。</p>
</li>
<li><p>二级索引的叶子节点存的是主键的索引值，所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
</li>
</ol>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<h3 id="业务字段做主键的场景"><a href="#业务字段做主键的场景" class="headerlink" title="业务字段做主键的场景"></a>业务字段做主键的场景</h3><ol>
<li>只有一个索引</li>
<li>该索引是唯一索引</li>
</ol>
<p>就是典型的 KV 场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（4）-事务的隔离性</title>
    <url>/2019/03/27/Mysql%EF%BC%884%EF%BC%89-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    <content><![CDATA[<p>在 MySQL 中，事务支持是在引擎层实现的。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>  当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>  SQL 标准的事务隔离级别包括：</p>
<ul>
<li><p>读未提交（read uncommitted）</p>
</li>
<li><p>读提交（read committed）</p>
</li>
<li><p>可重复读（repeatable read</p>
</li>
<li><p>串行化（serializable ）。</p>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p>
<p>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p>
<p>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>
<p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>查看数据库隔离级别:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;transaction_isolation&#39;;</span><br></pre></td></tr></table></figure>
<p>  设置数据库的隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<p>  事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
<h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。</p>
<h2 id="为什么建议你尽量不要使用长事务。"><a href="#为什么建议你尽量不要使用长事务。" class="headerlink" title="为什么建议你尽量不要使用长事务。"></a>为什么建议你尽量不要使用长事务。</h2><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库.</p>
<h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>MySQL 的事务启动方式有以下几种：</p>
<ol>
<li>显示的启动事务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin 或start transaction</span><br><span class="line">提交语句是commit</span><br><span class="line">回滚是rollback</span><br><span class="line">commit work and chain 提交事务并启动下一个事务</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将线程的自动提交关掉</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit&#x3D;0</span><br><span class="line">事务会持续到我们主动commit或rollback，或者断开连接</span><br></pre></td></tr></table></figure>

<p>查询系统中的长事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selselect * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure>

<h2 id="如何避免长事务？"><a href="#如何避免长事务？" class="headerlink" title="如何避免长事务？"></a>如何避免长事务？</h2><h3 id="应用开发层面"><a href="#应用开发层面" class="headerlink" title="应用开发层面"></a>应用开发层面</h3><ol>
<li><p>确认是否使用了set autocommit=0</p>
<p> 可以通过general_log的日志开确认，MySQL开启general_log跟踪sql执行记录：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置general log保存路径</span><br><span class="line"># 注意在Linux中只能设置到 &#x2F;tmp 或 &#x2F;var 文件夹下，设置其他路径出错</span><br><span class="line"># 需要root用户才有访问此文件的权限</span><br><span class="line"></span><br><span class="line">mysql&gt;set global general_log_file&#x3D;&#39;&#x2F;tmp&#x2F;general.log&#39;; #设置路径</span><br><span class="line">mysql&gt;set global general_log&#x3D;on;  # 开启general log模式</span><br><span class="line">mysql&gt;set global general_log&#x3D;off;   # 关闭general</span><br><span class="line"></span><br><span class="line">命令行设置即可,无需重启</span><br><span class="line">在general log模式开启过程中，所有对数据库的操作都将被记录 general.log 文件</span><br><span class="line"></span><br><span class="line">或者也可以将日志记录在表中:</span><br><span class="line">mysql&gt;set global log_output&#x3D;&#39;table&#39;</span><br><span class="line">运行后,可以在mysql数据库下查找 general_log表</span><br></pre></td></tr></table></figure></li>
<li><p>取消不必要的只读事务</p>
<p> 开发过程后，特别是使用Spring框架管理事务的时候，很多人习惯所有方法用@Transaction标注，把好几个selet语句放到事务中，这种只读事务有时是不需要的。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</p>
</li>
</ol>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ol>
<li><p>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</p>
</li>
<li><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（3）-redo日志和binlog日志</title>
    <url>/2019/03/26/Mysql%EF%BC%883%EF%BC%89-redo%E6%97%A5%E5%BF%97%E5%92%8Cbinlog%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="update语句执行过程"><a href="#update语句执行过程" class="headerlink" title="update语句执行过程"></a>update语句执行过程</h2><p>类似查询语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立连接,分析器分析是更新语句，清空缓存，优化器选取索引，执行器执行sql.</span><br></pre></td></tr></table></figure>

<p>与查询语句不同的是更新还涉及两个重要的日志模块</p>
<ul>
<li>binlog</li>
<li>redo log</li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>场景考虑：如果每次更新都操作进磁盘，磁盘找到对应的记录,然后更新。整个过程磁盘的IO成本，查找成本很高，这样做效率底下。Mysql为解决这个问题失踪了WAL技术：Write-Ahead Logging，关键点就是先写日志，空闲时再写磁盘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">技术点：WAL(Write-Ahead Logging)</span><br></pre></td></tr></table></figure>

<p>当有一条记录需要更新时，InnoDB会先将这条记录写到redo log里并更新内存，这个更新就算完成了。同时InnoDB会在空闲的时候将这个操作记录跟新到磁盘。</p>
<p>InnoDB的redo log大小是固定配置的。从头开始写，写到末尾后又回到开头写，注意两个关键的位置点：</p>
<ul>
<li>write pos – 当前记录的位置</li>
<li>Checkpoint – 当前要擦出的位置</li>
</ul>
<p>write pos和Checkpoint之间是空闲的位置，可以记录新的操作，如果write pos值追上Checkpoint值了，这时候不能继续执行新的更新，要先停下来擦掉一些记录，把checkpoint推进一些。</p>
<p>redo log使InnoDB具有了crash-safe能力.</p>
<p>redo log是InnoDB存储引擎特有的日志</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog 是server层的日志;</p>
<p>binlog日志只能用于归档;</p>
<p>InnoDB引擎执行update语句内部理流程</p>
<ol>
<li><p>将要改的数据读到内存</p>
</li>
<li><p>修改数据</p>
</li>
<li><p>将修改更新到内存，并更新到redo日志里 prepare</p>
</li>
<li><p>执行器生成binlog，并将binlog写入磁盘</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<p>两阶段提交：</p>
<p>上面的更新过程将redo log的写入拆成了连个个步骤，prepare和commit，这是为了让两份日志之间的逻辑一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redo log 用于保证 crash-safe 能力。</p>
<p>innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>
<p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><h3 id="为了保持两份日志逻辑的一致性，是怎么做到的？"><a href="#为了保持两份日志逻辑的一致性，是怎么做到的？" class="headerlink" title="为了保持两份日志逻辑的一致性，是怎么做到的？"></a>为了保持两份日志逻辑的一致性，是怎么做到的？</h3><p>通过两阶段提交：</p>
<ol>
<li>redo log 第一阶段写入</li>
<li>binlog写入</li>
<li>redo log第二阶段写入</li>
</ol>
<p>如果在redo log第二阶段写入时，mysql dowwn了，那么重启的的时候会检查binlog日志是否写入，写入了话，redo log会认为事务提交进行第二阶段写入，否则回滚。</p>
<p>这里有几个个概念要弄清楚：</p>
<ul>
<li>binlog是归档日志，属于server层日志，mysql并没有通过binlog去实现crash-safe的能力,它存在的意义是，我们可以通过binlog日志实现恢复数据库到某一刻的能力（取决于全库备份时间，和binlog日志保存的天数）。</li>
<li>InnoDB引擎的 的crash-safe能力 是通过redo log保证的，两阶段提交就是为了在提供cresh-safe的同时，保证binlog和redo log的一致性。binglog日志是可以单独关掉的，并不会影响innodb引擎的crash-safe能力</li>
</ul>
<h3 id="怎样将数据库恢复到一周前某一秒的状态？"><a href="#怎样将数据库恢复到一周前某一秒的状态？" class="headerlink" title="怎样将数据库恢复到一周前某一秒的状态？"></a>怎样将数据库恢复到一周前某一秒的状态？</h3><p>使用全量备份的库，配合binlog回放到要恢复的时间点。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-2：Nginx安装</title>
    <url>/2019/03/25/Nginx-2%EF%BC%9ANginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装nginx有两种方式：</p>
<ul>
<li>编译</li>
<li>使用操作系统商自带的工具比如Yarm、apt-get、yum 等直接安装Nginx。</li>
</ul>
<p>直接安装Nginx有个问题，无法安装第三方模块，安装第三方模块只能通过编译的方式安装。</p>
<h1 id="下载Nginx"><a href="#下载Nginx" class="headerlink" title="下载Nginx"></a>下载Nginx</h1><p>进入官网 <a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a> 找到download，点击进入。</p>
<p>nignx官方有两种版本：</p>
<ul>
<li>Mainline Version 主线版本</li>
<li>Stable Version 稳定版本</li>
</ul>
<p>下载最新nginx stable版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxf nginx-1.16.0.tar.gz</span><br></pre></td></tr></table></figure>

<h1 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h1><ul>
<li><p>conf</p>
<p>示例文件，方便配置的示例</p>
</li>
<li><p>configure</p>
<p>configure脚本，用来生成中间文件，执行编译前的必备动作</p>
</li>
<li><p>contrib</p>
<p>提供了一些工具，比如vim编辑nginx配置的高亮支持（将contrib/vim中的文件全部copy到~/.vim中即可）</p>
</li>
<li><p>html</p>
<p>提供了两个标准的html文件，50x.html和默认nginx欢迎界面index.html</p>
</li>
<li><p>src</p>
<p>nginx源码文件</p>
</li>
</ul>
<h1 id="configure介绍"><a href="#configure介绍" class="headerlink" title="configure介绍"></a>configure介绍</h1><p>查看configure脚本支持哪些参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --help|more</span><br></pre></td></tr></table></figure>

<p>主要分为三大类：</p>
<ul>
<li><p>nginx执行中会去哪些目录下的文件作为它的辅助的一些文件</p>
<p>比如–modules-path指定动态模块，通常我们只需要指定–prefix=PATH(安装目录)即可，其它的模块会在prefix指定的路径下建文件夹</p>
</li>
<li><p>第二类参数用来确定使用或者不使用哪些模块</p>
<p>–with开头的参数表示的模块，默认不会被编译进nginx</p>
<p>–without开头的模块，默认会被编译进nginx</p>
</li>
<li><p>第三类参数指定了nginx编译中的特殊参数</p>
<p>比如–with-debug表示需要打印级别的日志</p>
<p>编译nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>执行完configure脚本后会生成一些中间文件，这些文夹放在objs文件下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── autoconf.err</span><br><span class="line">├── Makefile</span><br><span class="line">├── ngx_auto_config.h</span><br><span class="line">├── ngx_auto_headers.h</span><br><span class="line">├── ngx_modules.c</span><br><span class="line">└── src</span><br><span class="line">    ├── core</span><br><span class="line">    ├── event</span><br><span class="line">    │   └── modules</span><br><span class="line">    ├── http</span><br><span class="line">    │   ├── modules</span><br><span class="line">    │   │   └── perl</span><br><span class="line">    │   └── v2</span><br><span class="line">    ├── mail</span><br><span class="line">    ├── misc</span><br><span class="line">    ├── os</span><br><span class="line">    │   ├── unix</span><br><span class="line">    │   └── win32</span><br><span class="line">    └── stream</span><br></pre></td></tr></table></figure>

<p>这里ngx_modules.c文件指定了哪些模块会被编译进nginx</p>
</li>
</ul>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#执行make编译</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>我们可以看到执行过程中生成了大量的中间文件，执行结束最终在objs中生成了可执行的nginx二进制文件</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果是升级安装，则把可执行的nginx二进制文件copy到安装文件即可。</p>
<p>如果是首次安装，则继续执行make install 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@192 nginx-1.16.0]$ make install</span><br><span class="line">make -f objs&#x2F;Makefile install</span><br><span class="line">make[1]: 进入目录“&#x2F;opt&#x2F;nginx-1.16.0”</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#39; || mkdir -p &#39;&#x2F;opt&#x2F;nginx&#39;</span><br><span class="line">mkdir: 无法创建目录 “&#x2F;opt&#x2F;nginx”: Permission denied</span><br><span class="line">make[1]: *** [objs&#x2F;Makefile:1206：install] 错误 1</span><br><span class="line">make[1]: 离开目录“&#x2F;opt&#x2F;nginx-1.16.0”</span><br><span class="line">make: *** [Makefile:11：install] 错误 2</span><br><span class="line">[richey@192 nginx-1.16.0]$ sudo make install</span><br><span class="line">[sudo] richey 的密码：</span><br><span class="line">make -f objs&#x2F;Makefile install</span><br><span class="line">make[1]: 进入目录“&#x2F;opt&#x2F;nginx-1.16.0”</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#39; || mkdir -p &#39;&#x2F;opt&#x2F;nginx&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#39; \</span><br><span class="line">	|| mkdir -p &#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#39;</span><br><span class="line">test ! -f &#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; \</span><br><span class="line">	|| mv &#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; \</span><br><span class="line">		&#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#x2F;nginx.old&#39;</span><br><span class="line">cp objs&#x2F;nginx &#39;&#x2F;opt&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39; \</span><br><span class="line">	|| mkdir -p &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;koi-win &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;koi-utf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;win-utf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;mime.types&#39; \</span><br><span class="line">	|| cp conf&#x2F;mime.types &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;mime.types &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;mime.types.default&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;fastcgi_params&#39; \</span><br><span class="line">	|| cp conf&#x2F;fastcgi_params &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;fastcgi_params \</span><br><span class="line">	&#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;fastcgi_params.default&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;fastcgi.conf&#39; \</span><br><span class="line">	|| cp conf&#x2F;fastcgi.conf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;fastcgi.conf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;fastcgi.conf.default&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;uwsgi_params&#39; \</span><br><span class="line">	|| cp conf&#x2F;uwsgi_params &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;uwsgi_params \</span><br><span class="line">	&#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;uwsgi_params.default&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;scgi_params&#39; \</span><br><span class="line">	|| cp conf&#x2F;scgi_params &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#39;</span><br><span class="line">cp conf&#x2F;scgi_params \</span><br><span class="line">	&#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;scgi_params.default&#39;</span><br><span class="line">test -f &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#39; \</span><br><span class="line">	|| cp conf&#x2F;nginx.conf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&#39;</span><br><span class="line">cp conf&#x2F;nginx.conf &#39;&#x2F;opt&#x2F;nginx&#x2F;conf&#x2F;nginx.conf.default&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39; \</span><br><span class="line">	|| mkdir -p &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39; \</span><br><span class="line">	|| mkdir -p &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;html&#39; \</span><br><span class="line">	|| cp -R html &#39;&#x2F;opt&#x2F;nginx&#39;</span><br><span class="line">test -d &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39; \</span><br><span class="line">	|| mkdir -p &#39;&#x2F;opt&#x2F;nginx&#x2F;logs&#39;</span><br><span class="line">make[1]: 离开目录“&#x2F;opt&#x2F;nginx-1.16.0”</span><br></pre></td></tr></table></figure>

<p>执行完之后，我们去–prefix指定的安装目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@192 nginx]$ tree</span><br><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── fastcgi.conf</span><br><span class="line">│   ├── fastcgi.conf.default</span><br><span class="line">│   ├── fastcgi_params</span><br><span class="line">│   ├── fastcgi_params.default</span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.conf</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params</span><br><span class="line">│   ├── scgi_params.default</span><br><span class="line">│   ├── uwsgi_params</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── html</span><br><span class="line">│   ├── 50x.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── logs</span><br><span class="line">└── sbin</span><br><span class="line">    └── nginx</span><br></pre></td></tr></table></figure>

<p>这里最主要的nginx的二进制文件就在sbin目录下，决定nginx功能的配置文件在conf目录下</p>
<p>以上就是nginx编译安装的全部步骤。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（2）-基本架构</title>
    <url>/2019/03/25/Mysql%EF%BC%882%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Mysql基本架构是什么样子的（简述Mysql基本架构）"><a href="#Mysql基本架构是什么样子的（简述Mysql基本架构）" class="headerlink" title="Mysql基本架构是什么样子的（简述Mysql基本架构）"></a>Mysql基本架构是什么样子的（简述Mysql基本架构）</h2><p>Mysql由服务层（Service层）和存储引擎层构成。</p>
<ul>
<li><p>Service层涵盖Mysql的大多数核心功能，及所有的内置函数</p>
<p>包含连接器、查询缓存、分析器、优化器、执行器；</p>
<p>所有跨存储引擎的功能都在这一层实现；</p>
</li>
<li><p>存储引擎层，负责数据的存储和提取</p>
<p>采用插件式设计，支持InnoDB、MYISAM、Memory等多个存储引擎；</p>
<p>建表时，如果不制定引擎类型，会默认使用InnoDB</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#指定存储引擎</span><br><span class="line">create table foo（id int primary key,name var(10) not null）engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>
<p>不同的存储引擎共用一个service层</p>
</li>
</ul>
<h2 id="Mysql由哪些组件组成-各个组件的作用是什么"><a href="#Mysql由哪些组件组成-各个组件的作用是什么" class="headerlink" title="Mysql由哪些组件组成,各个组件的作用是什么"></a>Mysql由哪些组件组成,各个组件的作用是什么</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>  负责跟客户端建立连接，获取权限，维持和管理连接；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mysql客户端工具连接</span><br><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>  客户端同服务端建立连接，在完成TCP握手后，连接器就开始认证身份，需要我们提供用户名密码；</p>
<p>  认证通过后，连接器会到权限表里查出所有你拥有的权限，之后这个连接里的所有权限判断，都将依赖于此时读到的权限。也就是说连接成功后权限就不会改变了，如果修改了权限，需要重新连接。</p>
<p>  关于连接的一些参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show processlist; --查看所有链接状态</span><br><span class="line"></span><br><span class="line">-- 查看mysql參數</span><br><span class="line">show variables like &quot;%timeout%&quot;；</span><br><span class="line">-- wait_timeout：设置非交互连接（就是指那些连接池方式、非客户端方式连接的）的超时时间，默认是28800，就是8小时，超过这个时间，mysql服务器会主动切断那些已经连接的，但是状态是sleep的连接。</span><br><span class="line"></span><br><span class="line">-- interactive_timeout:交互链接超时时间;</span><br><span class="line"></span><br><span class="line">-- connection_timeout：“连接过程中”的等待时间</span><br></pre></td></tr></table></figure>

<p>  建立连接的过程通常是比较复杂的，所以建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>  MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<pre><code>解决：
定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。

如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</code></pre><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>  键值对的形式，key是查询语句，valve是结果；</p>
<p>  查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p>
<p>  可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。</p>
<p>  MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p>
<p>  如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。</p>
<p>  关于查询缓存的一些参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">query_catche_size&#x3D;0; -- 最好设置为1024的倍数，参考值32M</span><br><span class="line">query_catch_type&#x3D;0; -- 0禁用 1缓存所有查询 2只缓存通过SQL_CACHE指定需要缓存的查询</span><br></pre></td></tr></table></figure>


<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>  词法分析；</p>
<pre><code>读取表定义，识别关键字及表和列信息等</code></pre><p>  语法分析；</p>
<pre><code>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</code></pre><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>  查询会在优化器之前调用 precheck 验证权限；</p>
<p>  选择索引，决定表的连接顺序。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>  权限检查；</p>
<p>  开表；</p>
<p>  重复调用表定义的引擎接口，直到表的最后一行，拿到所有满足条件的接口，组成结果集返回给客户端；</p>
<h2 id="Mysql权限是怎么控制的？"><a href="#Mysql权限是怎么控制的？" class="headerlink" title="Mysql权限是怎么控制的？"></a>Mysql权限是怎么控制的？</h2><p>  客户端通过认证后，会去权限表读取权限，此后所有的权限判断都基于此时读取的权限。除非重新连接，否则不会改变。</p>
<p>  命中缓存后，返回结果前会校验权限；</p>
<p>  优化器之前会调用precheck权限验证；</p>
<p>  执行器开表前会进行权限验证。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-3：Nginx中的正则表达式</title>
    <url>/2019/03/25/Nginx-3%EF%BC%9ANginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式可以让我们匹配的功能更加强大</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.   匹配除换行符之外的任意字符</span><br><span class="line">\w  匹配字母、数字、下划线或汉字</span><br><span class="line">\s  匹配任意的空白字符</span><br><span class="line">\d  匹配数字</span><br><span class="line">\b  匹配单词的开始或结束</span><br><span class="line">^   匹配字符串的开始</span><br><span class="line">$   匹配字符串的结束</span><br></pre></td></tr></table></figure>

<h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*      重复0次或多次</span><br><span class="line">+      重复1次或多次</span><br><span class="line">？     重复0次或1次</span><br><span class="line">&#123;n&#125;    重复n次</span><br><span class="line">&#123;n,&#125;   重复n次或更多次</span><br><span class="line">&#123;n,m&#125;  重复n到m次</span><br></pre></td></tr></table></figure>

<h1 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\: 取消元字符的特殊含义</span><br></pre></td></tr></table></figure>

<h1 id="分组与取值"><a href="#分组与取值" class="headerlink" title="分组与取值"></a>分组与取值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">():用来通过$方式取表达式中的值，或者进行分组</span><br></pre></td></tr></table></figure>

<h1 id="pcretest"><a href="#pcretest" class="headerlink" title="pcretest"></a>pcretest</h1><p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。我们可以通过pcretest工具来测试<br>我们写的正则表达式的可用性。</p>
<p>我们安装pcre-tools后就可以使用pcretools了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dnf install pcre-tools</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>原始url： /web/assets/view/salary/month-8/payslip/basicsalary.jpg<br>转换后的url： /web/assets/view/cnb-salary/payslip/basicsalary/month/8.jpg<br>匹配原始url的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^\&#x2F;web\&#x2F;assets\&#x2F;view\&#x2F;salary\&#x2F;(\w+)-(\d&#123;1,2&#125;)\&#x2F;payslip\&#x2F;(\w+)\.(png|jpg|gif|jpeg|bmp)$&#x2F;</span><br><span class="line"></span><br><span class="line">rewrite ^&#x2F;web&#x2F;assets&#x2F;view&#x2F;salary&#x2F;(\w+)-(\d&#123;1,2&#125;)&#x2F;payslip&#x2F;(\w+).(png|jpg|gif|jpeg|bmp)$  &#x2F;web&#x2F;assets&#x2F;view&#x2F;cnb-salary&#x2F;payslip&#x2F;$3&#x2F;$1&#x2F;$2.$4 last;</span><br></pre></td></tr></table></figure>
<p>我们通过pcretest进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[richey@192 ~]$ pcretest</span><br><span class="line">PCRE version 8.43 2019-02-23</span><br><span class="line"></span><br><span class="line">  re&gt; &#x2F;^\&#x2F;web\&#x2F;assets\&#x2F;view\&#x2F;salary\&#x2F;(\w+)-(\d&#123;1,2&#125;)\&#x2F;payslip\&#x2F;(\w+)\.(png|jpg|gif|jpeg|bmp)$&#x2F;</span><br><span class="line">data&gt; &#x2F;web&#x2F;assets&#x2F;view&#x2F;salary&#x2F;month-8&#x2F;payslip&#x2F;basicsalary.jpg</span><br><span class="line"> 0: &#x2F;web&#x2F;assets&#x2F;view&#x2F;salary&#x2F;month-8&#x2F;payslip&#x2F;basicsalary.jpg</span><br><span class="line"> 1: month</span><br><span class="line"> 2: 8</span><br><span class="line"> 3: basicsalary</span><br><span class="line"> 4: jpg</span><br></pre></td></tr></table></figure>
<p>可以看到通过正则表达式（）匹配到的各个值，然后就可以通过$1,$2…的方式使用这些值，达到rewrite的目的。</p>
<p>注意在nginx中使用正则表达式是不需要使用反斜杠转义的，这里是为了在pcretest中测试</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）</title>
    <url>/2019/03/23/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%EF%BC%88ASCII-Unicode-Utf-8-GB2312%E2%80%A6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="本文转自http-www-imkevinyang-com"><a href="#本文转自http-www-imkevinyang-com" class="headerlink" title="本文转自http://www.imkevinyang.com"></a>本文转自<a href="http://www.imkevinyang.com" target="_blank" rel="noopener">http://www.imkevinyang.com</a></h2><p>字符编码的问题看似很小，经常被技术人员忽视，但是很容易导致一些莫名其妙的问题。这里总结了一下字符编码的一些普及性的知识，希望对大家有所帮助。</p>
<p>还是得从ASCII码说起</p>
<p>说到字符编码，不得不说ASCII码的简史。计算机一开始发明的时候是用来解决数字计算的问题，后来人们发现，计算机还可以做更多的事，例如文本处理。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符，例如65代表字母‘A’，66代表字母‘B’，以此类推。但是计算机之间字符-数字的对应关系必须得一致，否则就会造成同一段数字在不同计算机上显示出来的字符不一样。因此美国国家标准协会ANSI制定了一个标准，规定了常用字符的集合以及每个字符对应的编号，这就是ASCII字符集（Character Set），也称ASCII码。</p>
<p>当时的计算机普遍使用8比特字节作为最小的存储和处理单元，加之当时用到的字符也很少，26个大小写英文字母还有数字再加上其他常用符号，也不到100个，因此使用7个比特位就可以高效的存储和处理ASCII码，剩下最高位1比特被用作一些通讯系统的奇偶校验。</p>
<p>注意，字节代表系统能够处理的最小单位，不一定是8比特。只是现代计算机的事实标准就是用8比特来代表一个字节。在很多技术规格文献中，为了避免产生歧义，更倾向于使用8位组（Octet）而不是字节（Byte）这个术语来强调8个比特的二进制流。下文中为了便于理解，我会延用大家熟悉的“字节”这个概念。</p>
<p>ASCII字符集由95个可打印字符（0x20-0x7E）和33个控制字符（0x00-0x19，0x7F）组成。可打印字符用于显示在输出设备上，例如荧屏或者打印纸上，控制字符用于向计算机发出一些特殊指令，例如0x07会让计算机发出哔的一声，0x00通常用于指示字符串的结束，0x0D和0x0A用于指示打印机的打印针头退到行首（回车）并移到下一行（换行）。</p>
<p>那时候的字符编解码系统非常简单，就是简单的查表过程。例如将字符序列编码为二进制流写入存储设备，只需要在ASCII字符集中依次找到字符对应的字节，然后直接将该字节写入存储设备即可。解码二进制流的过程也是类似。</p>
<p>OEM字符集的衍生</p>
<p>当计算机开始发展起来的时候，人们逐渐发现，ASCII字符集里那可怜的128个字符已经不能再满足他们的需求了。人们就在想，一个字节能够表示的数字（编号）有256个，而ASCII字符只用到了0x00~0x7F，也就是占用了前128个，后面128个数字不用白不用，因此很多人打起了后面这128个数字的主意。可是问题在于，很多人同时有这样的想法，但是大家对于0x80-0xFF这后面的128个数字分别对应什么样的字符，却有各自的想法。这就导致了当时销往世界各地的机器上出现了大量各式各样的OEM字符集。</p>
<p>下面这张表是IBM-PC机推出的其中一个OEM字符集，字符集的前128个字符和ASCII字符集的基本一致（为什么说基本一致呢，是因为前32个控制字符在某些情况下会被IBM-PC机当作可打印字符解释），后面128个字符空间加入了一些欧洲国家用到的重音字符，以及一些用于画线条画的字符。</p>
<p>事实上，大部分OEM字符集是兼容ASCII字符集的，也就是说，大家对于0x00<del>0x7F这个范围的解释基本是相同的，而对于后半部分0x80</del>0xFF的解释却不一定相同。甚至有时候同样的字符在不同OEM字符集中对应的字节也是不同的。</p>
<p>不同的OEM字符集导致人们无法跨机器交流各种文档。例如职员甲发了一封简历résumés给职员乙，结果职员乙看到的却是r</p>
<p>sum</p>
<p>s，因为é字符在职员甲机器上的OEM字符集中对应的字节是0x82，而在职员乙的机器上，由于使用的OEM字符集不同，对0x82字节解码后得到的字符却是</p>
<p>。</p>
<p>多字节字符集（MBCS）和中文字符集</p>
<p>上面我们提到的字符集都是基于单字节编码，也就是说，一个字节翻译成一个字符。这对于拉丁语系国家来说可能没有什么问题，因为他们通过扩展第8个比特，就可以得到256个字符了，足够用了。但是对于亚洲国家来说，256个字符是远远不够用的。因此这些国家的人为了用上电脑，又要保持和ASCII字符集的兼容，就发明了多字节编码方式，相应的字符集就称为多字节字符集。例如中国使用的就是双字节字符集编码（DBCS，Double Byte Character Set）。</p>
<p>对于单字节字符集来说，代码页中只需要有一张码表即可，上面记录着256个数字代表的字符。程序只需要做简单的查表操作就可以完成编解码的过程。</p>
<p>代码页是字符集编码的具体实现，你可以把他理解为一张“字符-字节”映射表，通过查表实现“字符-字节”的翻译。下面会有更详细的描述。</p>
<p>而对于多字节字符集，代码页中通常会有很多码表。那么程序怎么知道该使用哪张码表去解码二进制流呢？答案是，根据第一个字节来选择不同的码表进行解析。</p>
<p>例如目前最常用的中文字符集GB2312，涵盖了所有简体字符以及一部分其他字符；GBK（K代表扩展的意思）则在GB2312的基础上加入了对繁体字符等其他非简体字符（GB18030字符集不是双字节字符集，我们在讲Unicode的时候会提到）。这两个字符集的字符都是使用1-2个字节来表示。Windows系统采用936代码页来实现对GBK字符集的编解码。在解析字节流的时候，如果遇到字节的最高位是0的话，那么就使用936代码页中的第1张码表进行解码，这就和单字节字符集的编解码方式一致了。</p>
<p>当字节的高位是1的时候，确切的说，当第一个字节位于0x81–0xFE之间时，根据第一个字节不同找到代码页中的相应的码表，例如当第一个字节是0x81，那么对应936中的下面这张码表：</p>
<p>（关于936代码页中完整的码表信息，参见MSDN：<a href="http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx.）" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx.）</a></p>
<p>按照936代码页的码表，当程序遇到连续字节流0x81 0x40的时候，就会解码为“丂”字符。</p>
<p>ANSI标准、国家标准、ISO标准</p>
<p>不同ASCII衍生字符集的出现，让文档交流变得非常困难，因此各种组织都陆续进行了标准化流程。例如美国ANSI组织制定了ANSI标准字符编码（注意，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK），ISO组织制定的各种ISO标准字符编码，还有各国也会制定一些国家标准字符集，例如中国的GBK，GB2312和GB18030。</p>
<p>操作系统在发布的时候，通常会往机器里预装这些标准的字符集还有平台专用的字符集，这样只要你的文档是使用标准字符集编写的，通用性就比较高了。例如你用GB2312字符集编写的文档，在中国大陆内的任何机器上都能正确显示。同时，我们也可以在一台机器上阅读多个国家不同语言的文档了，前提是本机必须安装该文档使用的字符集。</p>
<p>Unicode的出现</p>
<p>虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然无法解决一个问题：在一份文档中显示所有字符。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。</p>
<p>Unicode字符集概述</p>
<p>Unicode字符集涵盖了目前人类使用的所有字符，并为每个字符进行统一编号，分配唯一的字符码（Code Point）。Unicode字符集将所有字符按照使用上的频繁度划分为17个层面（Plane），每个层面上有216=65536个字符码空间。</p>
<p>其中第0个层面BMP，基本涵盖了当今世界用到的所有字符。其他的层面要么是用来表示一些远古时期的文字，要么是留作扩展。我们平常用到的Unicode字符，一般都是位于BMP层面上的。目前Unicode字符集中尚有大量字符空间未使用。</p>
<p>编码系统的变化</p>
<p>在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，都是直接将字符和最终字节流绑定死了，例如ASCII编码系统规定使用7比特来编码ASCII字符集；GB2312以及GBK字符集，限定了使用最多2个字节来编码所有字符，并且规定了字节序。这样的编码系统通常用简单的查表，也就是通过代码页就可以直接将字符映射为存储设备上的字节流了。例如下面这个例子：</p>
<p>这种方式的缺点在于，字符和字节流之间耦合得太紧密了，从而限定了字符集的扩展能力。假设以后火星人入住地球了，要往现有字符集中加入火星文就变得很难甚至不可能了，而且很容易破坏现有的编码规则。</p>
<p>因此Unicode在设计上考虑到了这一点，将字符集和字符编码方案分离开。</p>
<p>也就是说，虽然每个字符在Unicode字符集中都能找到唯一确定的编号（字符码，又称Unicode码），但是决定最终字节流的却是具体的字符编码。例如同样是对Unicode字符“A”进行编码，UTF-8字符编码得到的字节流是0x41，而UTF-16（大端模式）得到的是0x00 0x41。</p>
<p>常见的Unicode编码</p>
<p>UCS-2/UTF-16</p>
<p>如果要我们来实现Unicode字符集中BMP字符的编码方案，我们会怎么实现？由于BMP层面上有216=65536个字符码，因此我们只需要两个字节就可以完全表示这所有的字符了。</p>
<p>举个例子，“中”的Unicode字符码是0x4E2D(01001110 00101101)，那么我们可以编码为01001110 00101101（大端）或者00101101 01001110 （小端）。</p>
<p>UCS-2和UTF-16对于BMP层面的字符均是使用2个字节来表示，并且编码得到的结果完全一致。不同之处在于，UCS-2最初设计的时候只考虑到BMP字符，因此使用固定2个字节长度，也就是说，他无法表示Unicode其他层面上的字符，而UTF-16为了解除这个限制，支持Unicode全字符集的编解码，采用了变长编码，最少使用2个字节，如果要编码BMP以外的字符，则需要4个字节结对，这里就不讨论那么远，有兴趣可以参考维基百科：UTF-16/UCS-2。</p>
<p>Windows从NT时代开始就采用了UTF-16编码，很多流行的编程平台，例如.Net，Java，Qt还有Mac下的Cocoa等都是使用UTF-16作为基础的字符编码。例如代码中的字符串，在内存中相应的字节流就是用UTF-16编码过的。</p>
<p>UTF-8</p>
<p>UTF-8应该是目前应用最广泛的一种Unicode编码方案。由于UCS-2/UTF-16对于ASCII字符使用两个字节进行编码，存储和处理效率相对低下，并且由于ASCII字符经过UTF-16编码后得到的两个字节，高字节始终是0x00，很多C语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。因此一开始推出的时候遭到很多西方国家的抵触，大大影响了Unicode的推行。后来聪明的人们发明了UTF-8编码，解决了这个问题。</p>
<p>UTF-8编码方案采用1-4个字节来编码字符，方法其实也非常简单。</p>
<p>（上图中的x代表Unicode码的低8位，y代表高8位）</p>
<p>对于ASCII字符的编码使用单字节，和ASCII编码一摸一样，这样所有原先使用ASCII编解码的文档就可以直接转到UTF-8编码了。对于其他字符，则使用2-4个字节来表示，其中，首字节前置1的数目代表正确解析所需要的字节数，剩余字节的高2位始终是10。例如首字节是1110yyyy，前置有3个1，说明正确解析总共需要3个字节，需要和后面2个以10开头的字节结合才能正确解析得到字符。</p>
<p>关于UTF-8的更多信息，参考维基百科：UTF-8。</p>
<p>GB18030</p>
<p>任何能够将Unicode字符映射为字节流的编码都属于Unicode编码。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。只不过他的编码方式并不像UTF-8或者UTF-16一样，将Unicode字符的编号通过一定的规则进行转换，而只能通过查表的手段进行编码。</p>
<p>关于GB18030的更多信息，参考：GB18030。</p>
<p>Unicode相关的常见问题</p>
<p>Unicode是两个字节吗？</p>
<p>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储为什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-16和UTF-8。</p>
<p>带签名的UTF-8指的是什么意思？</p>
<p>带签名指的是字节流以BOM标记开始。很多软件会“智能”的探测当前字节流使用的字符编码，这种探测过程出于效率考虑，通常会提取字节流前面若干个字节，看看是否符合某些常见字符编码的编码规则。由于UTF-8和ASCII编码对于纯英文的编码是一样的，无法区分开来，因此通过在字节流最前面添加BOM标记可以告诉软件，当前使用的是Unicode编码，判别成功率就十分准确了。但是需要注意，不是所有软件或者程序都能正确处理BOM标记，例如PHP就不会检测BOM标记，直接把它当普通字节流解析了。因此如果你的PHP文件是采用带BOM标记的UTF-8进行编码的，那么有可能会出现问题。</p>
<p>Unicode编码和以前的字符集编码有什么区别？</p>
<p>早期字符编码、字符集和代码页等概念都是表达同一个意思。例如GB2312字符集、GB2312编码，936代码页，实际上说的是同个东西。但是对于Unicode则不同，Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）。</p>
<p>乱码问题</p>
<p>乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量</p>
<p>或者?。乱码问题是所有计算机用户或多或少会遇到的问题。造成乱码的原因就是因为使用了错误的字符编码去解码字节流，因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么。只有这样，我们才能正确分析和处理乱码问题。</p>
<p>例如最常见的网页乱码问题。如果你是网站技术人员，遇到这样的问题，需要检查以下原因：<br>服务器返回的响应头Content-Type没有指明字符编码<br>网页内是否使用META HTTP-EQUIV标签指定了字符编码<br>网页文件本身存储时使用的字符编码和网页声明的字符编码是否一致</p>
<p>注意，网页解析的过程如果使用的字符编码不正确，还可能会导致脚本或者样式表出错。具体细节可以参考我以前写过的文章：文档字符集导致的脚本错误和Asp.Net页面的编码问题。</p>
<p>不久前看到某技术论坛有人反馈，WinForm程序使用Clipboard类的GetData方法去访问剪切板中的HTML内容时会出现乱码的问题，我估计也是由于WinForm在获取HTML文本的时候没有用对正确的字符编码导致的。Windows剪贴板只支持UTF-8编码，也就是说你传入的文本都会被UTF-8编解码。这样一来，只要两个程序都是调用Windows剪切板API编程的话，那么复制粘贴的过程中不会出现乱码。除非一方在获取到剪贴板数据之后使用了错误的字符编码进行解码，才会得到乱码（我做了简单的WinForm剪切板编程实验，发现GetData使用的是系统默认编码，而不是UTF-8编码）。</p>
<p>关于乱码中出现?或者?，这里需要额外提一下，当程序使用特定字符编码解析字节流的时候，一旦遇到无法解析的字节流时，就会用</p>
<p>或者?来替代。因此，一旦你最终解析得到的文本包含这样的字符，而你又无法得到原始字节流的时候，说明正确的信息已经彻底丢失了，尝试任何字符编码都无法从这样的字符文本中还原出正确的信息来。</p>
<p>必要的术语解释</p>
<p>字符集（Character Set），字面上的理解就是字符的集合，例如ASCII字符集，定义了128个字符；GB2312定义了7445个字符。而计算机系统中提到的字符集准确来说，指的是已编号的字符的有序集合（不一定是连续）。</p>
<p>字符码（Code Point）指的就是字符集中每个字符的数字编号。例如ASCII字符集用0-127这连续的128个数字分别表示128个字符；GBK字符集使用区位码的方式为每个字符编号，首先定义一个94X94的矩阵，行称为“区”，列称为“位”，然后将所有国标汉字放入矩阵当中，这样每个汉字就可以用唯一的“区位”码来标识了。例如“中”字被放到54区第48位，因此字符码就是5448。而Unicode中将字符集按照一定的类别划分到0~16这17个层面（Planes）中，每个层面中拥有216=65536个字符码，因此Unicode总共拥有的字符码，也即是Unicode的字符空间总共有17*65536=1114112。</p>
<p>编码的过程是将字符转换成字节流。</p>
<p>解码的过程是将字节流解析为字符。</p>
<p>字符编码（Character Encoding）是将字符集中的字符码映射为字节流的一种具体实现方案。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符。例如‘A’的编号是65，用单字节表示就是0x41，因此写入存储设备的时候就是b’01000001’。GBK编码则是将区位码（GBK的字符码）中的区码和位码的分别加上0xA0（160）的偏移（之所以要加上这样的偏移，主要是为了和ASCII码兼容），例如刚刚提到的“中”字，区位码是5448，十六进制是0x3630，区码和位码分别加上0xA0的偏移之后就得到0xD6D0，这就是“中”字的GBK编码结果。</p>
<p>代码页（Code Page）一种字符编码具体形式。早期字符相对少，因此通常会使用类似表格的形式将字符直接映射为字节流，然后通过查表的方式来实现字符的编解码。现代操作系统沿用了这种方式。例如Windows使用936代码页、Mac系统使用EUC-CN代码页实现GBK字符集的编码，名字虽然不一样，但对于同一汉字的编码肯定是一样的。</p>
<p>大小端的说法源自《格列佛游记》。我们知道，鸡蛋通常一端大一端小，小人国的人们对于剥蛋壳时应从哪一端开始剥起有着不一样的看法。同样，计算机界对于传输多字节字（由多个字节来共同表示一个数据类型）时，是先传高位字节（大端）还是先传低位字节（小端）也有着不一样的看法，这就是计算机里头大小端模式的由来了。无论是写文件还是网络传输，实际上都是往流设备进行写操作的过程，而且这个写操作是从流的低地址向高地址开始写（这很符合人的习惯），对于多字节字来说，如果先写入高位字节，则称作大端模式。反之则称作小端模式。也就是说，大端模式下，字节序和流设备的地址顺序是相反的，而小端模式则是相同的。一般网络协议都采用大端模式进行传输，windows操作系统采用Utf-16小端模式。</p>
<p>——Kevin Yang</p>
<p>参考链接：<br>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)<br><a href="http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html" target="_blank" rel="noopener">http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html</a><br><a href="http://en.wikipedia.org/wiki/Universal_Character_Set" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Universal_Character_Set</a><br><a href="http://en.wikipedia.org/wiki/Code_page" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Code_page</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-1：基本概念</title>
    <url>/2019/03/20/Nginx-1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Nginx组成"><a href="#Nginx组成" class="headerlink" title="Nginx组成"></a>Nginx组成</h1><h2 id="Ngnix二进制可执行文件"><a href="#Ngnix二进制可执行文件" class="headerlink" title="Ngnix二进制可执行文件"></a>Ngnix二进制可执行文件</h2><p>由各模块源码编译出来的一个文件</p>
<h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><p>控制Nginx的行为</p>
<h2 id="access-log访问日志"><a href="#access-log访问日志" class="headerlink" title="access.log访问日志"></a>access.log访问日志</h2><p>记录每一条http请求信息，可以进行运营和运维分析</p>
<h2 id="error-log错误日志"><a href="#error-log错误日志" class="headerlink" title="error.log错误日志"></a>error.log错误日志</h2><p>定位问题</p>
<h1 id="默认安装位置"><a href="#默认安装位置" class="headerlink" title="默认安装位置"></a>默认安装位置</h1><pre><code>/usr/local/nginx</code></pre><h1 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h1><ul>
<li><p>启动 nginx</p>
<ul>
<li>直接执行nginx二进制文件 /usr/local/nginx/sbin/nginx</li>
<li>指定配置文件的启动方式 /usr/local/nginx/sbin/nginx -c /tmp/nginx.conf</li>
<li>使用-p指定nginx的安装目录</li>
<li>采用Systemd初始化系统的Linux系统：systemctl start nginx.service</li>
<li>采用upstart初始化系统的Linux系统：initctl start nginx</li>
<li>采用SYSVINIT初始化系统的Linux系统：service nginx start</li>
</ul>
</li>
<li><p>关闭 ngixn</p>
<p>  当nginx实例运行时，可以通过发送相应的信号来管理它：</p>
<ul>
<li><p>stop - 快速关闭<br>  二进制文件路径/nginx -s stop<br>  kill -s SIGTERM pid<br>  kill -s SIGINT pid</p>
</li>
<li><p>quit - 优雅关闭 (等待 worker 线程完成处理)<br>  二进制文件路径/nginx -s qeuit<br>  kill -s SIGQUIT <nginx master pid><br>  kill -s SIGQUIT <nginx worker pid>  如果只优雅的关闭一个worker进程</p>
</li>
<li><p>reload - 重载配置文件<br>  二进制文件路径/nginx -s reload<br>  kill -s SIGHUB <nginx master pid></p>
</li>
<li><p>reopen - 重新打开日志文件<br>  二进制文件路径/nginx -s reopen<br>  kill -s SIGUSR1 <nginx master pid></p>
</li>
</ul>
</li>
</ul>
<h1 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h1><p>nginx 的配置文件，默认的位置包括：</p>
<pre><code>/etc/nginx/nginx.conf,
/usr/local/etc/nginx/nginx.conf
/usr/local/nginx/conf/nginx.conf</code></pre><h1 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h1><p>在Nginx内部，你可以指定多个虚拟服务器，每个虚拟服务器用 server{} 上下文描述。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SeLinux</title>
    <url>/2019/03/20/SeLinux/</url>
    <content><![CDATA[<p>一、关闭SeLinux</p>
<p>查看SELinux状态：</p>
<p>1、/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态</p>
<p>SELinux status:                 enabled</p>
<p>2、getenforce                 ##也可以用这个命令检查</p>
<p>关闭SELinux：</p>
<p>1、临时关闭（不用重启机器）：</p>
<p>setenforce 0                  ##设置SELinux 成为permissive模式</p>
<p>##setenforce 1 设置SELinux 成为enforcing模式</p>
<p>2、修改配置文件需要重启机器：</p>
<p>修改/etc/selinux/config 文件</p>
<p>将SELINUX=enforcing改为SELINUX=disabled</p>
<p>重启机器即可</p>
<p>二、执行下面的命令</p>
<p>setsebool -P httpd_can_network_connect 1</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux笔记</title>
    <url>/2019/03/18/Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1、安装规划"><a href="#1、安装规划" class="headerlink" title="1、安装规划"></a>1、安装规划</h1><ul>
<li><p>必须要有的两个分区为根分区和swap分区</p>
</li>
<li><p>交换分区是一个特殊的分区，相当于windows下的虚拟分区，一般设为物理内存的两倍，但是建议不要超过8GB</p>
</li>
</ul>
<h1 id="2、用户"><a href="#2、用户" class="headerlink" title="2、用户"></a>2、用户</h1><ul>
<li><p>确认自己的UID</p>
<pre><code>id</code></pre></li>
<li><p>确认自己所属的用户组</p>
<pre><code>groups</code></pre></li>
<li><p>查看用户信息</p>
<pre><code>users、who、w</code></pre></li>
<li><p>调查用户</p>
<pre><code>finger richey</code></pre></li>
<li><p>切换用户</p>
<pre><code>su - //加-是用户环境一块切换

sudo  //不切换用户直接以root身份执行</code></pre></li>
</ul>
<blockquote>
<p>在演示sudo命令前，首先要编辑/etc/sudoers这个配置文件<br>linux专门提供里visudo来编辑这个文件<br>添加 richey  ALL=(ALL)  ALL<br>richey  ALL=(ALL)  NOPASSWD:ALL  这样设置就不需要输密码了</p>
</blockquote>
<ul>
<li><p>修改用户组</p>
<p>  usermod -g root richey 将用户添加到用户组，即拥有root权限</p>
</li>
</ul>
<h1 id="3、帐号管理"><a href="#3、帐号管理" class="headerlink" title="3、帐号管理"></a>3、帐号管理</h1><ul>
<li><p>添加新用户</p>
<pre><code>useradd</code></pre></li>
<li><p>修改密码</p>
<pre><code>passwd</code></pre></li>
<li><p>删除用户</p>
<pre><code>userdel</code></pre></li>
<li><p>添加用户组</p>
<pre><code>groupadd</code></pre></li>
<li><p>删除用户组</p>
<pre><code>groupdel</code></pre></li>
</ul>
<ul>
<li><p>demo:添加一个用户richey，并且将其用户组改为root（即赋予root权限）</p>
<p>  useradd richey</p>
<p>  usermod -g root richey   执行该命令时可能需要先将richey添加到/etc/sudoers这个配置文件</p>
</li>
</ul>
<h1 id="4、例行任务管理"><a href="#4、例行任务管理" class="headerlink" title="4、例行任务管理"></a>4、例行任务管理</h1><ul>
<li><p>单一时刻执行一次任务：==at==</p>
<pre><code>[richey@192 ~]$ at now +30 minutes  //从现在开始，30分钟后安排一个任务
warning: commands will be executed using /bin/sh
at&gt; /sbin/shutdown -h now  //到时间后执行关机操作
at&gt; &lt;EOT&gt;   //这不是手输入的，而是组合键Ctrl+D，表示输入结束
job 4 at Sun Aug 13 23:21:00 2017</code></pre></li>
</ul>
<pre><code>at 00:00 2017-08-13   //可以设置具体时间</code></pre><ul>
<li>查看当前使用at命令调度的任务列表：atq</li>
</ul>
<ul>
<li><p>atrm 删除任务</p>
<pre><code>atrm 1 //删除标号为1的任务</code></pre></li>
<li><p>周期性执行任务：cron</p>
<ul>
<li><p>首先确认crond进程在运行，如果没有，需要先运行该进程</p>
<pre><code>service crond start</code></pre></li>
</ul>
</li>
</ul>
<h1 id="5、文件相关操作"><a href="#5、文件相关操作" class="headerlink" title="5、文件相关操作"></a>5、文件相关操作</h1><ul>
<li><p>touch    </p>
<p>  如果用touch命令创建文件的时候，当前目录中已经存在了这个文件，那么这个命令不会对当前文件造成影响。它不会修改文件的内容，但是会更新文件的创建时间属性。</p>
<p>  在linux中文件也是一种目录，所以touch一个目录，这个目录的创建时间也会被更新</p>
<p>  可利用touch的这种特性生成时间戳文件，进行差异化备份    </p>
<pre><code>touch time_stamp</code></pre></li>
<li><p>cat</p>
<pre><code>cat foo.log

cat -n foo.log   //加上-n参数可以显示行号</code></pre></li>
</ul>
<ul>
<li><p>head 查看头文件</p>
<pre><code>head foo.log   //默认显示10行内容

head -n 20 foo.log  //-n 参数指定显示的行数</code></pre></li>
</ul>
<ul>
<li><p>tail 查看文件尾    </p>
<pre><code>tail foo.log   //默认显示10行内容

tail -n 20 foo.log    //-n 参数指定显示的行数

tail -f foo.log   //动态查看文件尾</code></pre></li>
<li><p>dos2unix 文件格式转换</p>
</li>
</ul>
<ul>
<li><p>mkdir     </p>
<pre><code>mkdir -p dir1/dir2  //-p参数一次性创建所有目录</code></pre></li>
</ul>
<ul>
<li><p>lsattr 显示文件的隐藏属性</p>
<pre><code>lsattr foo.log  //默认隐藏属性都是没有设置的</code></pre></li>
<li><p>chattr 设置文件的隐藏属性    </p>
<p>  常用隐藏属性</p>
<ul>
<li><p>a属性 拥有这种属性的文件只能在尾部增数据而不能被删除</p>
<pre><code>chattr +a foo.log  //设置了a属性即便是root用户也不能删除它    </code></pre></li>
<li><p>i属性 设置了这种权限的文件将无法写入、删除、改名，即使root用户也不行，这总属性常用于设置在系统或关键服务中的配置文件。</p>
<pre><code>chattr +i foo.log</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>chmod 改变文件权限</p>
<ul>
<li><p>每个文件都定义了拥有者（user）、拥有组（group）、其他人（other）的权限  </p>
</li>
<li><p>r=4  w=2 x=1</p>
</li>
<li><p>-R 递归修改所有文件权限</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://orybhlel7.bkt.clouddn.com/image/jpg/weread_image_788589565193717.jpeg" alt="image"></p>
<ul>
<li><p>chown 改变文件拥有者（拥有组）</p>
<pre><code>chown richey foo.log //将foo.log的所有者该为richey    

chown :richey foo.log //将foo.log文件改为richey用户组

chown richey:richey foo.log</code></pre></li>
<li><p>chgrp 改变文件的拥有组</p>
<pre><code>chgrp richey foo.log  //将foo.log文件的所属组改为richey</code></pre></li>
</ul>
<ul>
<li><p>特殊文件属性SUID/SGID/Sticky</p>
<p>  SUID : 设置了SUID权限的，意味着普通用户可以用root身份来执行这个命令，SUID权限只能用于二进制文件。</p>
<pre><code>chmod u+s somefile</code></pre><p>  SGID : 如果某个二进制文件的用户组设置了SGID权限，那么该组的所有用户都可以用root身份执行该文件。</p>
<pre><code>chmod g+s somefile</code></pre><p>  Sticky : Sticky权限只能设置在目录上，设置了这种权限的目录，任何用户都可以在该目录中创建和修改文件，但是只有文件的创建者和root用户可以删除自己的文件。</p>
<pre><code>chmod o +t somedir //权限部分的最后是t</code></pre></li>
<li><p>file 查看文件类型</p>
<pre><code>file somefile</code></pre></li>
<li><p>查找文件   </p>
<ul>
<li><p>一般查找：find    </p>
<pre><code>find PATH -name FILENAME

find / -name httpd.conf //查找一个名为httpd.conf的文件

find / -name *.conf  //通配符查找    </code></pre></li>
</ul>
</li>
</ul>
<pre><code>    ![image](http://orybhlel7.bkt.clouddn.com/image/jpg/weread_image_879160622465831.jpeg)    

* 数据库查找

    updatedb //查询前可更新下数据库，但者不是必须的，系统每天会自动更新

    locate httpd.conf    

* 查找执行文件：which/whereis

    which用于从系统PATH定义的目录中查找可执行文件的绝对路径    

        which passwd

    whereis也能查到路径，而且还能找到相关的man文件

        whereis passwd</code></pre><ul>
<li><p>文件压缩打包</p>
<ul>
<li><p>gzip/gunzip</p>
<pre><code>gzip foo.log    

gunzip foo.log.gz</code></pre></li>
<li><p>tar 不但可以打包文件，还可以将真个目录中的文件合成一个包，这个合包的同时还可以用gzip命令进行压缩。</p>
<p>  一般整合后的包习惯用.tar作为后缀    </p>
<p>  使用gzip压缩后的文件则使用.gz作为后缀    </p>
<p>  同时整合和压缩后的文件可以使用.tar.gz作为后缀，或者简写为.tgz    </p>
<pre><code>tar -zcvf  boot.tgz /boot // -z 使用gzip压缩  -c创建压缩文件（create） -v显示当前被压缩的文件   -f 指定使用的文件名（boot.tgz)

tar -zxvf boot.tgz

tar -zxvf boot.tgz -C /tmp //-C 指定压缩后的目录存放位置</code></pre></li>
<li><p>bzip2</p>
<p>  使用bzip2压缩文件时默认会产生.bz扩展名结尾的文件</p>
<p>  使用-z 参数进行压缩</p>
<p>  使用-d 参数进行解压</p>
</li>
<li><p>cpio</p>
<p>  该命令一般配合find命令一起使用，通过管道的方式进行压缩备份及还原</p>
</li>
</ul>
</li>
</ul>
<h1 id="6、磁盘分区、创建文件系统、挂载"><a href="#6、磁盘分区、创建文件系统、挂载" class="headerlink" title="6、磁盘分区、创建文件系统、挂载"></a>6、磁盘分区、创建文件系统、挂载</h1><ul>
<li><p>磁盘使用前要对其进行分割，这种操作被称为分区    </p>
</li>
<li><p>磁盘的分区分为两类：主分区和扩展分区</p>
</li>
<li><p>受限于磁盘分区表的大小（MBR512字节，其中分区表栈64字节），每个分区信息占用16字节，所以一块磁盘最多只能创建四个分区。（主分区+扩展分区不能超过四个）</p>
</li>
<li><p>完成分区后要创建文件系统，最后将分区挂载到系统中的某个挂载点才可以使用</p>
</li>
</ul>
<h2 id="查看磁盘的使用情况以及文件系统被挂载的位置s"><a href="#查看磁盘的使用情况以及文件系统被挂载的位置s" class="headerlink" title="查看磁盘的使用情况以及文件系统被挂载的位置ｓ"></a>查看磁盘的使用情况以及文件系统被挂载的位置ｓ</h2><pre><code>df -l</code></pre><h2 id="创建文件系统：fdisk"><a href="#创建文件系统：fdisk" class="headerlink" title="创建文件系统：fdisk"></a>创建文件系统：fdisk</h2><pre><code>fdisk -l //显示当前设备的分区表

fdisk -s /dev/sda1  //显示指定分区的大小

fdisk -s /dev/sda   //显示设备所有分区大小的总和

fdisk /dev/sda  创建分区</code></pre><h2 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h2><ul>
<li><p>创建了文件系统的分区后，在Linux系统中要进行挂载后才能使用，挂载的命令时amount</p>
<pre><code>mount DEVICE MOUNT_POINT //DEVICE指的时具体的设备

mount /dev/sda1  /home/workbench

mount //没有参数的mount会显所有的挂载</code></pre></li>
</ul>
<ul>
<li><p>设置启动自动挂载    </p>
<p>  使用mount挂的设备在计算机重启后就会消失，所以必须通过配置/etc/fstab使得系统在重启后进行自动挂载。这里只需要一条命令即可：     </p>
<pre><code>echo &quot;/dev/sdb1 /root/newDisk ext3 defaults 00&quot; &gt;&gt; /etc/fstab</code></pre><p>  命令的意思：/dev/sdb1（第一部分） 挂载到 /root/newDisk（第二部分） ,文件系统是ext3（第三部分），使用系统默认额度挂载参数（第四部分），第五部分是dump命令在进行备份时是否要将这个分区存档，默认是0，第六部分是设定系统启动时是否对该设备进行fsck。</p>
</li>
</ul>
<ul>
<li><p>lvm卷不能挂载的问题</p>
<pre><code>mount: 未知的文件系统类型“LVM2_member”    </code></pre><p>  解决办法：<a href="http://blog.csdn.net/pengyouchuan/article/details/17578189" target="_blank" rel="noopener">http://blog.csdn.net/pengyouchuan/article/details/17578189</a></p>
</li>
</ul>
<h2 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h2><pre><code>umount /DEVICE/PATH

或者

unount MOUNT_POINT</code></pre><h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><ul>
<li><p>硬链接</p>
<p>  硬链接又称实际链接，是指通过索引节点进行链接。在Linux系统中每个文件都会有一个编号，称为inode，多个文件指向同一个索引节点是被允许的，这种链接就是硬链接</p>
<p>  删除一个链接不会影响索引节点本身和其他链接</p>
<p>  文件真正删除的前提条件是与之相关的所有硬链接均被删除</p>
<p>  不允许给目录创建硬链接</p>
<p>  只有同一个文件系统中的文件之间才能创建链接</p>
<pre><code>mkdir hard

cd hard

touch hard01

ls -li //i 参数可是显示文件的inode

ln hard01 hard01_hlink //创建指向hard01的硬链接

ls -li //inode值是一致的</code></pre></li>
<li><p>软链接</p>
<p>  软链接又称符号链接，是一个包含了另一个文件路径名的文件，可以指向任意文件或目录，可以可以跨不同的文件系统。类似于windows系统的快捷方式。</p>
<pre><code>touch file01

ln -s file01 file01_slink //使用-s参数创建软链接</code></pre></li>
</ul>
<h1 id="7、字符处理"><a href="#7、字符处理" class="headerlink" title="7、字符处理"></a>7、字符处理</h1><pre><code>//TODO</code></pre><h1 id="8、网路管理"><a href="#8、网路管理" class="headerlink" title="8、网路管理"></a>8、网路管理</h1><h2 id="网路接口和配置"><a href="#网路接口和配置" class="headerlink" title="网路接口和配置"></a>网路接口和配置</h2><ul>
<li><p>使用ifconfig检查和配置网卡</p>
<pre><code>ifconfig // 输出当前系统中所有处于活动状态的网络接口</code></pre></li>
</ul>
<h1 id="9、进程管理"><a href="#9、进程管理" class="headerlink" title="9、进程管理"></a>9、进程管理</h1><h2 id="查询进程打开的文件：lsof"><a href="#查询进程打开的文件：lsof" class="headerlink" title="查询进程打开的文件：lsof"></a>查询进程打开的文件：lsof</h2><p>lsof(list open files)是一个列出当前系统中所有打开文件的工具。</p>
<p>Linux中一切皆文件，所以在系统中被打开的文件可以是普通文件、目录、网路文件系统中的文件、字符设备、管道、socket等</p>
<pre><code>dnf install lsof

lsof [options] filename

lsof filename //显示打开指定文件的所有进程

lsof -c string //显示COMMOND列中包含指定字符串的进程打开的所有文件

lsof -u username //显示所属于user进程打开的文件

lsof -g gid //显示属于gid的进程情况

lsof +d /DIR/ //显示目录下被进程打开的文件

lsof +D /DIR/ //同上，但是会搜索目录下的所有目录，时间相对较长

lsof -i 显示符合条件的进程情况</code></pre><ul>
<li><p>查找使用了某个端口的进程</p>
<pre><code>lsof -i :8080</code></pre></li>
<li><p>查看当前有什么进程正在使用某文件</p>
<pre><code>lsof /var/log/messages</code></pre></li>
<li><p>利用lsof恢复被删除的文件，但这是有条件的，必须是文件正在被某个进程使用，而且该进程未停止（也就是我们依然有打开文件的句柄）</p>
</li>
</ul>
<h1 id="10、Shell编程"><a href="#10、Shell编程" class="headerlink" title="10、Shell编程"></a>10、Shell编程</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在某个shell中生效的变量，在其它shell中无效，随着shell的消失而消失</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><p>环境变量又称“全局变量”。在shell脚本中变量默认就是全局的，但是为了子Shell继当前Shell的变量，可以使用export内建命令，将其导出为环境变量。该命令的使用方式为：</p>
<pre><code>export VAR=value  //VAR为变量名字，value为值，用等号相连，等号两边没有空格
echo $VAR //打印环境变量VAR</code></pre></li>
<li><p>环境变量可以用在创建环境变量的Shell和从该Shell派生的任意子Shell或进程中（使用export内建命令将变量导出为环境变量），因此环境变量又被称为全局变量。</p>
</li>
<li><p>环境变量被创建时所处的Shell被称为父Shell，如果在父Shell中再创建一个Shell，则该Shell被称作子Shell。</p>
</li>
<li><p>环境变量只能向下传递不能向上传递。</p>
</li>
<li><p>常用环境变量</p>
<pre><code>echo $HOMETYPE  //展示主机的架构

echo $LANG

echo $PATH  //记录命令的搜索路径</code></pre></li>
</ul>
<pre><code>export PATH=/some/path:$PATH //重设PATH，增加/some/path至原来的PATH中</code></pre><ul>
<li><p>设置环境变量方法，如想将一个路径加入到$PATH中，可以像下面这样做:    </p>
<ul>
<li><p>控制台中设置，不赞成这种方式，因为他只对当前的shell 起作用，换一个shell设置就无效了：    </p>
<pre><code>$PATH=&quot;$PATH&quot;:/NEW_PATH  (关闭shell Path会还原为原来的path)</code></pre></li>
<li><p>修改 /etc/profile文件如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell</p>
<pre><code>在/etc/profile的最下面添加：  export  PATH=&quot;$PATH:/NEW_PATH&quot;    </code></pre><p>  注：修改文件后要想马上生效还要运行# ==source /etc/profile==不然只能在下次重进此用户时生效</p>
</li>
<li><p>修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。</p>
<pre><code>在下面添加：Export  PATH=&quot;$PATH:/NEW_PATH&quot;    </code></pre><p>  注：修改文件后要想马上生效还要运行$ source /home/richey/.bash_profile不然只能在下次重进此用户时生效</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用evn查看所有环境变量</p>
<p>  env</p>
</li>
<li><p>使用unset删除指定的环境变量</p>
<p>  unset VAR //删除环境变量VAR</p>
</li>
</ul>
<ul>
<li>demo</li>
</ul>
<ol>
<li><p>永久修改，对所有用户有效    </p>
<p> vi /etc/profile<br> //按键盘[Shift + g], 在profile文件最后添加下面的内容:<br> export JAVA_HOME = /home/myuser/jdk1.7.0_03<br> export PATH = $JAVA_HOME/bin:$PATH<br> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br> [注]：修改文件后如果想马上生效，还要运行 #source /etc/profile</p>
</li>
<li><p>永久修改，对单一用户有效    </p>
<p> //修改用户目录下的.bash_profile文件<br>  $ vi /home/myuser/.bash_profile<br> //在文件最后添加下面的内容<br>  export JAVA_HOME = /home/myuser/jdk1.7.0_03<br>  export PATH = $JAVA_HOME/bin:$PATH<br>  export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>  [注]：修改文件后如果想马上生效，还要运行 #source /home/myuser/.bash_profile</p>
</li>
<li><p>只对当前bash /shell 生效    </p>
<p> $ export JAVA_HOME = /home/myuser/jdk1.7.0_03<br> $ export PATH = $JAVA_HOME/bin:$PATH<br> $ export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2019/03/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="1、查找文件"><a href="#1、查找文件" class="headerlink" title="1、查找文件"></a>1、查找文件</h4><pre><code>find . -name &quot;*.xml&quot; 递归查找所有的xml文件
find / -name filename.txt 根据名称查找/目录下的filename.txt文件。
find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件
find ./ -size 0 | xargs rm -f &amp;amp; 删除文件大小为零的文件
grep -H &apos;spring&apos; *.xml 查找所以有的包含spring的xml文件
ls -l | grep &apos;.jar&apos; 查找当前目录中的所有jar文件
grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行。
grep &apos;test&apos; aa bb cc 显示在aa，bb，cc文件中匹配test的行。
grep &apos;[a-z]\{5\}&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</code></pre><h4 id="2、查看一个程序是否运行"><a href="#2、查看一个程序是否运行" class="headerlink" title="2、查看一个程序是否运行"></a>2、查看一个程序是否运行</h4><pre><code>ps –ef|grep tomcat 查看所有有关tomcat的进程</code></pre><h4 id="3、终止线程"><a href="#3、终止线程" class="headerlink" title="3、终止线程"></a>3、终止线程</h4><pre><code>kill -9 19979 终止线程号位19979的进程</code></pre><h4 id="4、查看文件，包含隐藏文件"><a href="#4、查看文件，包含隐藏文件" class="headerlink" title="4、查看文件，包含隐藏文件"></a>4、查看文件，包含隐藏文件</h4><pre><code>ls -al</code></pre><h4 id="5、当前工作目录"><a href="#5、当前工作目录" class="headerlink" title="5、当前工作目录"></a>5、当前工作目录</h4><pre><code>pwd</code></pre><h4 id="6、创建目录"><a href="#6、创建目录" class="headerlink" title="6、创建目录"></a>6、创建目录</h4><pre><code>mkdir newfolder</code></pre><h4 id="7、复制文件"><a href="#7、复制文件" class="headerlink" title="7、复制文件"></a>7、复制文件</h4><pre><code>cp source dest 复制文件
cp -r sourceFolder targetFolder 递归复制整个文件夹
scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝</code></pre><h4 id="8、删除目录"><a href="#8、删除目录" class="headerlink" title="8、删除目录"></a>8、删除目录</h4><pre><code>rmdir deleteEmptyFolder 删除空目录
rm -rf deleteFile 递归删除目录中所有内容</code></pre><h4 id="9、重命令"><a href="#9、重命令" class="headerlink" title="9、重命令"></a>9、重命令</h4><pre><code>mv oldNameFile newNameFile</code></pre><h4 id="10、移动文件"><a href="#10、移动文件" class="headerlink" title="10、移动文件"></a>10、移动文件</h4><pre><code>mv /temp/movefile /targetFolder</code></pre><h4 id="11、切换用户"><a href="#11、切换用户" class="headerlink" title="11、切换用户"></a>11、切换用户</h4><pre><code>su -username</code></pre><h4 id="12、修改文件权限"><a href="#12、修改文件权限" class="headerlink" title="12、修改文件权限"></a>12、修改文件权限</h4><pre><code>chmod 777 file.java //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可
执行</code></pre><h4 id="13、压缩文件"><a href="#13、压缩文件" class="headerlink" title="13、压缩文件"></a>13、压缩文件</h4><pre><code>tar -czf test.tar.gz /test1 /test2</code></pre><h4 id="14、列出压缩文件列表"><a href="#14、列出压缩文件列表" class="headerlink" title="14、列出压缩文件列表"></a>14、列出压缩文件列表</h4><pre><code>tar -tzf test.tar.gz</code></pre><h4 id="15、解压文件"><a href="#15、解压文件" class="headerlink" title="15、解压文件"></a>15、解压文件</h4><pre><code>tar -xvzf test.tar.gz</code></pre><h4 id="16、查看文件头10行"><a href="#16、查看文件头10行" class="headerlink" title="16、查看文件头10行"></a>16、查看文件头10行</h4><pre><code>head -n 10 example.txt</code></pre><h4 id="17、查看文件尾10行"><a href="#17、查看文件尾10行" class="headerlink" title="17、查看文件尾10行"></a>17、查看文件尾10行</h4><pre><code>tail -n 10 example.txt</code></pre><h4 id="18、使用超级管理员身份执行命令"><a href="#18、使用超级管理员身份执行命令" class="headerlink" title="18、使用超级管理员身份执行命令"></a>18、使用超级管理员身份执行命令</h4><pre><code>sudo rm a.txt 使用管理员身份删除文件</code></pre><h4 id="19、查看日志类型文件"><a href="#19、查看日志类型文件" class="headerlink" title="19、查看日志类型文件"></a>19、查看日志类型文件</h4><pre><code>tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</code></pre><h4 id="20、查看端口占用情况"><a href="#20、查看端口占用情况" class="headerlink" title="20、查看端口占用情况"></a>20、查看端口占用情况</h4><pre><code>netstat -tlnp | grep 8080 查看端口8080的使用情况</code></pre><ul>
<li><p>打开端口</p>
<p>  iptables -A INPUT -ptcp –dport  端口号 -j ACCEPT</p>
</li>
<li><p>关闭端口</p>
<p>  iptables -A INPUT -p tcp –drop 端口号 -j DROP</p>
<p>  iptables -A OUTPUT -p tcp –dport 端口号 -j DROP</p>
</li>
<li><p>demo打开23端口（即telnet端口）</p>
<p>  nc -lp23</p>
</li>
</ul>
<h4 id="21、查看端口属于哪个程序"><a href="#21、查看端口属于哪个程序" class="headerlink" title="21、查看端口属于哪个程序"></a>21、查看端口属于哪个程序</h4><pre><code>lsof -i :8080</code></pre><h4 id="22、查看进程"><a href="#22、查看进程" class="headerlink" title="22、查看进程"></a>22、查看进程</h4><pre><code>ps aux|grep java 查看java进程
ps aux 查看所有进程</code></pre><h4 id="23、以树状图列出目录的内容"><a href="#23、以树状图列出目录的内容" class="headerlink" title="23、以树状图列出目录的内容"></a>23、以树状图列出目录的内容</h4><pre><code>tree a

ps:Mac下使用tree命令

http://www.hollischuang.com/archives/546</code></pre><h4 id="24、文件下载"><a href="#24、文件下载" class="headerlink" title="24、文件下载"></a>24、文件下载</h4><pre><code>wget http://file.tgz
curl http://file.tgz

mac下安装wget命令

http://www.hollischuang.com/archives/548</code></pre><h4 id="25、网络检测"><a href="#25、网络检测" class="headerlink" title="25、网络检测"></a>25、网络检测</h4><pre><code>ping www.just-ping.com</code></pre><h4 id="26、远程登录"><a href="#26、远程登录" class="headerlink" title="26、远程登录"></a>26、远程登录</h4><pre><code>ssh userName@ip</code></pre><h4 id="27、打印信息"><a href="#27、打印信息" class="headerlink" title="27、打印信息"></a>27、打印信息</h4><pre><code>echo $JAVA_HOME 打印java home环境变量的值</code></pre><h4 id="28、java-常用命令"><a href="#28、java-常用命令" class="headerlink" title="28、java 常用命令"></a>28、java 常用命令</h4><pre><code>java javac jps ,jstat ,jmap, jstack

jps:http://www.hollischuang.com/archives/105
jstat:http://www.hollischuang.com/archives/481
jmap:http://www.hollischuang.com/archives/303
jstack:http://www.hollischuang.com/archives/110</code></pre><h4 id="29、查看所有的可用服务"><a href="#29、查看所有的可用服务" class="headerlink" title="29、查看所有的可用服务"></a>29、查看所有的可用服务</h4><pre><code>systemctl list-unit-files |grep service |grep enable</code></pre><h4 id="30、关闭服务"><a href="#30、关闭服务" class="headerlink" title="30、关闭服务"></a>30、关闭服务</h4><pre><code>systemctl stop ipatables</code></pre><h4 id="30、开机不启动"><a href="#30、开机不启动" class="headerlink" title="30、开机不启动"></a>30、开机不启动</h4><pre><code>systemctl disable iptables</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux使用私钥公钥(Public key)登录 - 免密码登录</title>
    <url>/2019/03/12/Linux%E4%BD%BF%E7%94%A8%E7%A7%81%E9%92%A5%E5%85%AC%E9%92%A5(Public%20key)%E7%99%BB%E5%BD%95%20-%20%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>为了更安全、方便的登录Linux服务器，可以取消密码登录，使用私钥公钥的方式来登录，更方便也更安全。</p>
<h1 id="生成密钥（客户端机器）"><a href="#生成密钥（客户端机器）" class="headerlink" title="生成密钥（客户端机器）"></a>生成密钥（客户端机器）</h1><pre><code>ssh-keygen -t [rsa|dsa] -P &apos;&apos;</code></pre><p>直接ssh-keygen然后三次回车就可以了。<br>-P表示密码，-P ‘’ 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车。<br>它在/home/chenlb下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub这样一对公私钥。</p>
<h1 id="上传公钥到服务器端"><a href="#上传公钥到服务器端" class="headerlink" title="上传公钥到服务器端"></a>上传公钥到服务器端</h1><p>先在服务器对应用户目录下创建~/.ssh/authorized_keys目录（如果目录已存在，这一步会被略过）</p>
<p>ssh richey@host mkdir -p .ssh/authorized_keys</p>
<p>把客户端的公钥_rsa.pub复制到服务器端机器的.ssh/authorized_keys文件里</p>
<pre><code>* 可以用scp复制到服务器，然后再从服务器中把从客户端复制的id_rsa.pub添加到.ssh/authorzied_keys文件里。

    scp .ssh/id_rsa.pub  richey@45.xx.xx.16:/home/richey/id_rsa.pub

* 或者

    cat .ssh/id_rsa.pub | ssh richey@hostB &apos;cat &gt;&gt; .ssh/authorized_keys&apos;</code></pre><ul>
<li><p>上述的创建目录并复制的操作也可以通过一个 ssh-copy-id 命令一步完成：    </p>
<pre><code>ssh-copy-id -i ~/.ssh/id_rsa.pub aliceB@hostB</code></pre></li>
<li><p>authorized_keys的权限要是600。</p>
<pre><code>chmod 600 .ssh/authorized_keys</code></pre></li>
</ul>
<h1 id="修改SSH的配置文件"><a href="#修改SSH的配置文件" class="headerlink" title="修改SSH的配置文件"></a>修改SSH的配置文件</h1><p>配置文件位置</p>
<pre><code>/etc/ssh/sshd_config :

#RSAAuthentication yes
#PubkeyAuthentication yes
#AuthorizedKeysFile .ssh/authorized_keys</code></pre><p>去调上面3行前面的#，保存后重启SSH服务。</p>
<pre><code>使用SYSVINIT初始化系统的Linux系统：service sshd restart
使用SYSTEMD初始化系统的Linux系统：systemctl restart sshd</code></pre><p>至此服务器端已经支持使用SSH私钥证书登录。</p>
<h1 id="关闭root用户使用密码登陆"><a href="#关闭root用户使用密码登陆" class="headerlink" title="关闭root用户使用密码登陆"></a>关闭root用户使用密码登陆</h1><p>在使用SSH Key登录验证成功后，还是为了安全，建议关闭root用户使用密码登陆，关闭的方法如下：</p>
<p>修改SSH的配置文件/etc/ssh/sshd_config，找到下面1行：</p>
<pre><code>PasswordAuthentication yes</code></pre><p>修改为：</p>
<pre><code>PasswordAuthentication no</code></pre><p>保存后重启SSH服务。</p>
<pre><code>service sshd restart</code></pre><p>好了，至此只要你保存好你的私钥（为安全，建议删除服务器端的私钥），你的服务器相比原来使用root用户加密码登陆来说已经安全多了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下iptables 禁止端口和开放端口</title>
    <url>/2019/03/10/Linux%E4%B8%8Biptables%20%E7%A6%81%E6%AD%A2%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>iptables属于网络层防火墙。</p>
<ul>
<li>iptables 查看所有iptables规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -L</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭所有的 INPUT FORWARD OUTPUT 只对某些端口开放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置：</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">查看是否设置好：</span><br><span class="line">iptables -L -n</span><br><span class="line">保存设置：</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<ul>
<li><p>iptables 规则保存在/etc/sysconfig/iptables里面</p>
</li>
<li><p>打开22端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">查看是否添加上去了：</span><br><span class="line">iptables -L -n</span><br><span class="line"></span><br><span class="line">记得保存：</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line">命令解释：</span><br><span class="line">-A 就是添加新的规则</span><br><span class="line">-p 指定是什么协议 我们常用的tcp 协议，当然也有udp 例如53端口的DNS</span><br><span class="line">--dport 目标端口 当数据从外部进入服务器为目标端口</span><br><span class="line">--sport 数据源端口，数据从服务器出去为数据源端口</span><br><span class="line">-j 就是指定是 ACCEPT 接收 或者 DROP 不接收</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止某个ip访问</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加规则：</span><br><span class="line">iptables -A INPUT -p tcp -s 192.168.1.2 -j DROP</span><br><span class="line">保存规则：</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line">命令解释：</span><br><span class="line">-A 就是添加新的规则</span><br><span class="line">-p tcp 指定添加的是tcp规则</span><br><span class="line">-s 来源的意思，ip来源于192.168.1.2</span><br><span class="line">-j 怎么做 我们拒绝它 这里应该是 DROP</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除规则</p>
<p>每条规则都有一个编号，首先我们要知道要删除的规则编号。</p>
<p>查看规则及对应编号：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -L -n --line-number</span><br><span class="line"></span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    ACCEPT     udp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            udp dpt:53</span><br><span class="line">2    ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:53</span><br><span class="line">3    ACCEPT     udp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            udp dpt:67</span><br><span class="line">4    ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:67</span><br><span class="line">5    ACCEPT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            ctstate RELATED,ESTABLISHED</span><br><span class="line">6    ACCEPT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0  </span><br><span class="line"></span><br><span class="line">多了num一列，那么我们就可以进行删除了：</span><br><span class="line">iptables -D INPUT 2 #删除INPUT链编号为2的规则</span><br></pre></td></tr></table></figure>

<ul>
<li><p>过滤无效的数据包</p>
<ul>
<li><p>禁止没有通过请求回应的数据包</p>
<p> 假设有人进入了服务器，或者有病毒木马程序，它可以通过22，80端口像服务器外传送数据。它的这种方式就和我们正常访问22，80端口是有区别的，它发向外发的数据不是我们通过访问网页请求而回应的数据包。</p>
<p>iptables 提供了一个参数 是检查状态的，下面我们来配置下 22 和 80 端口，防止无效的数据包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">对比之前使用的：</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span><br><span class="line">多了一个状态判断</span><br><span class="line"></span><br><span class="line">同样80端口也一样：</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">删掉原来的两条规则：</span><br><span class="line">iptables -L -n --line-number</span><br><span class="line">iptables -D OUTPUT 对应的规则编号</span><br><span class="line"></span><br><span class="line">保存规则：</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>打开DNS端口</p>
<p>DNS对应的是53端口</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看能不能解析域名：</span><br><span class="line">host www.baidu.com</span><br><span class="line"></span><br><span class="line">输入这个命令后，一直等待，出现下面提示：</span><br><span class="line">;; connection timed out; no servers could be reached</span><br><span class="line"></span><br><span class="line">ping一下域名也是不通：</span><br><span class="line">ping www.baidu.com</span><br><span class="line">ping: unknown host www.baidu.com</span><br><span class="line"></span><br><span class="line">这时候可以查看53端口是否开放：</span><br><span class="line">sudo iptables -L -n|grep 53</span><br><span class="line"></span><br><span class="line">查看域名服务端口号：</span><br><span class="line">grep domain &#x2F;etc&#x2F;services</span><br><span class="line"></span><br><span class="line">domain          53&#x2F;tcp                          # name-domain server</span><br><span class="line">domain          53&#x2F;udp</span><br><span class="line">domain-s        853&#x2F;tcp                 # DNS query-response protocol</span><br><span class="line">domain-s        853&#x2F;udp                 # DNS query-response protocol</span><br><span class="line">domaintime      9909&#x2F;tcp                # domaintime</span><br><span class="line">domaintime      9909&#x2F;udp                # domaintime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打开DNS53端口,我们一般使用udp协议：</span><br><span class="line"></span><br><span class="line">ping一个域名数据出去</span><br><span class="line">iptables -A OUTPUT -p udp --dport 53 -j ACCEPT</span><br><span class="line">DNS服务器响应回来</span><br><span class="line">iptables -A INPUT -p udp --sport 53 -j ACCEPT</span><br><span class="line"></span><br><span class="line">同时还要设置：</span><br><span class="line">iptables -A INPUT -p udp --dport 53 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p udp --sport 53 -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -L -n 查看设置情况</span><br><span class="line"></span><br><span class="line">保存规则：</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<ul>
<li>iptables对ftp的设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ftp连接端口有2个 21 和 20 端口，我现在添加对应的规则。</span><br><span class="line"></span><br><span class="line">[root@localhost root]#iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">[root@localhost root]#iptables -A INPUT -p tcp --dport 20 -j ACCEPT</span><br><span class="line">[root@localhost root]#iptables -A OUTPUT -p tcp --sport 21 -j ACCEPT</span><br><span class="line">[root@localhost root]#iptables -A OUTPUT -p tcp --sport 20 -j ACCEPT</span><br><span class="line"></span><br><span class="line">ftp 是比较特殊的端口，它还有一些端口是数据传输端口,如目录列表、上传、下载文件都要用到这些端口，而这些端口是任意端口。</span><br><span class="line">所以我们要给ftp指定这个数据传输端口的一个范围。</span><br><span class="line">修改一下ftp配置文件,不同ftp配置文件不同，这里以vsftpd来演示修改：</span><br><span class="line"></span><br><span class="line">[root@localhost root]#vi &#x2F;etc&#x2F;vsftpd.conf</span><br><span class="line">pasv_min_port&#x3D;30001</span><br><span class="line">pasv_max_port&#x3D;31000</span><br><span class="line"></span><br><span class="line">这两句话的意思告诉vsftpd, 要传输数据的端口范围就在30001到31000 这个范围内传送。</span><br><span class="line"></span><br><span class="line">打开iptables 30001到31000这些端口：</span><br><span class="line">[root@localhost root]#iptables -A INPUT -p tcp --dport 30001:31000 -j ACCEPT</span><br><span class="line">[root@localhost root]#iptables -A OUTPUT -p tcp --sport 30001:31000 -j ACCEPT</span><br><span class="line">[root@localhost root]#service iptables save</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令</title>
    <url>/2019/03/08/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>hexo g 生成静态文件</p>
</li>
<li><p>hexo s 启动本地服务</p>
</li>
<li><p>hexo clean 清除缓存文件(db.json)和已生成的静态文件(public)</p>
</li>
<li><p>hexo g -d 生成文件并部署到github</p>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Stream</title>
    <url>/2019/03/08/Java%20Stream/</url>
    <content><![CDATA[<h1 id="1、Java-Stream-API-入门"><a href="#1、Java-Stream-API-入门" class="headerlink" title="1、Java Stream API 入门"></a>1、Java Stream API 入门</h1><h2 id="Java8引入函数式编程"><a href="#Java8引入函数式编程" class="headerlink" title="Java8引入函数式编程"></a>Java8引入函数式编程</h2><ul>
<li>代码简洁，使用stream接口让你从此告别for循环</li>
<li>多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下parallel()方法</li>
</ul>
<h2 id="Java函数式编程的主角-Stream"><a href="#Java函数式编程的主角-Stream" class="headerlink" title="Java函数式编程的主角 Stream"></a>Java函数式编程的主角 Stream</h2><blockquote>
<p>stream并不是某种数据结构，它只是==数据源的一种视图==。这里的数据源可以是一个数组，Java容器或I/O channel等。因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：</p>
</blockquote>
<ul>
<li>调用Collection.stream()或者Collection.parallelStream()方法</li>
<li>stream(T[] array)方法</li>
<li>Stream 接口关系继承图</li>
</ul>
<p><img src="http://orybhlel7.bkt.clouddn.com/image/png/stream-interface.png" alt="image"></p>
<blockquote>
<p>图中4种stream接口继承自BaseStream，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图</p>
</blockquote>
<h2 id="Stream的特点"><a href="#Stream的特点" class="headerlink" title="Stream的特点"></a>Stream的特点</h2><blockquote>
<p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>
</blockquote>
<ul>
<li>==无存储==。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li>==为函数式编程而生==。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>
<li>==惰式执行==。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>==可消费性==。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<blockquote>
<p>对stream的操作分为为两类，==中间操作==(intermediate operations)和==结束操作==(terminal operations)，二者特点是：</p>
</blockquote>
<ol>
<li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>
<li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>
</ol>
<h2 id="Stream常见方法"><a href="#Stream常见方法" class="headerlink" title="Stream常见方法"></a>Stream常见方法</h2><blockquote>
<p>Stream接口的部分常见方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>接口方法</th>
</tr>
</thead>
<tbody><tr>
<td>中间操作</td>
<td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td>结束操作</td>
<td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody></table>
<p><strong>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。</strong></p>
<h2 id="Stream方法的使用"><a href="#Stream方法的使用" class="headerlink" title="Stream方法的使用"></a>Stream方法的使用</h2><blockquote>
<p>stream跟函数接口关系非常紧密，没有函数接口stream就无法工作。回顾一下：==函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式==，所以不必记忆函数接口的名字。   </p>
</blockquote>
<ul>
<li>forEach()    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;yout&quot;,&quot;too&quot;);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<pre><code>由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。</code></pre><ul>
<li><p>filter()    </p>
<p>  函数原型为Stream<T> filter(Predicate&lt;? super T&gt; predicate)，作用是返回一个只包含满足predicate条件元素的Stream。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">stream.filter(str -&gt; str.length() &#x3D;&#x3D; 3).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
</li>
<li><p>distinck()</p>
<p>  函数原型为Stream<T> distinct()，作用是返回一个去除重复元素之后的Stream。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;,&quot;too&quot;);</span><br><span class="line">stream.distinct().forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sorted()</p>
<p>  排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream<T>　sorted()和Stream<T>　sorted(Comparator&lt;? super T&gt; comparator)。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length() - str2.length()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<ul>
<li>map()</li>
</ul>
<p>函数原型为<R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)，作用是返回一个对当前所有元素执行执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flatMap</p>
<p>  函数原型为<R> Stream<R> flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)，作用是对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲flatMap()的作用就相当于把原stream中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream &#x3D; Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4));</span><br><span class="line">stream.flatMap(list -&gt; list.stream()).forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>

<h1 id="2、Java-Stream-API-进阶"><a href="#2、Java-Stream-API-进阶" class="headerlink" title="2、Java Stream API 进阶"></a>2、Java Stream API 进阶</h1><h2 id="Stream的规约操作"><a href="#Stream的规约操作" class="headerlink" title="Stream的规约操作"></a>Stream的规约操作</h2><blockquote>
<p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作reduce()和collect()，也有一些为简化书写而设计的专用规约操作，比如sum()、max()、min()、count()等。</p>
</blockquote>
<blockquote>
<p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍reduce()和collect()，这是比较有魔法的地方。</p>
</blockquote>
<h3 id="多面手reduce"><a href="#多面手reduce" class="headerlink" title="多面手reduce()"></a>多面手reduce()</h3><p>reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用。reduce()的方法定义有三种重写形式：</p>
<ul>
<li>Optional<T> reduce(BinaryOperator<T> accumulator)</li>
<li>T reduce(T identity, BinaryOperator<T> accumulator)</li>
<li><U> U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator<U> combiner)</li>
</ul>
<p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>
<p>需求：从一组单词中找出最长的单词。这里“大”的含义就是“长”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">Optional&lt;String&gt; longest &#x3D; stream.reduce((str1, str2) -&gt; str1.length() &gt; str2.length() ? str1 : str2);</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">Optional&lt;String&gt; longest &#x3D; stream.max((str1, str2) -&gt; str1.length() - str2.length());</span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>
<p>上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用Stream.max(Comparator&lt;? super T&gt; comparator)方法来达到同等效果，但reduce()自有其存在的理由。</p>
<p>需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">Integer lengthSum &#x3D; stream.reduce(0, &#x2F;&#x2F; 初始值 &#x2F;&#x2F;(1)</span><br><span class="line">        (sum, str) -&gt; sum + str.length(),  &#x2F;&#x2F;累加器 &#x2F;&#x2F;(2)</span><br><span class="line">        (a, b) -&gt; a + b); &#x2F;&#x2F;部分结果拼接器 &#x2F;&#x2F;(3)</span><br><span class="line">&#x2F;&#x2F;stream.mapToInt(str -&gt; str.length()).sum();</span><br><span class="line">System.out.println(lengthSum);</span><br></pre></td></tr></table></figure>
<p>上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用reduce()函数将这两步合二为一，更有助于提升性能。如果想要使用map()和sum()组合来达到上述目的，也是可以的。</p>
<p>==reduce()擅长的是生成一个值==，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器collect()横空出世！</p>
<h3 id="终极武器collect"><a href="#终极武器collect" class="headerlink" title="终极武器collect()"></a>终极武器collect()</h3><p>不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过collect()方法实现。collect()是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());</span><br><span class="line">&#x2F;&#x2F;Set&lt;String&gt; set &#x3D; stream.collect(Collectors.toSet());</span><br><span class="line">&#x2F;&#x2F;Map&lt;String, Integer&gt; map &#x3D; stream.collect(Collectors.toMap(Function.identity(), String::length));</span><br></pre></td></tr></table></figure>

<p>上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：</p>
<ul>
<li>Function.identity()是干什么的？</li>
<li>String::length是什么意思？</li>
<li>Collectors是个什么东西？</li>
</ul>
<h4 id="接口的静态方法和默认方法"><a href="#接口的静态方法和默认方法" class="headerlink" title="==接口的静态方法和默认方法=="></a>==接口的静态方法和默认方法==</h4><p>Function是一个接口，那么Function.identity()是什么意思呢？这要从两方面解释：</p>
<ol>
<li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。</li>
<li>Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</li>
</ol>
<blockquote>
<p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得t -&gt; t比identity()方法更直观。我会告诉你接口中的default方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？default方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了default方法，为何不再加入static方法来避免专门的工具类呢！</p>
</blockquote>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="==方法引用=="></a>==方法引用==</h4><p>诸如String::length的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p>
<table>
<thead>
<tr>
<th>方法引用类别</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td>Integer::sum</td>
</tr>
<tr>
<td>引用某个对象的方法</td>
<td>list::add</td>
</tr>
<tr>
<td>引用某个类的方法</td>
<td>String::length</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>HashMap::new</td>
</tr>
</tbody></table>
<h4 id="收集器"><a href="#收集器" class="headerlink" title="==收集器=="></a>==收集器==</h4><p>收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p>
<ol>
<li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li>
<li>新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉collect()</li>
<li>多个部分结果如何合并成一个。</li>
</ol>
<p>结合以上分析，collect()方法定义为<R> R collect(Supplier<R> supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)，三个参数依次对应上述三条分析。不过每次调用collect()都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以collect()的另一定义为&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,&quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</span><br><span class="line">&#x2F;&#x2F;List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>通常情况下我们不需要手动指定collect()的三个参数，而是调用collect(Collector&lt;? super T,A,R&gt; collector)方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了collect()的行为。</p>
<p>==使用collect()生成Collection==</p>
<p>前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将Stream转换成List或Set</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList()); &#x2F;&#x2F; (1)</span><br><span class="line">Set&lt;String&gt; set &#x3D; stream.collect(Collectors.toSet()); &#x2F;&#x2F; (2)</span><br></pre></td></tr></table></figure>

<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier<C> collectionFactory)方法完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toCollection(ArrayList::new)); &#x2F;&#x2F;(3)</span><br><span class="line">Set&lt;String&gt; set &#x3D; stream.collect(Collectors.toCollection(HashSet::new));  &#x2F;&#x2F;(4)</span><br></pre></td></tr></table></figure>
<p>上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。</p>
<h4 id="使用collect-生成Map"><a href="#使用collect-生成Map" class="headerlink" title="==使用collect()生成Map=="></a>==使用collect()生成Map==</h4><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map：</p>
<ol>
<li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li>
<li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li>
<li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li>
</ol>
<ul>
<li>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将电脑列表转换成由&lt;电脑，G价格&gt;组成的Map。非常直观，无需多言。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void TestCollectMap() &#123;</span><br><span class="line">    List&lt;ComputerVO&gt; computers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    computers.add(new ComputerVO(&quot;联想笔记本&quot;,5500.0));</span><br><span class="line">    computers.add(new ComputerVO(&quot;华硕笔记本&quot;,3500.0));</span><br><span class="line">    computers.add(new ComputerVO(&quot;苹果笔记本&quot;,6500.0));</span><br><span class="line">    Map&lt;ComputerVO,Double&gt; map &#x3D; computers.stream().collect(Collectors.toMap(Function.identity(), computerVO -&gt; getComputerPrice(computerVO)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Double getComputerPrice(ComputerVO computerVO) &#123;</span><br><span class="line">    return computerVO.getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将电脑分成价格大于等于3500和小于3500的两部分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void TestcollectMap2() &#123;</span><br><span class="line">    List&lt;ComputerVO&gt; computers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    computers.add(new ComputerVO(&quot;联想笔记本&quot;,5500.0));</span><br><span class="line">    computers.add(new ComputerVO(&quot;华硕笔记本&quot;,3500.0));</span><br><span class="line">    computers.add(new ComputerVO(&quot;苹果笔记本&quot;,6500.0));</span><br><span class="line">    Map&lt;Boolean,List&lt;ComputerVO&gt;&gt; map &#x3D; computers.stream().collect(Collectors.partitioningBy(c -&gt; c.getPrice() &gt;&#x3D; 3500));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将电脑按照品牌进行分组：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;ComputerVO&gt; computers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">computers.add(new ComputerVO(&quot;联想笔记本&quot;,5500.0));</span><br><span class="line">computers.add(new ComputerVO(&quot;华硕笔记本&quot;,3500.0));</span><br><span class="line">computers.add(new ComputerVO(&quot;苹果笔记本&quot;,6500.0));</span><br><span class="line">Map&lt;String,List&lt;ComputerVO&gt;&gt; map &#x3D; computers.stream().collect(Collectors.groupingBy(ComputerVO::getName));</span><br></pre></td></tr></table></figure>

<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将电脑按照品牌分组，2. 然后统计每个品牌电脑的个数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做==上游收集器==，之后执行其他运算的收集器叫做==下游收集器==(downstream Collector)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;ComputerVO&gt; computers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">computers.add(new ComputerVO(&quot;联想笔记本&quot;,5500.0));</span><br><span class="line">computers.add(new ComputerVO(&quot;华硕笔记本&quot;,3500.0));</span><br><span class="line">computers.add(new ComputerVO(&quot;苹果笔记本&quot;,6500.0));</span><br><span class="line">Map&lt;String, Long&gt; map &#x3D; computers.stream().collect(Collectors.groupingBy(ComputerVO::getName, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept &#x3D; employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,&#x2F;&#x2F; 下游收集器</span><br><span class="line">                                Collectors.toList())));&#x2F;&#x2F; 更下游的收集器</span><br></pre></td></tr></table></figure>

<h4 id="使用collect-做字符串join"><a href="#使用collect-做字符串join" class="headerlink" title="==使用collect()做字符串join=="></a>==使用collect()做字符串join==</h4><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用Collectors.joining()生成的收集器，从此告别for循环。Collectors.joining()方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Collectors.joining()拼接字符串</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">&#x2F;&#x2F;String joined &#x3D; stream.collect(Collectors.joining());&#x2F;&#x2F; &quot;Iloveyou&quot;</span><br><span class="line">&#x2F;&#x2F;String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;));&#x2F;&#x2F; &quot;I,love,you&quot;</span><br><span class="line">String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;));&#x2F;&#x2F; &quot;&#123;I,love,you&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="collect-还可以做更多"><a href="#collect-还可以做更多" class="headerlink" title="==collect()还可以做更多=="></a>==collect()还可以做更多==</h4><p>除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用collect(Supplier<R> supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。</p>
<h1 id="3、深入理解Java"><a href="#3、深入理解Java" class="headerlink" title="3、深入理解Java"></a>3、深入理解Java</h1><p><a href="http://www.importnew.com/24235.html" target="_blank" rel="noopener">http://www.importnew.com/24235.html</a></p>
<p><a href="http://www.importnew.com/25315.html" target="_blank" rel="noopener">http://www.importnew.com/25315.html</a></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description</a><br><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html</a></p>
<p><a href="http://www.importnew.com/24237.html" target="_blank" rel="noopener">http://www.importnew.com/24237.html</a><br><a href="http://www.importnew.com/24245.html" target="_blank" rel="noopener">http://www.importnew.com/24245.html</a><br><a href="http://www.importnew.com/24235.html" target="_blank" rel="noopener">http://www.importnew.com/24235.html</a></p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2019/03/08/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="HashMap、Hashtable、ConcurrentHashMap的原理与区别"><a href="#HashMap、Hashtable、ConcurrentHashMap的原理与区别" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap的原理与区别"></a>HashMap、Hashtable、ConcurrentHashMap的原理与区别</h1><h2 id="简述HashMap实现原理"><a href="#简述HashMap实现原理" class="headerlink" title="简述HashMap实现原理"></a>简述HashMap实现原理</h2><p>HashMap的底层是通过数组和链表实现的。其实就是维护了一个数组，put操作的时候根据key的哈希值和数组的长度（具体看源码）算出下标，判断该位置有没有对象，没有的话直接创建一个Entry对象（该对象保存了key，hash，value，下标等属性），如果有对象则判断是否有hash冲突（不同的key，但是hash值相同），有冲突则则该闻之用链表存储。</p>
<p>todo：源码分析</p>
<p>注意：</p>
<ul>
<li>HashMap的key和value都允许是null；</li>
<li>当put后数量大于等于当前容量*加载因子的时候，就需要扩容，扩容需要数组复制，是非常耗时的，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能；</li>
</ul>
<p>思考：<br>如果我们创建HashMap的时候指定了初始大小等于我们希望放入对象的数量，是不是就不会产生扩容？（如果不修改加载因子，仍会产生扩容）</p>
<h2 id="HashTale与HashMap的区别"><a href="#HashTale与HashMap的区别" class="headerlink" title="HashTale与HashMap的区别"></a>HashTale与HashMap的区别</h2><ul>
<li>HashTable同HashMap的实现差别不大，  同样是基于哈希表通过数组和链表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</li>
</ul>
<h2 id="HashTable与ConcurrentHashMap的区别"><a href="#HashTable与ConcurrentHashMap的区别" class="headerlink" title="HashTable与ConcurrentHashMap的区别"></a>HashTable与ConcurrentHashMap的区别</h2><ul>
<li>不同点在于HashTable是线程安全的，因为它每个方法中都加入了Synchronize。</li>
<li>ConcurrentHashMap是HashTable的代替，底层采用分段的数组+链表实现，线程安全。</li>
<li>通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)</li>
</ul>
<h1 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h1><h1 id="Jdk7中HashMap的环是如何形成的，Jdk8是如何解决的"><a href="#Jdk7中HashMap的环是如何形成的，Jdk8是如何解决的" class="headerlink" title="Jdk7中HashMap的环是如何形成的，Jdk8是如何解决的"></a>Jdk7中HashMap的环是如何形成的，Jdk8是如何解决的</h1><h1 id="Atomic类如何保证原子操作（CAS操作）"><a href="#Atomic类如何保证原子操作（CAS操作）" class="headerlink" title="Atomic类如何保证原子操作（CAS操作）"></a>Atomic类如何保证原子操作（CAS操作）</h1><h1 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h1><h1 id="ThreadLocal的原理和实现"><a href="#ThreadLocal的原理和实现" class="headerlink" title="ThreadLocal的原理和实现"></a>ThreadLocal的原理和实现</h1><h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><h1 id="核心线程池ThreadPoolExecutor的参数"><a href="#核心线程池ThreadPoolExecutor的参数" class="headerlink" title="核心线程池ThreadPoolExecutor的参数"></a>核心线程池ThreadPoolExecutor的参数</h1><h1 id="ThreadPoolExecutor的工作流程"><a href="#ThreadPoolExecutor的工作流程" class="headerlink" title="ThreadPoolExecutor的工作流程"></a>ThreadPoolExecutor的工作流程</h1><h1 id="如何控制线程池线程的优先级"><a href="#如何控制线程池线程的优先级" class="headerlink" title="如何控制线程池线程的优先级"></a>如何控制线程池线程的优先级</h1><h1 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a>线程之间如何通信</h1><h1 id="Jdk1-8和1-7都分别新增了哪些特性"><a href="#Jdk1-8和1-7都分别新增了哪些特性" class="headerlink" title="Jdk1.8和1.7都分别新增了哪些特性"></a>Jdk1.8和1.7都分别新增了哪些特性</h1><h1 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h1><h1 id="Object类内的方法"><a href="#Object类内的方法" class="headerlink" title="Object类内的方法"></a>Object类内的方法</h1><p>Mysql 一句查询操作的执行流程</p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql（1）-常用命令</title>
    <url>/2019/03/06/Mysql%EF%BC%881%EF%BC%89-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="查看数据库版本"><a href="#查看数据库版本" class="headerlink" title="查看数据库版本"></a>查看数据库版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select version();</span><br></pre></td></tr></table></figure>

<h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<h2 id="查看master数据库当前正在使用的二进制日志及当前执行二进制日志位置"><a href="#查看master数据库当前正在使用的二进制日志及当前执行二进制日志位置" class="headerlink" title="查看master数据库当前正在使用的二进制日志及当前执行二进制日志位置"></a>查看master数据库当前正在使用的二进制日志及当前执行二进制日志位置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<h2 id="查看数据库创建语句"><a href="#查看数据库创建语句" class="headerlink" title="查看数据库创建语句"></a>查看数据库创建语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create database database_name;</span><br></pre></td></tr></table></figure>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS mysql_study</span><br><span class="line">DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<h2 id="确定数据库大小"><a href="#确定数据库大小" class="headerlink" title="确定数据库大小"></a>确定数据库大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    ROUND(SUM(data_length + index_length) &#x2F; 1024 &#x2F; 1024) AS total_mb,</span><br><span class="line">    ROUND(SUM(data_length) &#x2F; 1024 &#x2F; 1024) AS data_mb,</span><br><span class="line">    ROUND(SUM(index_length) &#x2F; 1024 &#x2F; 1024) AS index_mb</span><br><span class="line">FROM</span><br><span class="line">    INFORMATION_SCHEMA.tables;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line"># 表相关</span><br><span class="line"></span><br><span class="line">## 创建表(建表语句)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;user_info&#96;(</span><br><span class="line">  &#96;id&#96; INT  AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">  &#96;companyId&#96; VARCHAR(40) NOT NULL,</span><br><span class="line">  &#96;birthday&#96; DATE,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  index idx_companyId_name(&#96;id&#96;,&#96;name&#96;)</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci;</span><br></pre></td></tr></table></figure>

<h2 id="查看建表语句"><a href="#查看建表语句" class="headerlink" title="查看建表语句"></a>查看建表语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table table_name;</span><br></pre></td></tr></table></figure>

<h2 id="查看表字段"><a href="#查看表字段" class="headerlink" title="查看表字段"></a>查看表字段</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc tb_books;</span><br><span class="line">or</span><br><span class="line">show columns from tb_books;</span><br></pre></td></tr></table></figure>

<h2 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table t1 modify name varchar(30) default null;</span><br></pre></td></tr></table></figure>


<h2 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table vip drop foreign key FK1C81D1738DA76</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table table_name drop index index_name ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># How can I employ “if exists” for creating or dropping an index in MySQL?</span><br><span class="line">set @exist :&#x3D; (select count(*) from information_schema.statistics where table_name &#x3D; &#39;table&#39; and index_name &#x3D; &#39;index&#39; and table_schema &#x3D; database());</span><br><span class="line">set @sqlstmt :&#x3D; if( @exist &gt; 0, &#39;select &#39;&#39;INFO: Index already exists.&#39;&#39;&#39;, &#39;create index i_index on tablename ( columnname )&#39;);</span><br><span class="line">PREPARE stmt FROM @sqlstmt;</span><br><span class="line">EXECUTE stmt;</span><br></pre></td></tr></table></figure>

<h2 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table table_test drop primary key;</span><br></pre></td></tr></table></figure>

<h2 id="增加主键"><a href="#增加主键" class="headerlink" title="增加主键"></a>增加主键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table table_test add primary key(id);</span><br></pre></td></tr></table></figure>

<h2 id="执行语句手动关闭安全更新模式"><a href="#执行语句手动关闭安全更新模式" class="headerlink" title="执行语句手动关闭安全更新模式"></a>执行语句手动关闭安全更新模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SQL_SAFE_UPDATES &#x3D; 0;</span><br></pre></td></tr></table></figure>

<h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><h2 id="创建用户（CREATE-USER）"><a href="#创建用户（CREATE-USER）" class="headerlink" title="创建用户（CREATE USER）"></a>创建用户（CREATE USER）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user &#39;richey&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;!@#$1234Richey&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show grants for foo;</span><br></pre></td></tr></table></figure>
<h2 id="给数据库用户授权（GRANT-PERMISSIONS）"><a href="#给数据库用户授权（GRANT-PERMISSIONS）" class="headerlink" title="给数据库用户授权（GRANT PERMISSIONS）"></a>给数据库用户授权（GRANT PERMISSIONS）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL ON mysql_study.* TO &#39;richey&#39;@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="刷新权限-（FLUSH-PRIVILEGES-Tell-the-server-to-reload-the-grant-tables）"><a href="#刷新权限-（FLUSH-PRIVILEGES-Tell-the-server-to-reload-the-grant-tables）" class="headerlink" title="刷新权限 （FLUSH PRIVILEGES, Tell the server to reload the grant tables）"></a>刷新权限 （FLUSH PRIVILEGES, Tell the server to reload the grant tables）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h1 id="系统表"><a href="#系统表" class="headerlink" title="系统表"></a>系统表</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.processlist</span><br><span class="line">select * from information_schema.innodb_trx; ## 当前运行的所有事务</span><br><span class="line">select * from information_schema.innodb_locks; ## 当前出现的锁</span><br><span class="line">select * from information_schema.innodb_lock_waits; ## 锁等待的对应关系</span><br></pre></td></tr></table></figure>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="查看binglog文件列表"><a href="#查看binglog文件列表" class="headerlink" title="查看binglog文件列表"></a>查看binglog文件列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br><span class="line">报错：</span><br><span class="line">ERROR 1381 (HY000): You are not using binary logging</span><br><span class="line">mysql&gt; show mysql&gt; show variables like &#39;log_bin&#39;;</span><br><span class="line">发现二进制文件没有开启</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | OFF   |</span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">Linux下MySQL的配置文件是my.cnf,一般会放在&#x2F;etc&#x2F;my.cnf,&#x2F;etc&#x2F;mysql&#x2F;my.cnf。</span><br><span class="line"></span><br><span class="line">在mysqld配置项下面加上log_bin&#x3D;mysql_bin</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">log_bin &#x3D; mysql_bin</span><br><span class="line"></span><br><span class="line">重启mysql</span><br><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure>

<h3 id="查看在写入的binlog文件"><a href="#查看在写入的binlog文件" class="headerlink" title="查看在写入的binlog文件"></a>查看在写入的binlog文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status；</span><br></pre></td></tr></table></figure>

<h3 id="查看指定binlog文件的内容"><a href="#查看指定binlog文件的内容" class="headerlink" title="查看指定binlog文件的内容"></a>查看指定binlog文件的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show binlog events [in &#39;log_name&#39;] [FROM pos] [limit [offset,] row_count]</span><br></pre></td></tr></table></figure>
<h3 id="mysqlbinlog查看binlog文件内容"><a href="#mysqlbinlog查看binlog文件内容" class="headerlink" title="mysqlbinlog查看binlog文件内容"></a>mysqlbinlog查看binlog文件内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog binlog文件</span><br></pre></td></tr></table></figure>

<h3 id="输出指定position位置的binlog日志"><a href="#输出指定position位置的binlog日志" class="headerlink" title="输出指定position位置的binlog日志"></a>输出指定position位置的binlog日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --start-position&#x3D;&quot;指定开始位置&quot; --stop-position&#x3D;&quot;指定结束位置&quot; binlog文件</span><br></pre></td></tr></table></figure>
<h3 id="输出指定position位置的binlog日志到指定文件中"><a href="#输出指定position位置的binlog日志到指定文件中" class="headerlink" title="输出指定position位置的binlog日志到指定文件中"></a>输出指定position位置的binlog日志到指定文件中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --start-position&#x3D;&quot;指定开始位置&quot; --stop-position&#x3D;&quot;指定结束位置&quot; binlog文件 &gt; 输出文件名</span><br></pre></td></tr></table></figure>
<h3 id="输出指定开始时间的binlog日志"><a href="#输出指定开始时间的binlog日志" class="headerlink" title="输出指定开始时间的binlog日志"></a>输出指定开始时间的binlog日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --start-datetime&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot; binlog文件</span><br></pre></td></tr></table></figure>
<h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><p>获取当前日期+时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select now();</span><br><span class="line">+---------------------+</span><br><span class="line">| now()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2019-06-05 21:30:43 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>获得当前时间戳函数：current_timestamp, current_timestamp()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select current_timestamp, current_timestamp();</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| current_timestamp   | current_timestamp() |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2019-06-05 21:31:36 | 2019-06-05 21:31:36 |</span><br><span class="line">+---------------------+---------------------+</span><br></pre></td></tr></table></figure>
<p>日期/时间转换为字符串</p>
<p>函数：date_format(date,format), time_format(time,format)能够把一个日期/时间转换成各种各样的字符串格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select date_format(&#39;2019-06-05 21:31:36&#39;,&#39;%Y%m%d%H%i%s&#39;);</span><br><span class="line">+---------------------------------------------------+</span><br><span class="line">| date_format(&#39;2019-06-05 21:31:36&#39;,&#39;%Y%m%d%H%i%s&#39;) |</span><br><span class="line">+---------------------------------------------------+</span><br><span class="line">| 20190605213136                                    |</span><br><span class="line">+---------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>字符串转换为日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数：str_to_date(str, format)</span><br><span class="line"></span><br><span class="line">mysql&gt; select str_to_date(&#39;2019-06-05 21:31:36&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;);</span><br><span class="line">+--------------------------------------------------------+</span><br><span class="line">| str_to_date(&#39;2019-06-05 21:31:36&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;) |</span><br><span class="line">+--------------------------------------------------------+</span><br><span class="line">| 2019-06-05 21:31:36                                    |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>Unix 时间戳、日期转换函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix_timestamp(),</span><br><span class="line">unix_timestamp(date),</span><br><span class="line">from_unixtime(unix_timestamp),</span><br><span class="line">from_unixtime(unix_timestamp,format)</span><br><span class="line"></span><br><span class="line">mysql&gt; select unix_timestamp();</span><br><span class="line">+------------------+</span><br><span class="line">| unix_timestamp() |</span><br><span class="line">+------------------+</span><br><span class="line">|       1559742262 |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; mysql&gt; select unix_timestamp(&#39;2019-06-05&#39;);</span><br><span class="line">+------------------------------+</span><br><span class="line">| unix_timestamp(&#39;2019-06-05&#39;) |</span><br><span class="line">+------------------------------+</span><br><span class="line">|                   1559664000 |</span><br><span class="line">+------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; mysql&gt; select unix_timestamp(&#39;2019-06-05 21:31:36&#39;);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| unix_timestamp(&#39;2019-06-05 21:31:36&#39;) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                            1559741496 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select from_unixtime(1559742262);</span><br><span class="line">+---------------------------+</span><br><span class="line">| from_unixtime(1559742262) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2019-06-05 21:44:22       |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select from_unixtime(1559664000);</span><br><span class="line">+---------------------------+</span><br><span class="line">| from_unixtime(1559664000) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2019-06-05 00:00:00       |</span><br><span class="line">+---------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select from_unixtime(1559741496);</span><br><span class="line">+---------------------------+</span><br><span class="line">| from_unixtime(1559741496) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2019-06-05 21:31:36       |</span><br><span class="line">+---------------------------+</span><br></pre></td></tr></table></figure>
<p>日期时间计算函数</p>
<p>为日期增加一个时间间隔：date_add()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select date_add(now(),interval 1 day);</span><br><span class="line">+--------------------------------+</span><br><span class="line">| date_add(now(),interval 1 day) |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| 2019-06-06 21:52:50            |</span><br><span class="line">+--------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select date_add(now(),interval 1 hour);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 minute);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 second);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 microsecond);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 week);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 month);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 quarter);</span><br><span class="line">mysql&gt; select date_add(now(),interval 1 year);</span><br><span class="line"></span><br><span class="line">select date_add(now(), interval -1 day);</span><br></pre></td></tr></table></figure>
<p>为日期减去一个时间间隔：date_sub()</p>
<p>时区（timezone）转换函数</p>
<p>函数：convert_tz(dt,from_tz,to_tz)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select convert_tz(&#39;2019-06-05 12:00:00&#39;, &#39;+08:00&#39;, &#39;+00:00&#39;);</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| convert_tz(&#39;2019-06-05 12:00:00&#39;, &#39;+08:00&#39;, &#39;+00:00&#39;) |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| 2019-06-05 04:00:00                                   |</span><br><span class="line">+-------------------------------------------------------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6笔记</title>
    <url>/2019/02/08/ES6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li><p>let命令</p>
<p> let声明的变量只在它所在的代码块有效。</p>
<p> for循环的计数器,就很适合使用let命令.</p>
<p> let不存在变量提升,即一定要在声明后使用，否则报错。</p>
<p> let不允许在相同作用域内，重复声明同一个变量</p>
<p> ES6 允许块级作用域的任意嵌套。</p>
</li>
<li><p>const命令</p>
<p> const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p> 这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p> const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
</li>
</ol>
<ol start="3">
<li><p>函数的扩展</p>
<p> ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
</li>
</ol>
<ol start="4">
<li><p>箭头函数</p>
<p> ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<p> 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<p> 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<p> 箭头函数的一个用处是简化回调函数。</p>
</li>
</ol>
<ol start="5">
<li>数组的扩展</li>
</ol>
<ul>
<li><p>Array.from()</p>
<p>  Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>  只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组</p>
<p>  扩展运算符（…）也可以将某些数据结构转为数组.</p>
<p>  Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组.</p>
<p>  Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
</li>
<li><p>Array.of()</p>
<p>  Array.of方法用于将一组值，转换为数组</p>
</li>
<li><p>数组实例的copyWithin()</p>
<p>  数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
</li>
<li><p>数组实例的find()和findIndex()</p>
<p>  数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
</li>
<li><p>数组实例的fill()</p>
<p>  fill方法使用给定值，填充一个数组。</p>
<p>  fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(5) - 镜像和仓库</title>
    <url>/2019/02/07/Docker(5)%20-%20%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="1、列出镜像"><a href="#1、列出镜像" class="headerlink" title="1、列出镜像"></a>1、列出镜像</h2><pre><code>sudo docker images

sudo docker images fedora //列出指定镜像名（如fedora）的镜像</code></pre><ul>
<li><p>镜像是从仓库中下载下来。镜像保存在仓库中，而仓库位于Register中。默认的Register式Docker公司提供的register服务，即Docker Hub</p>
</li>
<li><p>为了区分同一仓库中的不同镜像，Docker提供来一种称为标签（tag）的功能</p>
</li>
<li><p>运行一个带标签的镜像</p>
<pre><code>sudo docker run -i -t --name new_container ubuntu:12.04 /bin/bash</code></pre></li>
<li><p>一个镜像可以有多个标签，这使我们可以方便的对镜像进行打标签，并且很容器查找镜像</p>
</li>
<li><p>在构建容器时，==指定镜像的标签是一个很好的习惯==，可以准确的知道容器来源于哪里。</p>
</li>
<li><p>Docker Hub中有两种类型的仓库：==用户仓库==（user repository）和==顶层仓库==（top-level repository).</p>
</li>
<li><p>用户仓库的命名由用户名和仓库名两部分组成，如richey/my_repo</p>
</li>
</ul>
<h2 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h2><ul>
<li><p>用docker run 命令创建并启动一个容器的时候，如果指定的镜像不在本地，Docker会先从Docker Hub下载该镜像。如果没有指定具体的镜像标签，那么Docker会自动下载latest标签的镜像。</p>
</li>
<li><p>也可以通过docker pull命令先将镜像拉取到本地</p>
<pre><code>sudo docker pull ubuntu:12.04</code></pre></li>
</ul>
<h2 id="3、查找镜像"><a href="#3、查找镜像" class="headerlink" title="3、查找镜像"></a>3、查找镜像</h2><ul>
<li><p>可以通过docker search命令来查找所有Docker Hub上公共的可用镜像</p>
<pre><code>sudo docker search fedora    </code></pre></li>
<li><p>也可以在Docker Hub网站上在线查找可用镜像</p>
</li>
</ul>
<h2 id="4、构建镜像"><a href="#4、构建镜像" class="headerlink" title="4、构建镜像"></a>4、构建镜像</h2><ul>
<li><p>登录Docker Hub</p>
<pre><code>docker login //登录

docker logout //退出</code></pre></li>
<li><p>登录后会将用户的个人信息保存到$HOME/.docker/config.json中</p>
</li>
</ul>
<ul>
<li><p>Docker 构建镜像有两种方法</p>
<ul>
<li>使用docker commit命令（不推荐）</li>
<li>使用docker build命令和Dockerfile文件</li>
</ul>
</li>
</ul>
<h3 id="使用docker-commit-命令创建镜像"><a href="#使用docker-commit-命令创建镜像" class="headerlink" title="使用docker commit 命令创建镜像"></a>使用docker commit 命令创建镜像</h3><p>可以将此想象成我们往版本控制系统里提交变更。我们先创建一个容器，并在容器里作出修改，就像改代码一样，最后将修改提交为一个新的镜像。</p>
<ol>
<li><p>创建一个要进行修改的容器</p>
<pre><code>sudo docker run -i -t ubuntu /bin/bash</code></pre></li>
<li><p>安装apache软件包</p>
<pre><code>apt-get -y update

apt-get -y install apache2</code></pre></li>
<li><p>exit从容器里退出后运行docker commit命令</p>
<p> sudo docker commit -m “A new custom image” -a “Richey”  2c2224ec5ea3 richey/testrepo:test-commit</p>
<ul>
<li>-m 用来指定创建新镜像时的提交信息</li>
<li>-a 镜像的作者信息</li>
</ul>
</li>
</ol>
<h3 id="用Dockerfile构建镜像"><a href="#用Dockerfile构建镜像" class="headerlink" title="用Dockerfile构建镜像"></a>用Dockerfile构建镜像</h3><p>推荐使用被成为Dockerfile的定义文件和docker build命令来构建镜像，因为这种方式更具备可重复性、透明性、幂等性。</p>
<p>一有了Dockerfile，我们就可以用docker build命令基于该Dockerfile中的指令创建一个新的镜像。</p>
<p>这里我们以创建一个包含简单的Web服务器的Docker镜像为例，说明如何使用Dockerfile文件构建镜像：</p>
<ul>
<li><p>创建一个目录，并在里面创建初始的Dockerfile文件；</p>
<pre><code>mkdir static_web_context
cd mkdir static_web_context
touch Dockerfile    </code></pre></li>
</ul>
<pre><code>static_web_context目录：这就是我们的构建环境，Docker称此环境为上下文（context）或构建上下文（build context）。Docker在构建镜像时会将该上下文和上下文中的目录及文件上传到Docker守护进程。这样守护进程就能直接访问用户想在镜像中存储的任何代码、文件或其它数据。

Dockerfile：这里我们创建了一个空的Dockerfile文件，Dockerfile文件由一系列的指令和参数组成，每条指令都必须时大写字母，且后面要跟一个参数。Dockerfile中的指令会按照顺序从上往下执行。

    #version:0.0.1
    FROM ubuntu:16.04
    MAINTAINER Richey &quot;xx.xx@gmail.com&quot;
    RUN apt-get update &amp;&amp; apt-get install -y nginx
    RUN echo &apos;Hi,I am in your container&apos; &gt; /usr/share/nginx/html/index.html
    EXPOSE 80

每条指令都会创建一个镜像层并对镜像进行提交，所以当通过Dockerfile构建镜像时，即使由于某些原因（比如Dockerfile中的某条命令执行失败了），没有正常结束，我们仍然可以得到一个可用的镜像。这对调试非常的有作用，我们可以通过运行该镜像得到一个可以交互的容器，然后执行失败的命令，查看失败的具体原因，以此对Dockerfile文件中的指令进行修改等操作，调试完后通过新的Dockerfile文件重新构建镜像。

Dockerfile文件支持注释，以#开头的行会被认为是注释

每个Dockerfile文件的第一行必须时FROM，FROM用于指定一个已存在的镜像，后续指令都将基于该镜像执行，该镜像被成为基础镜像。

MAINTAIN指令用来说明该镜像的作者及邮箱等信息

RUN指令会在当前镜像中运行指定的命令，RUN指令可以有多条，每条RUN指令都会创建一个新的镜像层。默认情况下RUN指令会在shell里面使用命令包装器/bin/sh -c执行。如果在不支持shell的平台运行或不希望在shell中执行，也可以使用exec格式的RUN指令，如：

    RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]

EXPOSE指令，这条命令告诉Docker，该容器向外部宿主机公开的端口，可以公开多个端口。但并非设置该参数后，就可以随意访问该容器的这些端口，Docker并不会自打开这些端口，需要用户使用docker run时来指定需要打开哪些端口。

Docker也使用EXPOSE指令来帮助将多个容器链接，用户也可以在运行时在运行docker run 命令时通过--expose选项来指定对外公开的端口。</code></pre><ul>
<li><p>基于Dockerfile构建新镜像</p>
<p>  上面我们已经创建了一个简单的构建上下文环境（docker context）和Dockerfile文件,下面我们基于此构建一个新的镜像。</p>
<p>  执行docker build命令时，Dockerfile中的所有指令都会被执行且提交，该命令执行成功后会得到一个新的镜像。</p>
<pre><code>cd static_web_context/
sudo docker build -t &quot;richey/static_web:v1&quot; .</code></pre><p>  -t参数为镜像设置了仓库和名称,以及标签v1，如果没有指定任何标签，Docker将为镜像设置一个latest标签。</p>
<p>  上面命令后面的点（.）告诉Docker到本地目录中去寻找Dockerfile文件，也可以指定一个Git仓库的源地址来指定Dockerfile的位置，当然该Git仓库的根目录下面要存在Dockerfile文件。</p>
<p>  自Docker1.5.0以后,也可以通过-f参数指定一个区别于标准Dockerfile构建源的位置，如：</p>
<pre><code>docker build -t &quot;richey/static_web&quot; -f path/file</code></pre><p>  这个文件可以不必命名为Dockerfile，但是必须要位于构建上下文（build context）中。</p>
<p>  在构建上下文目录中，可以设置.dockerignor文件来过滤匹配模式。</p>
</li>
</ul>
<h3 id="Dockerfile和构建缓存"><a href="#Dockerfile和构建缓存" class="headerlink" title="Dockerfile和构建缓存"></a>Dockerfile和构建缓存</h3><p>由于每一步的构建过程都会将结果提交为镜像，所以Docker会将每一层的镜像看作缓存，比如当我们构建出错，修改后重新构建时，不会重新从地一层开始构建，会直接基于缓存从发生变化了的指令开始构建，这样会省很多时间.</p>
<p>如果要确保不使用缓存可以用docker build的–nocache参数:</p>
<pre><code>docker build --nocache -t &quot;richey/static_web&quot; .</code></pre><h3 id="基于构建缓存的Dockerfile模板"><a href="#基于构建缓存的Dockerfile模板" class="headerlink" title="基于构建缓存的Dockerfile模板"></a>基于构建缓存的Dockerfile模板</h3><p>可以通过在Dockerfile文件的顶部使用相同的人指令集模板,从而尽可能的确保缓存命中,例如:</p>
<pre><code>FROM fedora:26
MAINTAINER Richey &quot;brin.baolin@gmail.com&quot;
ENV REFRESHED_AT 2017-01-08
RUN dnf -q update</code></pre><p>这里通过ENV指令设置了一个环境变量REFRESHED_AT,用来记录该模板的最后更新时间.有了这个模板,如果我们要刷新构建,只需要更改ENV指令中的日期,Docker就会从ENV指令这行开始重置缓存.</p>
<h3 id="从镜像中启动一个容器"><a href="#从镜像中启动一个容器" class="headerlink" title="从镜像中启动一个容器"></a>从镜像中启动一个容器</h3><pre><code>sudo docker run -i -t -d -p 80 --name my_static_web  richey/static_web:v1</code></pre><p>-d:以detached,分离的方式在后台运行<br>-p:控制Docker在运行时公开哪些网络端口给宿主机</p>
<ul>
<li>运行一个容器时,Docker可用通过两种方式来在宿主机上分配端口:<ul>
<li>Docker可以在宿主上随机选择一个32768~61000的一个比较大的端口来映射到容器中的80端口上</li>
<li>可以在Docker宿主机中指定一个具体的端口号来映射到容器的80端口上</li>
</ul>
</li>
</ul>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><pre><code>docker push  NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code></pre><h3 id="docker-rmi-删除镜像"><a href="#docker-rmi-删除镜像" class="headerlink" title="docker rmi  删除镜像"></a>docker rmi  删除镜像</h3><h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><ul>
<li><p>查看系统中的镜像</p>
<pre><code>sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
richey/static_web   v1                  8cf769dd27de        26 hours ago        206 MB
docker.io/ubuntu    16.04               00fd29ccc6f1        3 weeks ago         111 MB</code></pre></li>
<li><p>列出指定镜像名（如fedora）的镜像</p>
<pre><code>sudo docker images fedora</code></pre></li>
</ul>
<ul>
<li><p>查看镜像详细信息</p>
<pre><code>sudo docker inspect richey/testreps:test-commit</code></pre></li>
<li><p>得到刚创建的容器的id</p>
<pre><code>sudo docker ps -l -q</code></pre></li>
</ul>
<ul>
<li><p>如果想探究镜像是如何被构建出来的,可以使用docker history命令</p>
<pre><code>[richey@192 ~]$ sudo docker history 8cf769dd27de</code></pre></li>
</ul>
<ul>
<li><p>运行一个带标签的镜像</p>
<pre><code>sudo docker run -i -t --name new_container ubuntu:12.04 /bin/bash</code></pre></li>
<li><p>拉去镜像(docker run 的时候,如果本地没有会自动从仓库拉取)</p>
<pre><code>sudo docker pull ubuntu:12.04</code></pre></li>
<li><p>查找镜像</p>
<pre><code>sudo docker search fedora</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker（4）- 入门（命令）</title>
    <url>/2019/02/06/Docker%EF%BC%884%EF%BC%89-%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%91%BD%E4%BB%A4%EF%BC%89/</url>
    <content><![CDATA[<h1 id="启动和关闭守护进程"><a href="#启动和关闭守护进程" class="headerlink" title="启动和关闭守护进程"></a>启动和关闭守护进程</h1><h2 id="在Red-Hat系发行版中启动Docker守护进程"><a href="#在Red-Hat系发行版中启动Docker守护进程" class="headerlink" title="在Red Hat系发行版中启动Docker守护进程"></a>在Red Hat系发行版中启动Docker守护进程</h2><h3 id="在RHEL-6或CentOS-6中"><a href="#在RHEL-6或CentOS-6中" class="headerlink" title="在RHEL 6或CentOS 6中"></a>在RHEL 6或CentOS 6中</h3><ul>
<li><p>启动/关闭Docker服务</p>
<pre><code>sudo service docker start　　　　
sudo service docker stop</code></pre></li>
<li><p>确保在RHEL 6中开机启动Docker</p>
<pre><code>sudo service docker enable</code></pre></li>
</ul>
<h3 id="在RHEL-7或Fedora中"><a href="#在RHEL-7或Fedora中" class="headerlink" title="在RHEL 7或Fedora中"></a>在RHEL 7或Fedora中</h3><ul>
<li><p>启动/关闭Docker服务</p>
<pre><code>sudo systemctl start docker
sudo systemctl stop docker</code></pre></li>
</ul>
<ul>
<li><p>在系统开机自动启动Docker服务</p>
<pre><code>sudo systemctl enable docker</code></pre></li>
<li><p>检查Docker是否正确安装</p>
<pre><code>sudo docker info</code></pre></li>
</ul>
<h1 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h1><ul>
<li><p>==docker run==命令提供了Docker容器的创建到启动的功能</p>
<pre><code>docker run -i -t ubuntu /bin/bash</code></pre><ul>
<li><p>-i 标志保证STDIN是开启的    </p>
</li>
<li><p>-t 则告诉Docker要为创建的容器分配一个伪tty终端。</p>
</li>
<li><p>若要在命令行下创建一个能与之进行交互的容，而不是一个运后台服务的容器，这两个参数是最基本的参数</p>
</li>
<li><p>ubuntu 告诉Docker我们要基于ubuntu镜像来创建容器(ubuntu镜像是一个常备镜像，也可以称之为“基础”镜像)。首先docker会检查本地是否有ubuntu镜像，如果没有的话就会去Docker Hub中找，找到后会下载并保存该镜像到本地宿主机中。</p>
</li>
<li><p>/bin/bash 告诉Docker在新容器中要运行什么命令</p>
</li>
</ul>
</li>
</ul>
<h1 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h1><ul>
<li><p>检查容器的主机名</p>
<pre><code>homename //可以看到容器的主机名就是容器的ID</code></pre></li>
<li><p>查看容器的/etc/hosts文件，发现Docker已经在hosts文件中为该容器的ip添加来一条主机配置项</p>
</li>
</ul>
<h1 id="查看当前系统中的容器列表"><a href="#查看当前系统中的容器列表" class="headerlink" title="查看当前系统中的容器列表"></a>查看当前系统中的容器列表</h1><pre><code>docker ps -a //查看所有容器

docker ps //只能看到正在运行的容器

docker ps -l //列出最后一个运行的容器

docker ps -n x //显示最后x个容器，不论这些容器正在运行还是已停止</code></pre><h1 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h1><ul>
<li><p>Docker会为我们创建的每一个容器自动生成一个随机的名称</p>
</li>
<li><p>可以通过 –name 参数指定容器的名字</p>
<pre><code>docker run --name my_container -i -t ubuntu /bin/bash</code></pre></li>
</ul>
<h1 id="删除已存在容器"><a href="#删除已存在容器" class="headerlink" title="删除已存在容器"></a>删除已存在容器</h1><pre><code>docker rm my_container

docker rm &apos;sudo docker ps -a -q&apos;</code></pre><h1 id="重新启动已停止的容器"><a href="#重新启动已停止的容器" class="headerlink" title="重新启动已停止的容器"></a>重新启动已停止的容器</h1><pre><code>sudo docker start my_container

sudo docker restart my_container //也可以重启一个容器</code></pre><h1 id="附着到容器上"><a href="#附着到容器上" class="headerlink" title="附着到容器上"></a>附着到容器上</h1><ul>
<li><p>我们可以用docker attach命令，附着到容器的会话上</p>
<pre><code>sudo docker attach my_container</code></pre></li>
<li><p>注意：如果退出容器的shell，==容器会停止运行==</p>
</li>
</ul>
<h1 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h1><ul>
<li><p>守护式容器没有交互式会话，非常适合运行应用程序和服务</p>
<pre><code>sudo docker run --name daemon_container -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; down&quot;</code></pre></li>
<li><p>使用来-d参数，因此Docker会将容器放在后台运行。</p>
</li>
</ul>
<h1 id="获取docker容器的日志"><a href="#获取docker容器的日志" class="headerlink" title="获取docker容器的日志"></a>获取docker容器的日志</h1><ul>
<li><p>可以用docker logs命令来获取容器的日志</p>
<pre><code>docker logs daemon_container //输出最后几条日志并返回

docker logs -f daemon_container //类似于tail -f

docker logs --tail 10 daemon_container //最后10行

docker logs --tail 0 -f daemon_container //跟踪容器的最新日志

docker logs -ft daemon_containner //-t 为日志加上时间戳</code></pre></li>
</ul>
<h1 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h1><pre><code>sudo docker top daemon_containner</code></pre><h1 id="Docker统计信息"><a href="#Docker统计信息" class="headerlink" title="Docker统计信息"></a>Docker统计信息</h1><pre><code>docker stats</code></pre><h1 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h1><ul>
<li><p>可以通过docker exec命令在容器内部额外启动新进程</p>
</li>
<li><p>可以在容器中运行的进程有两种类型：后台任务和交互任务</p>
<ul>
<li><p>后台命令</p>
<pre><code>sudo docker exec -d richey_ubuntu_container touch /etc/new_test_config_file</code></pre></li>
<li><p>交互式命令</p>
<pre><code>sudo docker exec -t -i richey_ubuntu_container /bin/bash</code></pre></li>
</ul>
</li>
</ul>
<h1 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h1><ul>
<li><p>可以通过–restart标志自动重启容器</p>
<pre><code>sudo docker run --restart=always --name daemon_container -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; down&quot;

sudo docker run --restart=on-failure:5 --name daemon_container -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; down&quot;</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker（3）- 守护进程</title>
    <url>/2019/02/05/Docker%EF%BC%883%EF%BC%89-%20%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Docker守护进程"><a href="#Docker守护进程" class="headerlink" title="Docker守护进程"></a>Docker守护进程</h1><ul>
<li><p>Docker软件包安装完毕后，默认会立即启动Docker守护进程</p>
</li>
<li><p>守护进程监听/var/run/docker.sock这个Unix套接字文件，来获取来自客户端Docker的请求</p>
</li>
<li><p>如果系统中存在名为docker的用户组的话，Docker则会将该套接字文件的所有者设为该用户组，这样docker用户组的所有者就可以直接运行Docker，而无需使用Docker命令了。</p>
</li>
<li><p>安装完Docker后要确认Docker的守护进程是否运行</p>
</li>
<li><p>Docker进程是Docker守护进程的客户端程序</p>
</li>
<li><p>使用 ==docker daemon==命令控制Docker守护进程（该命令已经过时了，1.6后会被弃用）</p>
</li>
</ul>
<h2 id="配置Docker守护进程"><a href="#配置Docker守护进程" class="headerlink" title="配置Docker守护进程"></a>配置Docker守护进程</h2><ul>
<li><p>运行Docker守护进程时，可以用-H标志调整守护进程绑定监听接口的方式</p>
</li>
<li><p>使用-H标志指定不同的网络接口和端口配置</p>
<pre><code>sudo docker daemon -H tcp:0.0.0.0:2375</code></pre></li>
<li><p>如果把守护进程或端口改成4200，那么运行客户端时就必须指定</p>
<pre><code>docker -H :4200</code></pre></li>
<li><p>如果不想每次运行客户端都加上-H标志，可以设置DOCKER_HOST环境变量来省略此步骤</p>
<pre><code>export DOCKER_HOST=&quot;tcp://0.0.0.0:2375&quot;</code></pre></li>
<li><p>也能通过-H标志指定一个Unix套接字路径</p>
<pre><code>sudo docker daemon -H unix://home/docker/docker.sock

sudo docker daemon -H tcp:0.0.0.0:2375 -H unix://home/docker/docker.sock</code></pre></li>
<li><p>如果Docker运行在代理或者公司防火墙之后，也可以使用THHPS_PROXY、HTTP_PROX和NO_PROXY选项来控制守护进程如何连接</p>
</li>
<li><p>还可以用-D标志来输出Docker守护进程更详细的信息</p>
<pre><code>sudo docker daemon -D</code></pre></li>
</ul>
<h2 id="检查Docker守护进程是否在运行"><a href="#检查Docker守护进程是否在运行" class="headerlink" title="检查Docker守护进程是否在运行"></a>检查Docker守护进程是否在运行</h2><h3 id="在Ubuntu中"><a href="#在Ubuntu中" class="headerlink" title="在Ubuntu中"></a>在Ubuntu中</h3><ul>
<li><p>如果Docker是通过软件包安装的话，可以用Upstart的status命令来检查Docker守护进程是否在运行及启动停止Docker进程等操作</p>
<pre><code>sudo status docker

sudo stop docker

sudo start docker</code></pre></li>
</ul>
<h3 id="在Red-Hat和Fedora中启动和停止Docker"><a href="#在Red-Hat和Fedora中启动和停止Docker" class="headerlink" title="在Red Hat和Fedora中启动和停止Docker"></a>在Red Hat和Fedora中启动和停止Docker</h3><pre><code>sudo service docker stop

sudo service docker start</code></pre>]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker（2）- 安装</title>
    <url>/2019/02/04/Docker%EF%BC%882%EF%BC%89-%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><ul>
<li><p>目前Docker团队推荐在UBuntu、Debian或者RHEL系列（CentOS、Fedora等）宿主机中部署Docker。</p>
</li>
<li><p>Docker也支持一些云平台</p>
</li>
<li><p>Docker目前只能运行在64位CPU架构的计算机上</p>
</li>
<li><p>运行Linux3.8或更高版本的内核</p>
</li>
</ul>
<h2 id="检查前提条件"><a href="#检查前提条件" class="headerlink" title="检查前提条件"></a>检查前提条件</h2><ul>
<li><p>内核3.8及以上</p>
<pre><code>uname -a</code></pre></li>
</ul>
<h2 id="在Ubuntu和Debian中安装Docker"><a href="#在Ubuntu和Debian中安装Docker" class="headerlink" title="在Ubuntu和Debian中安装Docker"></a>在Ubuntu和Debian中安装Docker</h2><h2 id="在Red-Hat和Red-Hat系发行办版中安装Docker"><a href="#在Red-Hat和Red-Hat系发行办版中安装Docker" class="headerlink" title="在Red Hat和Red Hat系发行办版中安装Docker"></a>在Red Hat和Red Hat系发行办版中安装Docker</h2><h3 id="1、在RHEL-6和CentOS-6中安装Docker"><a href="#1、在RHEL-6和CentOS-6中安装Docker" class="headerlink" title="1、在RHEL 6和CentOS 6中安装Docker"></a>1、在RHEL 6和CentOS 6中安装Docker</h3><h3 id="2、在RHEL-7中安装Docker"><a href="#2、在RHEL-7中安装Docker" class="headerlink" title="2、在RHEL 7中安装Docker"></a>2、在RHEL 7中安装Docker</h3><h3 id="3、在Fedora中安装Docker"><a href="#3、在Fedora中安装Docker" class="headerlink" title="3、在Fedora中安装Docker"></a>3、在Fedora中安装Docker</h3><ul>
<li><p>在Fedora 19安装Docker</p>
<pre><code>sudo yum -y install docker-io</code></pre></li>
<li><p>在Fedora 20或更高版本中安装Docker</p>
<pre><code>sudo yum -y install docker</code></pre></li>
<li><p>在Fodora 21中，软件包名称又回退到了docker-io</p>
<pre><code>sudo yum -y install docker-io</code></pre></li>
<li><p>最后到了Fedora 22，软件包名称则又变回了docker</p>
<pre><code>sudo dnf install docker</code></pre></li>
</ul>
<blockquote>
<p>具体的安装文档可以在官方文档中找到</p>
</blockquote>
<p><a href="https://docs.docker.com/engine/installation/linux/docker-ee/oracle/" target="_blank" rel="noopener">在Linux上安装Docker的文档</a></p>
<blockquote>
<p>也可以直接从Docker官方网站下载RHEL、CentOS和Fedora用的罪行RPM包</p>
</blockquote>
<h2 id="Docker安装脚本"><a href="#Docker安装脚本" class="headerlink" title="Docker安装脚本"></a>Docker安装脚本</h2><ul>
<li><p>使用远程安装脚本在宿主机上安装Docker，<a href="get.docker.com">get.docker.com</a>网站获取这个安装脚本</p>
</li>
<li><p>目前该脚本只支持在Ubuntu、Fedora、Debian和Gentoo中安装Docker</p>
</li>
</ul>
<h3 id="首先要确认curl命令已经安装"><a href="#首先要确认curl命令已经安装" class="headerlink" title="首先要确认curl命令已经安装"></a>首先要确认curl命令已经安装</h3><pre><code>whereis curl</code></pre><h3 id="安装curl"><a href="#安装curl" class="headerlink" title="安装curl"></a>安装curl</h3><ul>
<li><p>Ubuntu中安装     </p>
<pre><code>sudo apt-get -y install curl</code></pre></li>
<li><p>Fedora中安装curl</p>
<pre><code>sudo dnf install curl</code></pre></li>
</ul>
<h3 id="利用安装脚本来安装Docker"><a href="#利用安装脚本来安装Docker" class="headerlink" title="利用安装脚本来安装Docker"></a>利用安装脚本来安装Docker</h3><pre><code>curl https://get.docker.com/ | sudo sh</code></pre>]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker（１）- 简介</title>
    <url>/2019/02/03/Docker%EF%BC%88%EF%BC%91%EF%BC%89-%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>虚拟机：通过中间层将一台或多台独立的机器运行在物理硬件之上</p>
</li>
<li><p>容器：直接运行在操作系统内核之上的空间</p>
</li>
<li><p>由于“客居”于操作系统，容器只能运行与底层宿主机相同或相似的操作系统</p>
</li>
<li><p>在自己的权限范围内，容器更像是一个完整的宿主机，对于Docker来说，容器和宿主机之间的隔离更加彻底，容器有独立的网络和存储栈，还拥有自己的资源管理能力，使得同一台宿主机中的多个容器可以友好的共存。</p>
</li>
<li><p>Docker是一个能够把开发的应用程序自动部署到容器中的开源引擎。</p>
</li>
<li><p>大多数Docker容器只需要不到１秒就可以启动</p>
</li>
<li><p>Docker推荐单个容器只运行一个应用程序或进程。</p>
</li>
</ul>
<h1 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h1><ul>
<li><p>Docker客户端和服务器，也称Docker引擎</p>
</li>
<li><p>Docker镜像</p>
</li>
<li><p>Registry</p>
</li>
<li><p>Docker容器</p>
</li>
</ul>
<h1 id="Docker客户端和服务端"><a href="#Docker客户端和服务端" class="headerlink" title="Docker客户端和服务端"></a>Docker客户端和服务端</h1><ul>
<li><p>Docker十一个客户端/服务端（C/S）架构的程序</p>
</li>
<li><p>Docker客戶端只需要向Docker服务器端或守护进程发送请求，服务器或守护进程将完成所有工作，并返回结果。</p>
</li>
<li><p>Docker守护进程有时候也称为Docker引擎</p>
</li>
<li><p>Docker提供了命令行工具docker以及一整套的RESTful API来与守护今年成进行交互。</p>
</li>
<li><p>Docker可以在同一台宿主机上运行守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
</li>
</ul>
<p><img src="http://orybhlel7.bkt.clouddn.com/image/jpg/Docker-architecture.png" alt="image"></p>
<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><ul>
<li><p>镜像是Docker世界的基石，用户基于镜像来运行自己的容器</p>
</li>
<li><p>也可以把镜像当作是容器的“源代码”，镜像体积很小，非常的“便携”，易于分享、存储和更新</p>
</li>
</ul>
<h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><ul>
<li><p>Docker用Registry来保存用户构建的镜像。</p>
</li>
<li><p>Registry分为共有和私有两种。Docker公司运营的公有Registry叫做Docker Hub。</p>
</li>
</ul>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul>
<li><p>Docker可以帮助用户构建和部署容器，用户只要把自己的应用程序或服务打包放进容器即可。</p>
</li>
<li><p>容器是基于镜像启动的</p>
</li>
<li><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实战之容器备份、恢复、迁移</title>
    <url>/2019/02/02/Docker%20%E5%AE%9E%E6%88%98%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%A4%87%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<ol>
<li>备份容器<br>首先，为了备份Docker中的容器，我们会想看看我们想要备份的容器列表。要达成该目的，我们需要在我们运行着Docker引擎，并已创建了容器的Linux机器中运行 docker ps 命令。</li>
</ol>
<h1 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h1><p>Docker Containers List</p>
<p>在此之后，我们要选择我们想要备份的容器，然后去创建该容器的快照。我们可以使用 docker commit 命令来创建快照。</p>
<h1 id="docker-commit-p-30b8f18f20b4-container-backup"><a href="#docker-commit-p-30b8f18f20b4-container-backup" class="headerlink" title="docker commit -p 30b8f18f20b4 container-backup"></a>docker commit -p 30b8f18f20b4 container-backup</h1><p>Docker Commit</p>
<p>该命令会生成一个作为Docker镜像的容器快照，我们可以通过运行 docker images 命令来查看Docker镜像，如下。</p>
<h1 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h1><p>Docker Images</p>
<p>正如我们所看见的，上面做的快照已经作为Docker镜像保存了。现在，为了备份该快照，我们有两个选择，一个是我们可以登录进Docker注册中心，并推送该镜像；另一个是我们可以将Docker镜像打包成tar包备份，以供今后使用。</p>
<p>如果我们想要在Docker注册中心上传或备份镜像，我们只需要运行 docker login 命令来登录进Docker注册中心，然后推送所需的镜像即可。</p>
<h1 id="docker-login-172-16-101-192"><a href="#docker-login-172-16-101-192" class="headerlink" title="docker login 172.16.101.192"></a>docker login 172.16.101.192</h1><p>Docker Login</p>
<h1 id="docker-tag-a25ddfec4d2a-arunpyasi-container-backup-test"><a href="#docker-tag-a25ddfec4d2a-arunpyasi-container-backup-test" class="headerlink" title="docker tag a25ddfec4d2a arunpyasi/container-backup:test"></a>docker tag a25ddfec4d2a arunpyasi/container-backup:test</h1><h1 id="docker-push-arunpyasi-container-backup"><a href="#docker-push-arunpyasi-container-backup" class="headerlink" title="docker push arunpyasi/container-backup"></a>docker push arunpyasi/container-backup</h1><p>Docker Push</p>
<p>如果我们不想备份到docker注册中心，而是想要将此镜像保存在本地机器中，以供日后使用，那么我们可以将其作为tar包备份。要完成该操作，我们需要运行以下 docker save 命令。</p>
<h1 id="docker-save-o-container-backup-tar-container-backup"><a href="#docker-save-o-container-backup-tar-container-backup" class="headerlink" title="docker save -o ~/container-backup.tar container-backup"></a>docker save -o ~/container-backup.tar container-backup</h1><p>taking tarball backup</p>
<p>要验证tar包是否已经生成，我们只需要在保存tar包的目录中运行 ls 命令即可。</p>
<ol start="2">
<li>恢复容器<br>接下来，在我们成功备份了我们的Docker容器后，我们现在来恢复这些制作了Docker镜像快照的容器。如果我们已经在注册中心推送了这些Docker镜像，那么我们仅仅需要把那个Docker镜像拖回并直接运行即可。</li>
</ol>
<h1 id="docker-pull-arunpyasi-container-backup-test"><a href="#docker-pull-arunpyasi-container-backup-test" class="headerlink" title="docker pull arunpyasi/container-backup:test"></a>docker pull arunpyasi/container-backup:test</h1><p>Docker Pull</p>
<p>但是，如果我们将这些Docker镜像作为tar包文件备份到了本地，那么我们只要使用 docker load 命令，后面加上tar包的备份路径，就可以加载该Docker镜像了。</p>
<h1 id="docker-load-i-container-backup-tar"><a href="#docker-load-i-container-backup-tar" class="headerlink" title="docker load -i ~/container-backup.tar"></a>docker load -i ~/container-backup.tar</h1><p>现在，为了确保这些Docker镜像已经加载成功，我们来运行 docker images 命令。</p>
<h1 id="docker-images-1"><a href="#docker-images-1" class="headerlink" title="docker images"></a>docker images</h1><p>在镜像被加载后，我们将用加载的镜像去运行Docker容器。</p>
<h1 id="docker-run-d-p-80-80-container-backup"><a href="#docker-run-d-p-80-80-container-backup" class="headerlink" title="docker run -d -p 80:80 container-backup"></a>docker run -d -p 80:80 container-backup</h1><p>Restoring Docker Tarball</p>
<ol start="3">
<li>迁移Docker容器<br>迁移容器同时涉及到了上面两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器。但是，如果我们将镜像打包成tar包备份到了本地，我们只需要拷贝或移动该镜像到我们想要的机器上，加载该镜像并运行需要的容器即可。实施</li>
</ol>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 命令</title>
    <url>/2019/02/01/Docker%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><ul>
<li><p>查看基本信息</p>
<pre><code>docker info  </code></pre></li>
</ul>
<p>是经常用来查看运行状态及版本信息的命令，是整个Docker Daemon守护进程运行状况的缩影，包括容器个数、镜像个数、Daemon版本、使用的存储驱动等信息。</p>
<ul>
<li><p>获取容器的主机名</p>
<pre><code>hostname(这个是linux的基本命令)</code></pre><p>  容器的主机名就是该容器的id，Docker会默认在/etc/hosts中为该容器的ip地址添加一条主机的配置项目</p>
</li>
<li><p>列出所有docker容器</p>
<pre><code>docker ps 会列出所有正在运行的docker容器
docker ps -a 会列出所有docker容器，包括未运行的</code></pre></li>
</ul>
<h1 id="docker-run-命令"><a href="#docker-run-命令" class="headerlink" title="docker run 命令"></a>docker run 命令</h1><p>docker run 命令提供了Docker容器的创建到启动的功能</p>
<ol>
<li><p>端口映射</p>
<p> 可以通过-P或者-p参数指定端口映射</p>
<ul>
<li><p>-P Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
</li>
<li><p>-p（小写）则可以指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器。支持的格式有hostPort:containerPort、ip:hostPort:containerPort、 ip::containerPort。</p>
<ul>
<li><p>hostPort:containerPort（映射所有接口地址）<br>将本地的 5000 端口映射到容器的 5000 端口，可以执行如下命令：<br>$ sudo docker run -d -p 5000:5000 training/webapp python app.py 此时默认会绑定本地所有接口上的所有地址。        </p>
</li>
<li><p>ip:hostPort:containerPort （映射指定地址的指定端口）<br>指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1<br>$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</p>
</li>
<li><p>ip::containerPort （映射指定地址的任意端口）<br>绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。<br>sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py<br>还可以使用 udp 标记来指定 udp 端口<br>$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>-i 标志保证容器的STDIN是开启的，即表示启动一个可交互的容器；</p>
</li>
<li><p>-t 表示使用pseudo-TTY,关联到容器的stdin和stdout，即为创造的容器分配一个伪tty终端；</p>
</li>
<li><p>-d 让容器在后台运行，不关联到当前终端的shell上</p>
</li>
</ol>
<ol start="5">
<li><p>–name容器命名</p>
</li>
<li><p>–restart 设置自动重启容器</p>
<p> –restart=always</p>
<p> –restart=on-failure:5 //当容器退出码为非0的时候重启，最多重启5次</p>
</li>
</ol>
<h1 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h1><pre><code>启动已经停止运行的容</code></pre><h1 id="images相关命令"><a href="#images相关命令" class="headerlink" title="images相关命令"></a>images相关命令</h1><ol>
<li><p>docker iamges</p>
<p> 查看本机镜像列表</p>
<p> 为了区分同一个仓库中的不同镜像，Docker提供了标签（tag）功能，每个镜像在被列出来时都带有一个标签。</p>
</li>
<li><p>拉取镜像</p>
<ul>
<li><p>格式</p>
<p>  [域名/][用户名/]镜像名[:版本号]</p>
<p>  当指定了域名就会从该域名下载，否则就会从Docker Hub进行下载；</p>
<p>  镜像名是必填项，版本号默认是latest</p>
<pre><code>sudo docker pull ubuntu:12.04</code></pre></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>查找Docker Hub镜像</p>
<p> docker search</p>
</li>
<li><p>构建及发布镜像</p>
<p> 具体查看《Docker(5) - 镜像和仓库》</p>
<p> 在push镜像之前要首先tag镜像</p>
</li>
<li><p>删除服务器中无用的docker镜像命令</p>
<pre><code>docker images | grep \&lt;none\&gt; | tr -s &quot; &quot; | cut -d &apos; &apos; -f 3 | xargs docker rmi</code></pre></li>
</ol>
<h1 id="docker-日志相关"><a href="#docker-日志相关" class="headerlink" title="docker 日志相关"></a>docker 日志相关</h1><p>日志分两类，一类是 Docker 引擎日志；另一类是 容器日志。</p>
<ul>
<li><p>Docker 引擎日志</p>
<p>  Docker 引擎日志 一般是交给了 Upstart(Ubuntu 14.04) 或者 systemd (CentOS 7, Ubuntu 16.04)。前者一般位于 /var/log/upstart/docker.log 下，后者一般通过 jounarlctl -u docker 来读取。不同系统的位置都不一样，可以参考：</p>
</li>
</ul>
<pre><code>系统 | 日志位置</code></pre><p>—|—<br>Ubuntu(14.04)|     /var/log/upstart/docker.log<br>Ubuntu(16.04)|     journalctl -u docker.service<br>CentOS 7/RHEL 7/Fedora|     journalctl -u docker.service<br>CoreOS|     journalctl -u docker.service<br>OpenSuSE|     journalctl -u docker.service<br>OSX    | ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/log/d‌​ocker.log<br>Debian|  GNU/Linux 7    /var/log/daemon.log<br>Debian|  GNU/Linux 8    journalctl -u docker.service<br>Boot2Docker|     /var/log/docker.log</p>
<ul>
<li><p>容器的日志</p>
<p>  则可以通过 docker logs 命令来访问，而且可以像 tail -f 一样，使用 docker logs -f 来实时查看。如果使用 Docker Compose，则可以通过 docker-compose logs &lt;服务名&gt; 来查看。</p>
<p>  如果深究其日志位置，每个容器的日志默认都会以 json-file 的格式存储于 /var/lib/docker/containers/&lt;容器id&gt;/&lt;容器id&gt;-json.log 下，不过并不建议去这里直接读取内容，因为 Docker 提供了更完善地日志收集方式 - Docker 日志收集驱动。</p>
</li>
</ul>
<ul>
<li><p>找出当前 Docker 守护进程的默认日志驱动程序，运行 docker info 命令并在输出中找 Logging Driver。</p>
<pre><code>$ docker info | grep &apos;Logging Driver&apos;</code></pre></li>
<li><p>查看某容器使用的日志驱动程序</p>
<pre><code>docker inspect -f &apos;{{.HostConfig.LogConfig.Type}}&apos; container_name</code></pre></li>
<li><p>docker logs 获取容器的日志</p>
<p>  docker logs -f container-name</p>
<p>  docker logs -f –tail 200 container-name</p>
<p>  docker logs -ft container-name //带时间戳是</p>
</li>
<li><p>查看容器日志大小</p>
<p>  假设容器目录为/var/lib/docker/containers，那么执行如下命令</p>
<pre><code>cd /var/lib/docker/containers  #进入默认容器空间目录

du -sh *            #统计文件大小

2.4G  de92a5643f7ffb106f8abba21fc0f93996842917a52879153adc95a73312934a-json.log

#以上这个代表容器de92a5643的日志大小为2.4G</code></pre></li>
<li><p>–log-driver指定日志驱动</p>
</li>
</ul>
<pre><code>驱动程序 | 描述
---|---
none   |    容器没有日志可用,docker logs 什么都不返回
json-file |    日志格式化为 JSON。这是 Docker 默认的日志驱动程序。
syslog|    将日志消息写入 syslog 工具。syslog 守护程序必须在主机上运s行。
journald|    将日志消息写入 journald。journald 守护程序必须在主机上运行。
gelf|    将日志消息写入 Graylog Extended Log Format (GELF) 终端，例如 Graylog 或 Logstash。
fluentd|    将日志消息写入 fluentd（forward input）。fluentd 守护程序必须在主机上运行。
awslogs|    将日志消息写入 Amazon CloudWatch Logs。
splunk|    Writes log messages to splunk using the HTTP Event Collector.
etwlogs|    将日志消息写为 Windows 的 Event Tracing 事件。仅在Windows平台上可用。
gcplogs    |将日志消息写入 Google Cloud Platform (GCP) Logging。
logentries|ss    将日志消息写入 Rapid7 Logentries。</code></pre><ul>
<li><p>增加日志参数</p>
<p>  docker run增加如下参数，限制生成的json.log单个文件大小和保留文件个数：</p>
<pre><code>--log-opt max-size=10m --log-opt max-file=3</code></pre></li>
</ul>
<h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><ul>
<li><p>docker top 查看容器内的进程</p>
<p>  docker top contain_name</p>
</li>
<li><p>docker stats 查看容器统计信息</p>
<p>  docker stats可以查看一个或多个容器的统计信息,包括CPU、内存、网络I/O及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。</p>
<pre><code>docker stats container_name1 container_name1</code></pre></li>
<li><p>docker inspect 获得更多容器信息</p>
<pre><code>docker inspect container_name</code></pre><p>  可以配合-f或者–format标志来选定查看结果</p>
</li>
</ul>
<pre><code>    docker inspect --format=&apos;{{ .State.Running }}&apos; containner_name //查看容器的运行状态

docker inspect --format=&apos;{{ .NetworkSettings.IPAddress }}&apos; containner_name //查看容器的运行状态</code></pre><ul>
<li><p>Docker镜像、容器及容器的配置目录</p>
<p>  /var/lib/docker</p>
</li>
<li><p>docker rm 删除容器</p>
<pre><code>sudo docker rm &apos;sudo docker ps -a -q&apos; //删除所有容器</code></pre><p>  -a 表示列出所有容器</p>
<p>  -q 表示只返回容器的id而不返回容器的其它信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>15、React：React 常用开发调试工具</title>
    <url>/2019/01/15/15%E3%80%81React%EF%BC%9AReact%20%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>主要介绍ESLint、Prettier、React DevTool、Redux DevTool</p>
<h1 id="ESLink"><a href="#ESLink" class="headerlink" title="ESLink"></a>ESLink</h1><p>javascript语法检查和一致性保证的标准</p>
<h1 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h1><p>facebook出的用于格式化代码的工具：</p>
<h1 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h1><p>保证更容易写出风格一致的代码</p>
<h1 id="React-DevTool"><a href="#React-DevTool" class="headerlink" title="React DevTool"></a>React DevTool</h1><p>用来调试React的chrome插件</p>
<h1 id="Redux-DevTool"><a href="#Redux-DevTool" class="headerlink" title="Redux DevTool"></a>Redux DevTool</h1><p>用来调试Redux的chrome插件</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React：最佳实践</title>
    <url>/2019/01/15/React%EF%BC%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><p>在 React 中另一个不同点是你不能通过返回 false的方式阻止默认行为。你必须显式的使用 preventDefault.</p>
<p>阻止组件渲染,可以让 render 方法直接返回 null，而不进行任何渲染。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>Keys 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<p>键（Key）只是在兄弟节点之间必须唯一．</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>使用 React 时，你一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器。React恰恰与之相反，你仅需要在该元素初始渲染的时候添加一个监听器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 为了在回调中使用 &#96;this&#96;，这个绑定是必不可少的</span><br><span class="line">    this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 这种语法确保 &#96;this&#96; 绑定在 &#96;handleClick&#96; 内。</span><br><span class="line">  &#x2F;&#x2F; 注意: 这是 *实验性* 语法。</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;this is:&#39;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&#39;this is:&#39;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这种语法确保 &#96;this&#96; 绑定在 &#96;handleClick&#96; 内。</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>14、React：React Router</title>
    <url>/2019/01/14/14%E3%80%81React%EF%BC%9AReact%20Router/</url>
    <content><![CDATA[<h1 id="为什么需要陆游"><a href="#为什么需要陆游" class="headerlink" title="为什么需要陆游"></a>为什么需要陆游</h1><ol>
<li>单页应用需要进行页面切换</li>
<li>通过URL可以定位到页面</li>
<li>更有语义的组织资源</li>
</ol>
<h1 id="路由实现的基本架构"><a href="#路由实现的基本架构" class="headerlink" title="路由实现的基本架构"></a>路由实现的基本架构</h1><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/react-router.png" alt="image"></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="comment">//BrowserRouter as Router,</span></span><br><span class="line">    HashRouter <span class="keyword">as</span> Router,</span><br><span class="line">    Route,</span><br><span class="line">    Link,</span><br><span class="line">    NavLink,</span><br><span class="line">    Prompt,</span><br><span class="line">    Redirect,</span><br><span class="line">    Switch</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;MemoryRouter&#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./RouterSample.css"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ReactPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>ReactPage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> AngularPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>AngularPage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> VuePage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>VuePage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> NavLinkPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>NavLinkPage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> LoginPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>LoginPage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> HomePage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>HomePage<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> SwitchPage1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SwitchPage1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> SwitchPage2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SwitchPage2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterSample</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> formIsHalfFielledOut = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> loggedIn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;ul id=<span class="string">"menu"</span>&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/LoginPage"</span>&gt;LoginPage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/ReactPage"</span>&gt;ReactPage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/AngularPage"</span>&gt;AngularPage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/VuePage"</span>&gt;VuePage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;NavLink to=<span class="string">"/NavLinkPage"</span> activeClassName=<span class="string">"selected"</span>&gt;NavLinkPage&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/LoginPage"</span> &gt;LoginPage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                        &lt;li&gt;</span><br><span class="line">                            &lt;Link to=<span class="string">"/SwitchPage"</span> &gt;SwitchPage&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>li&gt;</span><br><span class="line">                    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;/</span>*<span class="xml"><span class="tag">&lt;<span class="name">Prompt</span> <span class="attr">to</span>=<span class="string">"/PromptPage"</span> <span class="attr">when</span>=<span class="string">&#123;formIsHalfFielledOut&#125;</span> <span class="attr">message</span>=<span class="string">"确定要离开吗？"</span> /&gt;</span></span>*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                    &lt;div id="page-container"&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;Route path="/</span>ReactPage<span class="string">" component=&#123;ReactPage&#125;/&gt;</span></span><br><span class="line"><span class="string">                        &lt;Route path="</span>/AngularPage<span class="string">" component=&#123;AngularPage&#125;/&gt;</span></span><br><span class="line"><span class="string">                        &lt;Route path="</span>/VuePage<span class="string">" component=&#123;VuePage&#125;/&gt;</span></span><br><span class="line"><span class="string">                        &lt;Route path="</span>/NavLinkPage<span class="string">" component=&#123;NavLinkPage&#125;/&gt;</span></span><br><span class="line"><span class="string">                        &lt;Route exact path="</span>/LoginPage<span class="string">" render=&#123;() =&gt; (</span></span><br><span class="line"><span class="string">                            loggedIn</span></span><br><span class="line"><span class="string">                                ? (&lt;Redirect to="</span>/ReactPage<span class="string">"/&gt;)</span></span><br><span class="line"><span class="string">                                :(&lt;HomePage/&gt;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        )&#125;/&gt;</span></span><br><span class="line"><span class="string">                       &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                           &lt;Route path="</span>/SwitchPage<span class="string">" component=&#123;SwitchPage1&#125;/&gt;</span></span><br><span class="line"><span class="string">                           &lt;Route path="</span>/SwitchPage<span class="string">" component=&#123;SwitchPage2&#125;/&gt;</span></span><br><span class="line"><span class="string">                       &lt;/Switch&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    &lt;/div&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/Router&gt;</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="React-Router的特性"><a href="#React-Router的特性" class="headerlink" title="React Router的特性"></a>React Router的特性</h1><ol>
<li>声明式路由定义</li>
</ol>
<p>可以在页面的任何地方写路由</p>
<ol start="2">
<li>动态路由</li>
</ol>
<h1 id="三种路由实现方式"><a href="#三种路由实现方式" class="headerlink" title="三种路由实现方式"></a>三种路由实现方式</h1><ol>
<li>URL路径</li>
</ol>
<p>BrowserRouter</p>
<ol start="2">
<li>hash路由</li>
</ol>
<p>HashRouter，针对低版本浏览器，url变了页面不刷新的情况<br>3. 内存路由</p>
<p>MemoryRouter，<br>路由并不会反映到url上，通常做服务器端渲染的时候会有用。</p>
<h1 id="基于路由配置进行资源组织"><a href="#基于路由配置进行资源组织" class="headerlink" title="基于路由配置进行资源组织"></a>基于路由配置进行资源组织</h1><ol>
<li>实现业务逻辑的松耦合</li>
<li>易于扩展，重构和维护</li>
<li>路由层面实现Lazy Load</li>
</ol>
<h1 id="React-Router-API"><a href="#React-Router-API" class="headerlink" title="React Router API"></a>React Router API</h1><ol>
<li><Link>:普通链接，不会触发浏览器刷新</li>
<li><p><NavLink>:类似Link但是会添加当前选中状态，增加一个css样式</p>
</li>
<li><p><Prompt>:满足条件时提示用户是否离开当前页面</p>
</li>
<li><p><Redirect>:重定向当前页面，例如登录判断</p>
</li>
<li><p><Route>:路由配的额核心标记，路径匹配时显示对应组件</p>
<p> exact属性：精确匹配<br> Route不是排他的，及可以用时有多个相同path的Route，都会生效</p>
</li>
<li><p><Switch>:只显示第一个匹配的路由</p>
</li>
</ol>
<h1 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h1><ol>
<li>如何通过URL传递参数：&lt;Route path=”/topic:id” …/&gt;</li>
<li>如何获取参数: this.props.match.params</li>
<li><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">https://github.com/pillarjs/path-to-regexp</a> 通过正则表达式的方式做模糊正则匹配</li>
</ol>
<h1 id="何时需要URL参数"><a href="#何时需要URL参数" class="headerlink" title="何时需要URL参数"></a>何时需要URL参数</h1><p>页面状态尽量通过URL参数来定义</p>
<p>React Router中url变化，组件也会刷新</p>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><ol>
<li>每个React组件都可以是路由容器</li>
<li>React Router声明式语法可以方便的定义嵌套路由</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>13、React：Redux——理解不可变数据（immutable data）</title>
    <url>/2019/01/13/13%E3%80%81React%EF%BC%9ARedux%E2%80%94%E2%80%94%E7%90%86%E8%A7%A3%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%EF%BC%88immutable%20data%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Redux中的不可变数据"><a href="#Redux中的不可变数据" class="headerlink" title="Redux中的不可变数据"></a>Redux中的不可变数据</h1><p>Redux的store每一个结点都是不可变数据，修改它必须通过复制一份的方式进行，不能直接修改。</p>
<p>是Redux的运行基础。</p>
<h1 id="为什么需要不可变数据"><a href="#为什么需要不可变数据" class="headerlink" title="为什么需要不可变数据"></a>为什么需要不可变数据</h1><ol>
<li>性能优化，不需要遍历数据，只需要比较引用就可以确定当前的store有没有变，从而决定是否更新组件；</li>
<li>易于调试和跟踪；</li>
<li>易于推测，比较action前后store的值</li>
</ol>
<h1 id="如何操作不可变数据"><a href="#如何操作不可变数据" class="headerlink" title="如何操作不可变数据"></a>如何操作不可变数据</h1><ol>
<li>原生写法：{…},Object.assign</li>
<li>immutability-helper</li>
<li>immer 性能稍弱</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> update <span class="keyword">from</span> <span class="string">'immutability-helper'</span>;</span><br><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果操作不可变数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;<span class="attr">filter</span>: <span class="string">'completed'</span>, <span class="attr">todos</span>: [<span class="string">'Learn React'</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原生写法</span></span><br><span class="line"><span class="comment">//通过延展属性</span></span><br><span class="line"><span class="keyword">const</span> newState = &#123;...state, <span class="attr">todos</span>: [...state.todos, <span class="string">'Learn Redux'</span>]&#125;</span><br><span class="line"><span class="comment">//Es6写法  性能最高的写法</span></span><br><span class="line"><span class="keyword">const</span> newState2 = <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;<span class="attr">todos</span>: [...state.todos, <span class="string">'Learn Redux'</span>]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂场景，比如对象层级比较深</span></span><br><span class="line"><span class="keyword">const</span> newState3 = update(state, &#123;<span class="attr">todos</span>: &#123;<span class="attr">$push</span>: [<span class="string">'Learn Redux'</span>]&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//immer 需要为每个属性做代理，性能稍差，适用与简单场景，属性较多或层级较深时慎用</span></span><br><span class="line"><span class="keyword">const</span> newState4 = produce(state, draftState =&gt; &#123;</span><br><span class="line">    draftState.todos.push(<span class="string">'Learn Redux'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>12、React：如何在Redux中组织Action和Reducer</title>
    <url>/2019/01/12/12%E3%80%81React%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Redux%E4%B8%AD%E7%BB%84%E7%BB%87Action%E5%92%8CReducer/</url>
    <content><![CDATA[<h1 id="“标准”形式Redux-Action的问题"><a href="#“标准”形式Redux-Action的问题" class="headerlink" title="“标准”形式Redux Action的问题"></a>“标准”形式Redux Action的问题</h1><ol>
<li>所有Action放一个文件，会无限扩展</li>
<li>Action、Reducer分开放，实现业务逻辑时需要来回切换</li>
<li>不能直观的看到系统中有哪些ACtion</li>
</ol>
<p>例如：<a href="https://github.com/reduxjs/redux/tree/master/examples/todomvc/src/actions" target="_blank" rel="noopener">https://github.com/reduxjs/redux/tree/master/examples/todomvc/src/actions</a></p>
<h1 id="新的方式"><a href="#新的方式" class="headerlink" title="新的方式"></a>新的方式</h1><p>单个action和reducer放在同一个文件</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/action-reducer-file.png" alt="image"></p>
<ol>
<li>易于开发：不用在action和reducer文件件来回切换</li>
<li>易于维护：每个action文件都很小，容易理解</li>
<li>易于测试：每个业务逻辑只需要对应一个测试文件</li>
<li>易于理解：没见名就是action名字，文件列表就是action列表</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>11、React：Redux——理解异步Action、Redux中间件</title>
    <url>/2019/01/11/11%E3%80%81React%EF%BC%9ARedux%E2%80%94%E2%80%94%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5Action%E3%80%81Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Redux异步Action"><a href="#Redux异步Action" class="headerlink" title="Redux异步Action"></a>Redux异步Action</h1><p>异步action不是特殊action，而是多个同步action的组合使用</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/redux%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="image"></p>
<h1 id="Redux中间件（Middleware）"><a href="#Redux中间件（Middleware）" class="headerlink" title="Redux中间件（Middleware）"></a>Redux中间件（Middleware）</h1><p>中间件在dispatcher中截获action做特殊处理</p>
<ol>
<li>截获action</li>
<li>发出action</li>
</ol>
<h1 id="中间件应用场景"><a href="#中间件应用场景" class="headerlink" title="中间件应用场景"></a>中间件应用场景</h1><p>日志：</p>
<p>通过日志中间件打印所有action，方便调试</p>
<h1 id="Redux异步Action-Demo"><a href="#Redux异步Action-Demo" class="headerlink" title="Redux异步Action Demo"></a>Redux异步Action Demo</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>异步action不是特殊的action，而是多个同步action的组合使用</li>
<li>中间件在dispatcher中截获action做特殊处理</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>10、React：在React中使用Redux</title>
    <url>/2019/01/10/10%E3%80%81React%EF%BC%9A%E5%9C%A8React%E4%B8%AD%E4%BD%BF%E7%94%A8Redux/</url>
    <content><![CDATA[<h1 id="组件和Store的关系"><a href="#组件和Store的关系" class="headerlink" title="组件和Store的关系"></a>组件和Store的关系</h1><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/react-component-store.png" alt="image"></p>
<p>通过connect组件连接Component和Store,redux提供了react-redux包，里面提供了connect组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;connect&#125; from &#39;react-redux&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="connect组件的工作原理：高阶组件"><a href="#connect组件的工作原理：高阶组件" class="headerlink" title="connect组件的工作原理：高阶组件"></a>connect组件的工作原理：高阶组件</h2><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/react-connect-hoc.png" alt="react-connect-hoc"></p>
<p><a href="https://github.com/liubaolin/evolutionary/blob/master/JS/react-cli-demo/src/Redux/Counter.js" target="_blank" rel="noopener">代码示例</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>9、React：理解Store、Action、Reducer</title>
    <url>/2019/01/09/9%E3%80%81React%EF%BC%9A%E7%90%86%E8%A7%A3Store%E3%80%81Action%E3%80%81Reducer/</url>
    <content><![CDATA[<h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><p>负责管理所有的全局状态</p>
<p>产生一个Store</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>

<p>store有３个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getState(); 获得数据</span><br><span class="line">dispatch(action);</span><br><span class="line">subscribe(listener);　监听store的变化</span><br></pre></td></tr></table></figure>

<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/store.png" alt="store结构"></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>一个action其实是描述了一个行为的数据结构．</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">｛</span><br><span class="line">    type:ADD_TODO，</span><br><span class="line">    text:<span class="string">'Build my first Redux app '</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h1 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h1><p>reducer是一个函数，接受两个参数，第一个是state，第二个是action.</p>
<p>state是指指卡的状态，如果没有可以初始化为initialState,</p>
<p>所有的reducer会接收到所有的action，即一个action通过dispatch出去，所有系统中定义的reduce都能接收到，通过action.type来判断是否要执行．</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = initialState,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">        todos:[</span><br><span class="line">          ...state.todos,</span><br><span class="line">          &#123;</span><br><span class="line">            text:action.text,</span><br><span class="line">            completed:<span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/redux-data-flow.png" alt="redux-data-flow"></p>
<h1 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h1><ul>
<li><p>combineReducers</p>
<p>  将多个Reducer封装在一起，返回一个新的Reducer</p>
</li>
<li><p>bindActionCreators</p>
<p>  帮我我们封装dispatch事件</p>
</li>
</ul>
<h1 id="在JavaScript中使用Redux"><a href="#在JavaScript中使用Redux" class="headerlink" title="在JavaScript中使用Redux"></a>在JavaScript中使用Redux</h1><p>Redux可以单独的在js中使用，如下：</p>
<p><a href="https://github.com/liubaolin/evolutionary/blob/master/JS/react-cli-demo/src/Redux/PureRedux.js" target="_blank" rel="noopener">Redux使用demo</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>8、React：Redux简介</title>
    <url>/2019/01/08/8%E3%80%81React%EF%BC%9ARedux%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Redux是一个js的状态管理框架，Redux中提供了’react-redux’组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;connect&#125; from &#39;react-redux&#39;;</span><br></pre></td></tr></table></figure>

<h1 id="Redux核心概念"><a href="#Redux核心概念" class="headerlink" title="Redux核心概念"></a>Redux核心概念</h1><p>Redux全局只有唯一的一个Store，这个Store负责提供整个应用程序所有的状态；</p>
<p>Redux数据是一个tree的结构；</p>
<p>Redux让组件通信更加容易；</p>
<p>  <img src="http://blog-pic-1254088127.picsh.myqcloud.com/redux-communication.png" alt="Redux组件通信"></p>
<h1 id="Redux特性"><a href="#Redux特性" class="headerlink" title="Redux特性"></a>Redux特性</h1><h2 id="Single-Source-of-Truth"><a href="#Single-Source-of-Truth" class="headerlink" title="Single Source of Truth"></a>Single Source of Truth</h2><p>  传统MVC和视图和数据模型<br>  <img src="http://blog-pic-1254088127.picsh.myqcloud.com/mvc-view-module.png" alt="mvc-view-module"></p>
<p>  Redux视图数据模型<br>  <img src="http://blog-pic-1254088127.picsh.myqcloud.com/redux-view-module.png" alt="redux-view-module"></p>
<h2 id="可预测性"><a href="#可预测性" class="headerlink" title="可预测性"></a>可预测性</h2><p>产生新的状态肯定是由一个action触发的：state + action = new state</p>
<h2 id="纯函数更新Store"><a href="#纯函数更新Store" class="headerlink" title="纯函数更新Store"></a>纯函数更新Store</h2><p>纯函数的输出结果完全取决于输入参数，函数的内部不依赖任何的外部数据和外部资源。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>7、React 打包部署</title>
    <url>/2019/01/07/7%E3%80%81React%20%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="为什么需要打包？"><a href="#为什么需要打包？" class="headerlink" title="为什么需要打包？"></a>为什么需要打包？</h1><ol>
<li>编译ES6语法特性，编译JSX</li>
<li>整合资源，例如图片，Less/Sass</li>
<li>优化代码体积</li>
</ol>
<h1 id="使用Webpack进行打包"><a href="#使用Webpack进行打包" class="headerlink" title="使用Webpack进行打包"></a>使用Webpack进行打包</h1><h1 id="打包注意事项"><a href="#打包注意事项" class="headerlink" title="打包注意事项"></a>打包注意事项</h1><ol>
<li>设置nodejs环境为production</li>
</ol>
<ol start="2">
<li>禁用开发时的专用代码，如logger</li>
</ol>
<ol start="3">
<li><p>设置应用根路径</p>
<p>修改package.json配置文件的”homepage”:””</p>
</li>
</ol>
<h1 id="create-reacat-app-打包命令"><a href="#create-reacat-app-打包命令" class="headerlink" title="create-reacat-app 打包命令"></a>create-reacat-app 打包命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>6、React-新的Contet API及使用场景</title>
    <url>/2019/01/06/6%E3%80%81React-%E6%96%B0%E7%9A%84Contet%20API%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="React-16-3新特性-Context-API"><a href="#React-16-3新特性-Context-API" class="headerlink" title="React 16.3新特性:Context API"></a>React 16.3新特性:Context API</h1><p>要解决的还是组件间通讯的问题，有些全局的状态，很多组件都会去使用，但是如果所有的属性都是一层层的传递下来，非常麻烦。</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/react-context-api.png" alt="image"></p>
<p><a href="https://github.com/liubaolin/evolutionary/blob/master/JS/react-cli-demo/src/LocaleSample/LocaleSample.js" target="_blank" rel="noopener">代码片段</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>5、React高阶组件(HOC)和函数作为子组件</title>
    <url>/2019/01/05/5%E3%80%81React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6(HOC)%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>组件复用的另外两种形式:</p>
<ol>
<li>高阶组件（HOC）</li>
<li>函数作为子组件</li>
</ol>
<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>高阶组件实际是对已有组件的一个封装,来返回一个新的组件.新的组件会包含一些应用逻辑,这些新的逻辑会产生新的状态,这些状态会传给新的组件.</p>
<p>高阶组件一般不会有额外的UI展现,只是为它封装的组件提供额外的功能或者数据.</p>
<p>高阶组件可以自己去获取外部资源.</p>
<ul>
<li>创建一个高阶组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; highterOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>

<pre><code>高阶组件可以接受一个组件参数,并返回一个新的组件.</code></pre><h1 id="函数作为子组件"><a href="#函数作为子组件" class="headerlink" title="函数作为子组件"></a>函数作为子组件</h1><p>snippet:<br><a href="https://github.com/liubaolin/evolutionary/blob/master/JS/react-cli-demo/src/TabSelector/AdvanceTabSelector.js" target="_blank" rel="noopener">函数作为子组件</a></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>高阶组件和函数子组件都是设计模式</li>
<li>可以实现更多场景的组件复用</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>4、React-理解Virtual DOM及key属性的作用</title>
    <url>/2019/01/04/4%E3%80%81React-%E7%90%86%E8%A7%A3Virtual%20DOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>JSX的运行基础:Virtual DOM</p>
<p>React组件在内部维护了一套虚拟DOM的状态,这套虚拟DOM的状态最终会映射到真实DOM的节点上,当虚拟DOM发生变化的时候,内部需要计算虚拟DOM的区别来产生一个diff,并不会刷新所有的真实DOM,只会更新diff的部份.</p>
<h1 id="虚拟DOM是如何工作的"><a href="#虚拟DOM是如何工作的" class="headerlink" title="虚拟DOM是如何工作的"></a>虚拟DOM是如何工作的</h1><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/%E8%99%9A%E6%8B%9FDOM%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.png" alt="image"></p>
<h1 id="虚拟DOM的两个假设"><a href="#虚拟DOM的两个假设" class="headerlink" title="虚拟DOM的两个假设"></a>虚拟DOM的两个假设</h1><ol>
<li>组件的DOM结构是相对稳定的</li>
<li>类型相同的兄节点可以被唯一标识</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>3、React组件及其生命周期和使用场景</title>
    <url>/2019/01/03/3%E3%80%81React%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="理解React组件"><a href="#理解React组件" class="headerlink" title="理解React组件"></a>理解React组件</h1><ol>
<li>React组件一般不提供方法，而是提供某种状态机</li>
<li>React组件可以理解为一个纯函数（接收的参数是什么，则输出的结果是确定的）</li>
<li>单向数据绑定，数据变动同通过事件告诉外部</li>
</ol>
<h2 id="一个简单的React组件"><a href="#一个简单的React组件" class="headerlink" title="一个简单的React组件"></a>一个简单的React组件</h2><ol>
<li><p>创建静态UI</p>
</li>
<li><p>考虑组件的状态组成</p>
<p> 来自外部或者在内部维护</p>
</li>
<li><p>考虑组件的交互方式</p>
</li>
</ol>
<h2 id="受控组件VS非受控组件"><a href="#受控组件VS非受控组件" class="headerlink" title="受控组件VS非受控组件"></a>受控组件VS非受控组件</h2><p>主用应用与form表单中</p>
<ol>
<li><p>受控组件</p>
<p> 表单元素状态由使用者维护，必须指定value和onChange，<br> 即value的值是来自于外部的属性，而不是用户的输入。</p>
</li>
<li><p>非受控组件</p>
<p> 表单元素状态DOM自身维护；</p>
</li>
</ol>
<h2 id="创建React组件的几个原则"><a href="#创建React组件的几个原则" class="headerlink" title="创建React组件的几个原则"></a>创建React组件的几个原则</h2><ol>
<li><p>单一职责原则</p>
<ul>
<li>每个组件只做一件事；</li>
<li>如果组件变得负责，那么因该拆分成小组件</li>
</ul>
</li>
<li><p>数据状态管理:DRY原则</p>
<ul>
<li>能计算得到的状态就不要单独存储</li>
<li>组件尽量无状态，所需数据通过props获取</li>
</ul>
</li>
</ol>
<h1 id="React组件生命周期"><a href="#React组件生命周期" class="headerlink" title="React组件生命周期"></a>React组件生命周期</h1><p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/react-lifecycle-methods.png" alt="image"></p>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><ol>
<li>用于初始化内部状态,很少使用</li>
<li>唯一可以直接修改state的地方</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state.xxx &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<h1 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h1><ol>
<li>当state需要从props初始化时使用</li>
<li>尽量不要使用:维护两者状态一致性会增加复杂度</li>
<li>每次render都会调用</li>
<li>典型场景:表单控件获取默认值</li>
</ol>
<h1 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h1><ol>
<li>UI渲染完成后调用</li>
<li>值执行一次</li>
<li>典型场景:获取外部资源</li>
</ol>
<h1 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h1><ol>
<li>组件移除时调用</li>
<li>典型场景:资源释放</li>
</ol>
<h1 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h1><ol>
<li>在页面render之前调用,state已更新</li>
<li>典型场景:获取render之前的DOM状态</li>
</ol>
<h1 id="componentDisUpdate"><a href="#componentDisUpdate" class="headerlink" title="componentDisUpdate"></a>componentDisUpdate</h1><ol>
<li>每次UI更新时被调用</li>
<li>典型场景:页面需要根据props变化重新获取数据</li>
</ol>
<h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><ol>
<li>决定Virtual DOM是否要重绘</li>
<li>一般可以有PureComponent自动实现</li>
<li>典型场景:性能优化</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>2、React-JSX</title>
    <url>/2019/01/02/2%E3%80%81React-JSX/</url>
    <content><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>不是模板语言,只是一种语法糖,其实就是在JavaScript代码中直接写HTML的标记.</p>
<p>本质:动态创建组件的语法糖.</p>
<h1 id="在JSX中使用表达式"><a href="#在JSX中使用表达式" class="headerlink" title="在JSX中使用表达式"></a>在JSX中使用表达式</h1><p>表达式是会返回值的一个javaScript语法</p>
<ol>
<li>JSX本身也是表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello,world!&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在属性中使用表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent foo&#x3D;&#123;1+2+3+4&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>延展属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const props &#x3D; &#123;firstName:&#39;Ben&#39;,lastName:&#39;Hector&#39;&#125;;</span><br><span class="line">const greeting &#x3D; &lt;Greeting &#123;...props&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>表达式作为资源素</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;li&gt;&#123;props.message&#125;&lt;&#x2F;li&gt;;</span><br></pre></td></tr></table></figure>


<h1 id="JSX优点"><a href="#JSX优点" class="headerlink" title="JSX优点"></a>JSX优点</h1><ol>
<li>声明式创建界面的直观</li>
<li>代码动态创建页面的灵活</li>
<li>无需学习新的模板语言</li>
</ol>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><ol>
<li>React认为小写的tag是原生的DOM节点,如div</li>
<li>大写字母开头的为自定义组件</li>
<li>JSX标记可以直接使用属性语法,如&lt;menu.item /&gt;</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>1、React脚手架</title>
    <url>/2019/01/01/1%E3%80%81React%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="相关技术栈"><a href="#相关技术栈" class="headerlink" title="相关技术栈"></a>相关技术栈</h2><ul>
<li>Redux 用来做状态管理</li>
<li>REACT/ROUTER 路由管理</li>
<li>BABEL 最新JavaScript特性翻译成浏览器兼容的旧的JavaScript语法</li>
<li>webpack 打包</li>
<li>ESLint　语法检查</li>
</ul>
<h2 id="Create-React-App"><a href="#Create-React-App" class="headerlink" title="Create React App"></a>Create React App</h2><p>fackbook 推出的命令行工具，可以快速生成一个React Application项目</p>
<p>整合了Babel/Webpack Config/Testing/ESLint…</p>
<p>入门级的命令行工具，采取最简策略，只引入了必要的包</p>
<h2 id="Rekit"><a href="#Rekit" class="headerlink" title="Rekit"></a>Rekit</h2><p>整合了Babel/Webpack Config/Testing/ESLint　＋　Redux/React Router/Less(Scss)/Feature oriented Architecture/Dedicated IDE</p>
<h2 id="Codesandbox"><a href="#Codesandbox" class="headerlink" title="Codesandbox"></a>Codesandbox</h2><p>在线开发平台Codesandbox.io.</p>
<p>开发者可以不用关心项目配置的细节，打包，部署，build．．．</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Linux常用软件</title>
    <url>/2018/08/10/%E6%88%91%E7%9A%84Linux%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h1><ul>
<li><p>remmina</p>
<pre><code>sudo dnf install remmina</code></pre></li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><ul>
<li><p>chrome</p>
<ul>
<li><p>Fedora安装Chrom</p>
<pre><code>cd /etc/yum.repos.d/    
wget  http://repo.fdzh.org/chrome/google-chrome-mirrors.repo
dnf install -y google-chrome-stable</code></pre></li>
</ul>
</li>
</ul>
<h1 id="shadowsocket-服务"><a href="#shadowsocket-服务" class="headerlink" title="shadowsocket 服务"></a>shadowsocket 服务</h1><h1 id="FZUG源"><a href="#FZUG源" class="headerlink" title="FZUG源"></a>FZUG源</h1><p>  <a href="https://github.com/FZUG/repo/wiki/%E6%B7%BB%E5%8A%A0-FZUG-%E6%BA%90" target="_blank" rel="noopener">安装 FZUG 源</a></p>
<h1 id="UML工具"><a href="#UML工具" class="headerlink" title="UML工具"></a>UML工具</h1><p>  <a href="http://www.umlet.com/" target="_blank" rel="noopener">Umlet</a></p>
<p>  <a href="http://staruml.io/" target="_blank" rel="noopener">Staruml</a></p>
<h1 id="正则表达式工具"><a href="#正则表达式工具" class="headerlink" title="正则表达式工具"></a>正则表达式工具</h1><p>  <a href="http://www.regexbuddy.com/" target="_blank" rel="noopener">regexbuddy</a></p>
<h1 id="端口管理"><a href="#端口管理" class="headerlink" title="端口管理"></a>端口管理</h1><pre><code>nmap</code></pre><h1 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h1><pre><code>flameshot

添加到快捷键命令: flameshot gui</code></pre><h1 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h1><pre><code>Cacher</code></pre><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>DBeaver</p>
<h1 id="Atom插件"><a href="#Atom插件" class="headerlink" title="Atom插件"></a>Atom插件</h1><pre><code>列编辑插件

sublime-style-column-selection</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Linux初始化init系统</title>
    <url>/2015/09/03/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>转自<a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html</a></p>
<p>该系列共有3部份内容<br>第 1 部分: sysvinit<br>第 2 部分: UpStart<br>第 3 部分: Systemd</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志（2）-日志使用模式</title>
    <url>/2015/06/26/java%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89-%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>log4j是一个日志系统。</p>
<p>slf4j是一个日志系统的封装，对外提供统一的API使用slf4j需要下载： slf4j-api-x.x.x.jar（它提供对外一致的API接口，其本身不提供日志实现）。 假设我们选择log4j作为我们的日志实现，需要下载： log4j-x.x.x.jar 如果想把slf4j绑定log4j，则需要下载slf4j对log4j的相应驱动： slf4j-log4j12-x.x.x.jar （这样就可以使用slf4j提供的API，用log4j实现打日志了）。 所谓驱动，就是实现了slf4j的一些接口，用你喜欢的日志系统打日志。 slf4j还支持好多日志系统，并提供了相应的“驱动”包 例如：</p>
<p>slf4j-jdk14-x.x.x.jar是为java.util.logging提供的驱动</p>
<p>slf4j-simple-x.x.x.jar直接绑定System.err</p>
<p>lf4j-jcl-x.x.x.jar是为commons-logging提供的驱动</p>
<p>logback-classic-x.x.x.jar是为logback提供的驱动</p>
<h1 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h1><p>如果你引入了一个第三方jar包或者你之前的工程（本身就是使用的第三方jar包）使用了commons-logging打日志。还有一些组建可能直接调用了 java.util.logging，你想换成slf4j，你不需要更改代码，你需要使用桥接,你可以引入jcl-over-slf4j.jar，同时去掉commons-logging.jar包，这样之前打的日志会自动切换到你的slf4j中来了。 同样还有log4j-over-slf4j.jar and jul-to-slf4j.jar等用于使用其它日志系统的应用自动切换到slf4j统一打日志。</p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志（3）-sl4j驱动和桥接</title>
    <url>/2015/06/25/java%E6%97%A5%E5%BF%97%EF%BC%883%EF%BC%89-sl4j%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="slf4j-log4j组合使用模式"><a href="#slf4j-log4j组合使用模式" class="headerlink" title="slf4j+log4j组合使用模式"></a>slf4j+log4j组合使用模式</h2><p>slf4j-api-1.5.11.jar –提供对外一致的API接口</p>
<p>slf4j-log4j12-1.5.11.jar –slf4j对应log4j相应的“驱动”（把slf4j绑定log4j）</p>
<p>log4j-1.2.15.jar</p>
<p>log4j.properties(也可以是 log4j.xml)</p>
<h2 id="JCL-Log4J组合使用模式（即commons-logging-log4j）"><a href="#JCL-Log4J组合使用模式（即commons-logging-log4j）" class="headerlink" title="JCL+Log4J组合使用模式（即commons-logging+log4j）"></a>JCL+Log4J组合使用模式（即commons-logging+log4j）</h2><p>commons-logging-1.1.jar</p>
<p>log4j-1.2.15.jar</p>
<p>log4j.properties</p>
<h1 id="不同的获取logger的方式"><a href="#不同的获取logger的方式" class="headerlink" title="不同的获取logger的方式"></a>不同的获取logger的方式</h1><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">Logger logger= Logger.getLogger(xx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="slf4j-log4j："><a href="#slf4j-log4j：" class="headerlink" title="slf4j+log4j："></a>slf4j+log4j：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">Logger logger = LoggerFactory.getLogger(xx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="jcl-log4j"><a href="#jcl-log4j" class="headerlink" title="jcl+log4j"></a>jcl+log4j</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Log log = LogFactory.getLog(xx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，slf4j与commons-logging只是一个日志门面，实际还是要依赖真正的日志库log4j，虽然slf4j和commons-loggins自带了日志库，但是毕竟log4j才是最强大的。</p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志（1）-组件详解</title>
    <url>/2015/06/21/java%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89-%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="common-logging"><a href="#common-logging" class="headerlink" title="common-logging"></a>common-logging</h1><p>common-logging是apache提供的一个通用的日志接口。用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的logging，common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。当然，common-logging内部有一个Simple logger的简单实现，但是功能很弱。所以使用common-logging，通常都是配合着log4j来使用。</p>
<p>使用它的好处就是，代码依赖是common-logging而非log4j， 避免了和具体的日志方案直接耦合，在有必要时，可以更改日志实现的第三方库。</p>
<p>使用common-logging的常见代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态查找原理：Log 是一个接口声明。LogFactory 的内部会去装载具体的日志系统，并获得实现该Log 接口的实现类。LogFactory 内部装载日志系统的流程如下：</p>
<ul>
<li>首先，寻找org.apache.commons.logging.LogFactory 属性配置。</li>
<li>否则，利用JDK1.3 开始提供的service 发现机制，会扫描classpah 下的META-INF/services/org.apache.commons.logging.LogFactory文件，若找到则装载里面的配置，使用里面的配置。</li>
<li>否则，从Classpath 里寻找commons-logging.properties ，找到则根据里面的配置加载。</li>
<li>否则，使用默认的配置：如果能找到Log4j 则默认使用log4j 实现，如果没有则使用JDK14Logger 实现，再没有则使用commons-logging 内部提供的SimpleLog 实现。</li>
</ul>
<p>从上述加载流程来看，只要引入了log4j 并在classpath 配置了log4j.xml/log4j.properties，则commons-logging 就会使log4j 使用正常，而代码里不需要依赖任何log4j 的代码。</p>
<h1 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a>slf4j</h1><p>slf4j全称为Simple Logging Facade for JAVA，java简单日志门面。类似于Apache Common-Logging，是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。</p>
<p>但是，他在编译时静态绑定真正的Log库。使用SLF4J时，如果你需要使用某一种日志实现，那么你必须选择正确的SLF4J的jar包的集合（各种桥接包）。</p>
<p>使用slf4j的常见代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger; <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slf4j静态绑定原理：SLF4J 会在编译时会绑定import org.slf4j.impl.StaticLoggerBinder; 该类里面实现对具体日志方案的绑定接入。</p>
<p>任何一种基于slf4j 的实现都要有一个这个类。如：org.slf4j.slf4j-log4j12-1.5.6: 提供对 log4j 的一种适配实现。</p>
<p>注意：如果有任意两个实现slf4j 的包同时出现，那么就可能出现问题。</p>
<h1 id="slf4j与commons-logging比较"><a href="#slf4j与commons-logging比较" class="headerlink" title="slf4j与commons-logging比较"></a>slf4j与commons-logging比较</h1><p>common-logging通过动态查找的机制，在程序运行时自动找出真正使用的日志库。由于它使用了ClassLoader寻找和载入底层的日志库， 导致了象OSGI这样的框架无法正常工作，因为OSGI的不同的插件使用自己的ClassLoader。 OSGI的这种机制保证了插件互相独立，然而却使Apache Common-Logging无法工作。</p>
<p>slf4j在编译时静态绑定真正的Log库,因此可以在OSGI中使用。另外，SLF4J 支持参数化的log字符串，避免了之前为了减少字符串拼接的性能损耗而不得不写的if(logger.isDebugEnable())，</p>
<p>现在你可以直接写：logger.debug(“current user is: {}”, user)。拼装消息被推迟到了它能够确定是不是要显示这条消息的时候，但是获取参数的代价并没有幸免。</p>
<h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><p>Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务 器、NT的事件记录器、UNIX Syslog守护进程等；</p>
<p>用户也可以控制每一条日志的输出格式；</p>
<p>通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。</p>
<p>这些可以通过一个配置文件来灵活地进行配置，而不需要修改程序代码。</p>
<h1 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h1><p>Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。</p>
<h1 id="Log4j-与-LogBack-比较"><a href="#Log4j-与-LogBack-比较" class="headerlink" title="Log4j 与 LogBack 比较"></a>Log4j 与 LogBack 比较</h1><p>LogBack作为一个通用可靠、快速灵活的日志框架，将作为Log4j的替代和SLF4J组成新的日志系统的完整实现。LOGBack声称具有极佳的性能，“ 某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在LogBack中需要3纳秒，而在Log4J中则需要30纳秒。 LogBack创建记录器（logger）的速度也更快：13微秒，而在Log4J中需要23微秒。更重要的是，它获取已存在的记录器只需94纳秒，而 Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的”。 另外，LOGBack的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。</p>
<h1 id="slf4j与其他各种日志组件的桥接"><a href="#slf4j与其他各种日志组件的桥接" class="headerlink" title="slf4j与其他各种日志组件的桥接"></a>slf4j与其他各种日志组件的桥接</h1><p>应用代码中使用slf4j接口，接入具体实现的方法。</p>
<p>应用代码中使用别的日志接口，转成slf4j的方法。</p>
<h1 id="日志组件相关历史"><a href="#日志组件相关历史" class="headerlink" title="日志组件相关历史"></a>日志组件相关历史</h1><p>Java 界里有许多实现日志功能的工具，最早得到广泛使用的是 log4j，许多应用程序的日志部分都交给了 log4j，不过作为组件开发者，他们希望自己的组件不要紧紧依赖某一个工具，毕竟在同一个时候还有很多其他很多日志工具，假如一个应用程序用到了两个组件，恰好两个组件使用不同的日志工具，那么应用程序就会有两份日志输出了。</p>
<p>为了解决这个问题，Apache Commons Logging （之前叫 Jakarta Commons Logging，JCL）粉墨登场，JCL 只提供 log 接口，具体的实现则在运行时动态寻找。这样一来组件开发者只需要针对 JCL 接口开发，而调用组件的应用程序则可以在运行时搭配自己喜好的日志实践工具。</p>
<p>所以即使到现在你仍会看到很多程序应用 JCL + log4j 这种搭配，不过当程序规模越来越庞大时，JCL的动态绑定并不是总能成功，具体原因大家可以 Google 一下，这里就不再赘述了。解决方法之一就是在程序部署时静态绑定指定的日志工具，这就是 SLF4J 产生的原因。</p>
<p>跟 JCL 一样，SLF4J 也是只提供 log 接口，具体的实现是在打包应用程序时所放入的绑定器（名字为 slf4j-XXX-version.jar）来决定，XXX 可以是 log4j12, jdk14, jcl, nop 等，他们实现了跟具体日志工具（比如 log4j）的绑定及代理工作。举个例子：如果一个程序希望用 log4j 日志工具，那么程序只需针对 slf4j-api 接口编程，然后在打包时再放入 slf4j-log4j12-version.jar 和 log4j.jar 就可以了。</p>
<p>现在还有一个问题，假如你正在开发应用程序所调用的组件当中已经使用了 JCL 的，还有一些组建可能直接调用了 java.util.logging，这时你需要一个桥接器（名字为 XXX-over-slf4j.jar）把他们的日志输出重定向到 SLF4J，所谓的桥接器就是一个假的日志实现工具，比如当你把 jcl-over-slf4j.jar 放到 CLASS_PATH 时，即使某个组件原本是通过 JCL 输出日志的，现在却会被 jcl-over-slf4j “骗到”SLF4J 里，然后 SLF4J 又会根据绑定器把日志交给具体的日志实现工具。</p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>SERVLET02-Servlet生命周期</title>
    <url>/2014/03/06/SERVLET02-Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="什么是Servlet生命周期？"><a href="#什么是Servlet生命周期？" class="headerlink" title="什么是Servlet生命周期？"></a>什么是Servlet生命周期？</h1><p>Servlet容器如何去创建Servlet对象，如何初始化，如何调用Sevlet对象的方法去处理请求以及如何销毁Servlet的整个过程。</p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><ul>
<li>什么是实例化<br>容器调用Servlet的构造器，创建一个Servlet对象。</li>
<li>什么时候实例化<br>情况1：容器在收到请求后才创建Servlet对象；</li>
</ul>
<p>情况2：容器在启动的时候就创建Servlet对象；</p>
<p>web应用描述文件web.xml中配置Servlet的加载方式</p>
<p>它的值必须是一个整数，表示servlet应该被载入的顺序;<br>当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet;<br>当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载;<br>正数的值越小，该servlet的优先级越高，应用启动时就越先加载;<br>当值相同时，容器就会自己选择顺序来加载。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：Servlet在默认情况下，对每个Servlet，只会创建一个实例。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>什么是初始化？</p>
<p>容器在创建好Servlet对象后会立即调用对象的init()方法；</p>
<p>GenericServlet提供的init方法已经提供了init方法，一般情况下，我们不再需要写init方法了。 GenericServlet提供的init方法是这样实现的： 将容器提供的ServletConfig对象赋值给本地的ServletConfig，并且提供了getServletConfig方法用来获得ServletConfig对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　   <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span>　</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.config = config;</span><br><span class="line">    init();　　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里提供了init方法，方便我们在Servlet中重写，实现自己的初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Servlet的初始化参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.richey88.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 配置一些初始化参数,一个Servlet可以配置多个初始化参数</span></span><br><span class="line"><span class="comment">          init-param 是Servlet范围内的参数，只能在servlet中的init()方法中获得</span></span><br><span class="line"><span class="comment">          获取方式：String value = this.getInitParameter("key");</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>message<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>welcome to myservlet<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h2><p>什么是就绪？</p>
<p>Servlet容器在收到请求后会调用servlet的service方法来处理请求。</p>
<p>HttpServlet中的service()方法是如何实现的？ 依据请求方式(get/post)分别调用doGet/doPost方法。 可以override Httpservlet提供的doGet和doPost方法，也可以直接override HttpServlet提供的service方法。</p>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>什么是销毁？</p>
<p>Servlet容器根据自身的算法，会在不需要Servlet对象的时候调用该对象的destroy()方法，删除该对象。</p>
<p>GenericServlet已经实现了destroy（）方法。</p>
<p>该方法只会执行一次</p>
<h1 id="Servlet生命周期相关的接口与类"><a href="#Servlet生命周期相关的接口与类" class="headerlink" title="Servlet生命周期相关的接口与类"></a>Servlet生命周期相关的接口与类</h1><h2 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">init（ServletConfig config）</span><br><span class="line">service（ServletRequest request，ServletResponse response）</span><br></pre></td></tr></table></figure>

<h2 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h2><p>实现了Servlet接口中的部分方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">init()</span><br><span class="line">destroy()</span><br><span class="line">getServletContext（）</span><br></pre></td></tr></table></figure>
<h2 id="HttpServlet抽象类"><a href="#HttpServlet抽象类" class="headerlink" title="HttpServlet抽象类"></a>HttpServlet抽象类</h2><p>继承了 GenericServlet抽象类</p>
<p>ServletRequest接口是HttpServletRequest接口的父接口。</p>
<p>ServletResponse接口是HttpServletResponse接口的父接口。 destroy()</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/servlet01.png" alt="Servlet 生命周期时序图"></p>
]]></content>
      <categories>
        <category>java-web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SERVLET01-Servlet概述及编写</title>
    <url>/2014/03/04/SERVLET01-Servlet%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="Servlet是什么？"><a href="#Servlet是什么？" class="headerlink" title="Servlet是什么？"></a>Servlet是什么？</h1><p>Servlet是sun公司制定的一种用来扩展web服务器功能的组件规范。 1）扩展web服务器功能 早期的web服务器，比如（apache web server、iis）只能够处理静态资源的属性（也就是说，需要事先将html文件写好放在web服务器指定的文件夹下面 ），不能够处理动态资源的请求（也就是说，需要依据用户的请求参数来进行计算，然后生成相应的html内容）。 可以使用cgi程序来扩展web服务器：cgi（common gateway interface）程序一般使用perl，c等语言来写，web服务器会调用cgi程序来进行计算。cgi程序编写复杂，可移植性也不好，现在用的不多了。 Servlet可以用来扩展web服务器功能：简单点来说，Servlet是Java Web的核心程序，Java Web应用程序中的所有请求-响应都是由Servlet来完成的。 2）组件规范 a.组件：符合一定的规范，实现了部分功能的，并且可以部署到容器中运行的软件模块； b.容器：符合一定的规范，提供组件的运行环境，并管理组件的生命周期的程序。 Servlet就是一个组件，主要负责业务逻辑的处理。 Servlet容器（比如Tomcat等），会提供Servlet的运行环境。</p>
<h1 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h1><p>Servlet是一种实现了javax.servlet.Servlet接口的类，Servlet接口规定了特定的方法来处理特定的请求。 Servlet是建立在HTTP规范基础之上的，HTTP/1.1规范支持OPTIONS、GET、POST、HEAD、PUT、DELETE以及TRACE等7种Web访问方式。其中，最常用的是GET和POST，当浏览器以xxx的方式访问网络程序时，Servlet会执行如 void doXxx（HttpServletRequest request，HttpServletResponse response）的方法。例如doGet、doPost等。参数HttpServletRequest和HttpServletResponse分别为客户端请求与服务端响应。</p>
<h1 id="Servlet工作流程"><a href="#Servlet工作流程" class="headerlink" title="Servlet工作流程"></a>Servlet工作流程</h1><p>比如，现在在浏览器中输入地址：<a href="http://localhost:8080/servlet/data" target="_blank" rel="noopener">http://localhost:8080/servlet/data</a></p>
<p>step1、浏览器会根据ip和port与Servlet容器（如Tomcat，Servlet容器同时也是一个简单的web服务器）之间建立连接；<br>step2、浏览器打包（浏览器提交的请求时遵循http协议的文本，包括请求资源路径、参数及一些消息头），发送请求；<br>step3、Servlet容器（如Tomcat）接收请求拆包解析，将请求封装成HttpServletRequest类型的request对象，所有http请求的头数据都可以通过request的响应方法查到，Servlet容器同时会把输出流封装成一个HttpServletResponse类型的对象response，通过设置response对象就可以控制输出的内容；<br>step4、Servlet容器会根据请求资源路径，找到对应的Servlet的配置，然后将该对象实例化，并立即调用对象的init()方法进行初始化；<br>step5、Servlet容器会把request和response作为参数调用servlet的响应方法，例如doGet(request,response)、doPost(request,response)等。request对象中可以获取请求的所有数据，在servlet中进行相应的业务逻辑处理（如读取数据库、权限检查、业务处理等），最后将结果集写到response里面。<br>step6、Servlet容器从response中取出数据并打包发送给浏览器；<br>step7、浏览器拆包，并生产相应的页面。</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/servlet01.png" alt="http"></p>
<h1 id="编写Servlet"><a href="#编写Servlet" class="headerlink" title="编写Servlet"></a>编写Servlet</h1><p>直接实现Servlet接口来编写Servlet并不方便，要实现的方法太多，HttpServlet类已经实现了Servlet接口的所有方法。编写Servlet时直接继承HttpServlet，并覆盖需要的方法即可。一般只需要覆盖doGet()与doPost()或只覆盖Service方法()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.richey88.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.print(<span class="string">"MyServlet中进行业务逻辑处理。。。。"</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置Servlet"><a href="#配置Servlet" class="headerlink" title="配置Servlet"></a>配置Servlet</h1><p>只有Servlet文件是不行的，web容器要知道浏览器要访问的路径对应的的是哪个Servlet，也就是说需要配置Servlet的类文件与访问方式。这个配置在Web应用程序的描述文件web.xml里完成。 web应用程序描述文件WEB.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>servlet_01<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- application范围内的参数 ,在web项目完全启动之前加载参数，常用来加载Spring的配置文件</span></span><br><span class="line"><span class="comment">         获取方式：String context_value = getServletContext().getInitParameter("context_key");</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>context_key<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context_value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>   <span class="comment">&lt;!-- 可以取任意字符串，但是在web.xml里要唯一  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.richey88.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 配置一些初始化参数,一个Servlet可以配置多个初始化参数</span></span><br><span class="line"><span class="comment">          init-param 是Servlet范围内的参数，只能在servlet中的init()方法中获得</span></span><br><span class="line"><span class="comment">          获取方式：String value = this.getInitParameter("key");</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>message<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>welcome to myservlet<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 配置servlet的加载方式，</span></span><br><span class="line"><span class="comment">          它的值必须是一个整数，表示servlet应该被载入的顺序;</span></span><br><span class="line"><span class="comment">          当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet;</span></span><br><span class="line"><span class="comment">          当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载;</span></span><br><span class="line"><span class="comment">          正数的值越小，该servlet的优先级越高，应用启动时就越先加载;</span></span><br><span class="line"><span class="comment">          当值相同时，容器就会自己选择顺序来加载。</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  <span class="comment">&lt;!-- 匹配一次请求是否会执行这个servlet --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Servlet程序文件：MyServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.richey88.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">"应用启动时加载的application范围内的参数：  "</span>+</span><br><span class="line">                            <span class="keyword">this</span>.getServletContext().getInitParameter(<span class="string">"context_key"</span>));</span><br><span class="line">        out.println(<span class="string">"MyServlet 处理业务逻辑。。。"</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getInitParameter(<span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java-web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2014/03/02/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="http协议是什么"><a href="#http协议是什么" class="headerlink" title="http协议是什么"></a>http协议是什么</h1><p>由W3C组织制定的一种应用层协议，用于定义浏览器和WEB服务器之间通信的过程和数据的格式。简单的讲，在浏览器中点击一个连接后，浏览器会向服务器发送一段文本，告诉浏览器要访问的信息。这段文本遵循HTTP协议格式，包含访问方式，所用的HTTP版本、当前的浏览器及当前的页面地址信息等。（下面是用访问<a href="http://www.baidu.com时用httpwatch抓取消息头，关于httpwatch的使用方法网上有很多）" target="_blank" rel="noopener">www.baidu.com时用httpwatch抓取消息头，关于httpwatch的使用方法网上有很多）</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Request-Line)GET&#x2F;HTTP&#x2F;1.1</span><br><span class="line">Accept text&#x2F;html,application&#x2F;xhtml+xml,*&#x2F;*</span><br><span class="line">Accept-Encoding gzip, deflate</span><br><span class="line">Accept-Language zh-CN</span><br><span class="line">Connection Keep-Alive</span><br><span class="line">Cookie BD\_UPN&#x3D;1126314351; ispeed\_lsm&#x3D;2; BD\_LAST\_QID&#x3D;12126890578877287783; BD\_HOME&#x3D;0; BAIDUID&#x3D;C323FECD3763243205877E5BE6138F7D:FG&#x3D;1; BIDUPSID&#x3D;9A5864149C1C43304A1236E12F4C5175; PSTM&#x3D;1444447058; BDRCVFR\[kVc2Ho6h-mm\]&#x3D;I67x6TjHwwYf0; H\_PS\_PSSID&#x3D;17521\_1455\_17619\_14429\_17001\_17470\_17073\_15422\_11730\_17051   </span><br><span class="line">Host www.baidu.com User-Agent Mozilla&#x2F;5.0 (Windows NT 6.1; Trident&#x2F;7.0; rv:11.0) like Gecko X-HttpWatch-RID 41695-10075</span><br></pre></td></tr></table></figure>
<p>服务器知道了网址，便将网页的内容输出给浏览器。输出的内容既可以是html文本，也可以是二进制的数据，如图片、声音、视频等，浏览器会将html文本显示为网页，将二进制的数据还原为图片、声音、视频，予以显示或播放。</p>
<h1 id="通信的过程（http-1-0和http-1-1的区别）"><a href="#通信的过程（http-1-0和http-1-1的区别）" class="headerlink" title="通信的过程（http/1.0和http/1.1的区别）"></a>通信的过程（http/1.0和http/1.1的区别）</h1><p>http/1.0版本和http/1.1版本的通信过程是由很大的差别的，http/1.1全面兼容了http/1.0,目前最通用的标准是HTTP/1.1。 一个WEB站点每天可能要接收百万级别以上的的用户请求，为了提供系统的效率，http/1.0规定浏览器和服务器之间只能保持短暂的连接，服务器不跟踪每个客户也不记录过去的请求。浏览器每次请求都要和服务器建立一个TCP连接，服务器做出响应后立马断开连接。这样可以利用有限的连接个数为更多的客户端提供服务，提高效率，但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如图所示：</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/http01.jpg" alt="http"></p>
<p> 显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。 为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP 1.1协议的客户机与服务器的信息交换过程，如图所示：</p>
<p><img src="http://blog-pic-1254088127.picsh.myqcloud.com/http02.jpg" alt="http"></p>
<p> 总之，http/1.0一次连接只能发送一次请求，http/1.1可以一次连接发送多次请求，如图：</p>
<p> <img src="http://blog-pic-1254088127.picsh.myqcloud.com/http03.jpg" alt="http"></p>
<p> 可见，HTTP/1.1在继承了HTTP/1.0优点的基础上，也克服了HTTP/1.0的性能问题。不仅如此，HTTP/1.1还通过增加更多的请求头和响应头来改进和扩充HTTP/1.0的功能。例如，由于HTTP/1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP/1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP/1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP/1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头，同时http/1.1支持断点续传。</p>
<h1 id="数据的格式"><a href="#数据的格式" class="headerlink" title="数据的格式"></a>数据的格式</h1><h2 id="请求数据包"><a href="#请求数据包" class="headerlink" title="请求数据包"></a>请求数据包</h2><ol>
<li>请求行（请求方式、请求资源路径、协议类型和版本）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Request-Line) GET &#x2F;</span><br><span class="line">v.gif?pid&#x3D;107&amp;url&#x3D;http%3A%2F%2Fzhidao.baidu.com%2F&amp;type&#x3D;0&amp;m&#x3D;11&amp;col&#x3D;502&amp;pn&#x3D;2&amp;t&#x3D;%E7%9F%A5%E9%81%93&amp;ra&#x3D;0.47945168</span><br></pre></td></tr></table></figure></li>
<li>若干消息头 消息头是一些键值对，通信的双方都可以发送。比如浏览器可以发送”User-Agent”消息头，告诉服务器浏览器的类型和版本， 一般来说，消息头是自动生成的。有些时候需要编程生成一些消息头。</li>
<li>实体内容 如果发送get请求，实体内容为空。 只有发送post请求时，实体内容才会有数据（即请求参数值，比如name=tom），如果发送的是get请求，请求参数会放在请求资源路径的后面。</li>
</ol>
<h2 id="响应数据包"><a href="#响应数据包" class="headerlink" title="响应数据包"></a>响应数据包</h2><ol>
<li><p>状态行（协议类型和版本、状态码、状态描状态行述）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept text&#x2F;html, application&#x2F;xhtml+xml, *&#x2F;*</span><br><span class="line">Accept-Encoding gzip, deflate</span><br><span class="line">Accept-Language zh-CN</span><br><span class="line">Connection Keep-Alive</span><br><span class="line">Cookie BD\_UPN&#x3D;1126314351; ispeed\_lsm&#x3D;2; BD\_LAST\_QID&#x3D;12126890578877287783; BD\_HOME&#x3D;0; BAIDUID&#x3D;C323FECD3763243205877E5BE6138F7D:FG&#x3D;1; BIDUPSID&#x3D;9A5864149C1C43304A1236E12F4C5175; PSTM&#x3D;1444447058; BDRCVFR\[kVc2Ho6h-mm\]&#x3D;I67x6TjHwwYf0; H\_PS\_PSSID&#x3D;17521\_1455\_17619\_14429\_17001\_17470\_17073\_15422\_11730\_17051</span><br><span class="line">Host www.baidu.com   </span><br><span class="line">User-Agent Mozilla&#x2F;5.0 (Windows NT 6.1; Trident&#x2F;7.0; rv:11.0) like Gecko X-HttpWatch-RID 41695-10075 (Status-Line) HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求 <strong>常见的状态码：</strong><br>200：正常；<br>404：依据请求地址找不到对应的资源<br>500：系统错误，一般是程序运行出现了异常。</p>
</li>
<li><p>若干消息头 服务器也可以向浏览器发送一些消息头，比如”content-type”,告诉浏览器返回的数据类型以及编码格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Ranges bytes Cache-Control max-age&#x3D;0 Content-Length 0 Content-Type image&#x2F;gif Date Mon, 19 Oct 2015 15:14:04 GMT Etag “4280832337” Expires Mon, 19 Oct 2015 15:14:04 GMT Last-Modified Fri, 23 Oct 2009 08:06:04 GMT Pragma no-cache Server BWS&#x2F;1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体内容 程序处理的结果，浏览器会取出这些数据，生成相应的页面。</p>
</li>
</ol>
<h1 id="GET与POST请求"><a href="#GET与POST请求" class="headerlink" title="GET与POST请求"></a>GET与POST请求</h1><ol>
<li>哪些情况浏览器会发送get请求？ a.直接在浏览器地址栏输入某个地址 b.点击链接 c.表单的默认提交方式</li>
<li>哪些情况浏览器会发送post请求？ 表单设置了method=”post”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;处理请求的程序&quot; method&#x3D;&quot;get&#x2F;post&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>get方式的特点 a.会将请求参数添加到请求资源路径的后面，而且只能提交少量的数据给web服务器（get方式提交的网址不能超过256个字符） b.get请求会将请求参数显示在浏览器地址栏，不安全（路由器会记录这些地址）</li>
<li>post方式的特点 a.会将请求参数添加到实体内容中，所以可以提交大量的数据 b.post方式不会将请求参数显示在浏览器地址栏，所以相对安全（但是并没有加密） post请求需要提供要提交的数据类型及长度，数据的类型有两种，一种是普通的文本数据（ASCII数据），类型为”application/x-www-form-urlencoded”，另一种是文件数据（二进制数据），类型为”multipart/form-data”,例如；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;s HTTP&#x2F;1.1 Content-Type:application&#x2F;x-www-form-urlencoded Content-Length:7</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
</search>
